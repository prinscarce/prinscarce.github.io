<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络应用程序设计实验报告</title>
      <link href="/2022/06/25/2022/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/2022/06/25/2022/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="网络应用程序设计实验报告"><a href="#网络应用程序设计实验报告" class="headerlink" title="网络应用程序设计实验报告"></a>网络应用程序设计实验报告</h1><blockquote><p>Ubuntu 20.04</p><p>IntelliJ IDEA Community Edition 2021.3.3</p><p>jdk-17.0.1</p></blockquote><h2 id="1-Linux平台上的TCP并发服务"><a href="#1-Linux平台上的TCP并发服务" class="headerlink" title="1 Linux平台上的TCP并发服务"></a>1 Linux平台上的TCP并发服务</h2><h3 id="一、实验内容"><a href="#一、实验内容" class="headerlink" title="一、实验内容"></a>一、实验内容</h3><p>掌握基本套接字函数使用方法、TCP协议工作原理、并发服务原理和编程方法。实验内容：在Linux平台上实现1个TCP并发服务器，至少可以为10个客户端同时提供服务。</p><ol><li><p>基于TCP套接字编写服务器端程序代码，然后编译和调试；</p></li><li><p>服务器程序要达到：可以绑定从终端输入的IP地址和端口；可以显示每一个进程的进程号；可以显示当前并发执行的进程数量；可以根据客户机要求的服务时间确定进程的生存时间。</p></li><li><p>基于TCP套接字编写客户端程序代码，然后编译和调试；</p></li><li><p>客户端程序要达到：可以从终端输入服务器的IP地址和端口；可以从终端输入对服务器的服务时间要求。</p></li><li><p>联调服务器和客户端，服务器每收到一个连接就新建一个子进程，在子进程中接收客户端的服务时间请求，根据所请求的时间进行延时，然后终止子进程。如：客户端请求服务10s，则服务器的子进程运行10s，然后结束。</p></li><li><p>服务器要清除因并发服务而产生的僵尸进程。</p></li></ol><h3 id="二、实验思想"><a href="#二、实验思想" class="headerlink" title="二、实验思想"></a>二、实验思想</h3><p>服务端进行监听请求，当得到请求后进行子进程的处理，完成后继续监听。这里设置处理上限为10个客户端，用一个数组来进行记录，当超过上限时会显示服务器超进程数。</p><h3 id="三、实验设计"><a href="#三、实验设计" class="headerlink" title="三、实验设计"></a>三、实验设计</h3><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><p>设置进程监控数组，监控函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> maxPro[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;, count = <span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">checksp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* livesp)</span> </span>&#123;<br><span class="hljs-keyword">int</span> count = <span class="hljs-number">-1</span>, i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (maxPro[i] != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (kill(maxPro[i], <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123; maxPro[i] = <span class="hljs-number">0</span>; count = i; &#125;<br>&#125;<br><span class="hljs-keyword">else</span> count = i;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建网络端口并填充地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建网络端点</span><br>sockfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can;t create socket\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">int</span> on = <span class="hljs-number">1</span>;<br>setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="hljs-keyword">sizeof</span>(on));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;reuse addr\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">//填充地址</span><br>bzero(&amp;srvaddr, <span class="hljs-keyword">sizeof</span>(srvaddr));<br>srvaddr.sin_family = AF_INET;<br>srvaddr.sin_port = htons(PORT);<br>srvaddr.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br></code></pre></td></tr></table></figure><p>绑定并监听端口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//bind</span><br><span class="hljs-keyword">if</span> (bind(sockfd, (struct sockaddr*) &amp; srvaddr, <span class="hljs-keyword">sizeof</span>(struct sockaddr)) == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bind error\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//listen</span><br><span class="hljs-keyword">if</span> (listen(sockfd, BACKLOG) == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listen error\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>检查子进程个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;;) &#123;<br>count = checksp(maxPro);<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">-1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;server has been reached maxinum of process!!!\n&quot;</span>); <span class="hljs-keyword">continue</span>; &#125;<br><span class="hljs-keyword">char</span> dest[MAXDATASIZE] = &#123; <span class="hljs-string">&quot;&quot;</span> &#125;;<br>mypid = fork();<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>等待监听过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (mypid == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid:%d  listening...\n&quot;</span>, getpid());<br>sin_size = <span class="hljs-keyword">sizeof</span>(struct sockaddr_in);<br><span class="hljs-keyword">if</span> ((new_fd = accept(sockfd, (struct sockaddr*) &amp; clientaddr, &amp;sin_size)) == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept error\n&quot;</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>获得请求与返回响应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client addr:%s %d\n&quot;</span>, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));<br><span class="hljs-comment">//接收请求</span><br>getchar();<br>nbytes = read(new_fd, buf, MAXDATASIZE);<br>buf[nbytes] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//回送响应</span><br><span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;proc shutdown.&quot;</span>);<br>write(new_fd, buf, <span class="hljs-built_in">strlen</span>(buf));<br></code></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>创建网络端口同理</p><p>指定服务器地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">bzero(&amp;srvaddr,<span class="hljs-keyword">sizeof</span>(srvaddr));<br>srvaddr.sin_family=AF_INET;<br>srvaddr.sin_port=htons(port);<br><br><span class="hljs-keyword">if</span>(inet_aton(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,&amp;srvaddr.sin_addr)==<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr convert error\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>(addr_conv(argv[<span class="hljs-number">1</span>],&amp;srvaddr.sin_addr)==<span class="hljs-number">-1</span>)&#123;<br>perror(strerror(errno));<br>&#125;<br></code></pre></td></tr></table></figure><p>连接服务器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(new_fd = connect(sockfd,(struct sockaddr *)&amp;srvaddr,<span class="hljs-keyword">sizeof</span>(struct sockaddr))==<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect error\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>发送请求与接受响应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">sprintf</span>(buf,<span class="hljs-string">&quot;server time:%d&quot;</span>,surviveTime);<br>send(sockfd,buf,<span class="hljs-built_in">strlen</span>(buf),<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>((nbytes=recv(sockfd,buf,MAXDATASIZE,<span class="hljs-number">0</span>))==<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read error\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>buf[nbytes]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;srv respons:%s\n&quot;</span>,buf);<br>sleep(surviveTime);<br></code></pre></td></tr></table></figure><h3 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h3><p> 仅单个客户端运行</p><p><img src="/images/Network/image-20220625201029271.png"></p><p>多个客户端运行</p><p><img src="/images/Network/image-20220625201057696.png"></p><h2 id="2-进程间的协调通信"><a href="#2-进程间的协调通信" class="headerlink" title="2 进程间的协调通信"></a>2 <strong>进程间的协调通信</strong></h2><h3 id="一、实验内容-1"><a href="#一、实验内容-1" class="headerlink" title="一、实验内容"></a>一、实验内容</h3><p>掌握进程的概念、进程间通信的基本原理、集成间通信的主要类型和各自的特点。实验内容：在linux平台上实现1个父进程、2个子进程，利用管道和共享内存实现两个子进程之间数据快速传送。</p><ol><li><p>创建一个进程，再创建一对管道、一块共享内存（大于64kB）；</p></li><li><p>通过fork（）函数生成2个子进程；</p></li><li><p>调试程序，确定父、子进程之间可以双向通信；</p></li><li><p>调试程序，确定两个子进程之间可以通过父进程中转实现双向通信；</p></li><li><p>调试程序，确定两个子进程都可访问共享内存；</p></li><li><p>实现两个子进程之间无冲突地访问共享内存。传送的数据块不小于32kB，为了能够看到演示效果，读/写每个字节后都延时0.5ms。</p></li></ol><h3 id="二、实验思想-1"><a href="#二、实验思想-1" class="headerlink" title="二、实验思想"></a>二、实验思想</h3><p>管道通信只支持父进程与子进程之间通信，想要完成2子进程之间的通信的话需要通过父进程作为桥梁来通信。当使用fork函数时，子进程继承父进程共享内存空间，这样就不需要再依靠父进程维护通信，只是需要在一个进程读写时加上锁就可以防止读写混乱。</p><h3 id="三、实验设计-1"><a href="#三、实验设计-1" class="headerlink" title="三、实验设计"></a>三、实验设计</h3><h4 id="利用管道通信"><a href="#利用管道通信" class="headerlink" title="利用管道通信"></a>利用管道通信</h4><p>管道初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> pipe1[<span class="hljs-number">2</span>],pipe2[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> pid1,pid2;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">char</span> buf1[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">char</span> buf2[<span class="hljs-number">128</span>];<br><span class="hljs-comment">//init</span><br><span class="hljs-built_in">memset</span>(buf1,<span class="hljs-string">&#x27;\0&#x27;</span>,<span class="hljs-number">128</span>); <br><span class="hljs-built_in">memset</span>(buf2,<span class="hljs-string">&#x27;\0&#x27;</span>,<span class="hljs-number">128</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">pipe</span>(pipe1)&lt;<span class="hljs-number">0</span>||<span class="hljs-built_in">pipe</span>(pipe2)&lt;<span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;pipe error&quot;</span>&lt;&lt;endl;<br>   &#125;<br></code></pre></td></tr></table></figure><p>父进程用管道一读数据，管道二写数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>((pid1=fork())==<span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;childprocess1 failed!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid1 &gt; <span class="hljs-number">0</span>)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;father PID:&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">read</span>(pipe1[<span class="hljs-number">0</span>],buf1,<span class="hljs-number">100</span>)&gt;<span class="hljs-number">0</span>)<br>cout&lt;&lt;<span class="hljs-string">&quot;father received:&quot;</span>&lt;&lt;buf1&lt;&lt;endl;<br><span class="hljs-built_in">write</span>(pipe2[<span class="hljs-number">1</span>],buf1,<span class="hljs-built_in">strlen</span>(buf1));<br>&#125;<br></code></pre></td></tr></table></figure><p>子进程1用管道一写数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid1==<span class="hljs-number">0</span>)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;child1 PID:&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;endl;<br><span class="hljs-comment">//子进程用管道1写数据</span><br><span class="hljs-built_in">close</span>(pipe1[<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭pipe1读端口</span><br><span class="hljs-built_in">close</span>(pipe2[<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭pipe2读端口</span><br><span class="hljs-built_in">close</span>(pipe2[<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭pipe2写端口</span><br><span class="hljs-built_in">write</span>(pipe1[<span class="hljs-number">1</span>],cstr,<span class="hljs-built_in">strlen</span>(cstr));<br>&#125;<br></code></pre></td></tr></table></figure><p>子进程2用管道二读数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid2==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//子进程2用管道2读数据</span><br><span class="hljs-built_in">close</span>(pipe1[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">close</span>(pipe1[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">close</span>(pipe2[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">read</span>(pipe2[<span class="hljs-number">0</span>],buf2,<span class="hljs-number">128</span>)&gt;<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In child2 : pid=%d\n&quot;</span>,<span class="hljs-built_in">getpid</span>());<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In child2 : buf=%s\n&quot;</span>,buf2);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="利用共享内存"><a href="#利用共享内存" class="headerlink" title="利用共享内存"></a>利用共享内存</h4><p>获取由mem_size指定大小的共享内存id</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br>shmid=<span class="hljs-built_in">shmget</span>(key,MEM_SIZE,<span class="hljs-number">0777</span>|IPC_CREAT);<br><span class="hljs-keyword">if</span>(shmid==<span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;shmget error&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>读写锁的实现，子进程1写入，子进程2读出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid1&gt;<span class="hljs-number">0</span>)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;father PID:&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;endl;<br><span class="hljs-built_in">wait</span>(&amp;status);<br>p_addr = (<span class="hljs-keyword">char</span>* )<span class="hljs-built_in">shmat</span>(shmid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>cout&lt;&lt;<span class="hljs-string">&quot;father received:&quot;</span>&lt;&lt;p_addr&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;child1 PID:&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;endl;<br>c1_addr = (<span class="hljs-keyword">char</span>* )<span class="hljs-built_in">shmat</span>(shmid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">memset</span>(c1_addr, <span class="hljs-string">&#x27;\0&#x27;</span>,<span class="hljs-number">1024</span>);<br><span class="hljs-built_in">strncpy</span>(c1_addr,text,<span class="hljs-number">1024</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid2==<span class="hljs-number">0</span>)<br>&#123;<br>c2_addr = (<span class="hljs-keyword">char</span>* )<span class="hljs-built_in">shmat</span>(shmid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>cout&lt;&lt;<span class="hljs-string">&quot;child2 PID:&quot;</span>&lt;&lt;<span class="hljs-built_in">getpid</span>()&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;child2 received:&quot;</span>&lt;&lt;c2_addr&lt;&lt;endl;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、实验结果-1"><a href="#四、实验结果-1" class="headerlink" title="四、实验结果"></a>四、实验结果</h3><p>利用管道通信</p><p><img src="/images/Network/UC3932%25OB682P@@%7D17%5BJQD1.png"></p><p>利用共享内存</p><p><img src="/images/Network/image-20220625203806813.png"></p><h2 id="3-Windows平台上的TCP并发服务"><a href="#3-Windows平台上的TCP并发服务" class="headerlink" title="3 Windows平台上的TCP并发服务"></a>3 Windows平台上的TCP并发服务</h2><h3 id="一、实验内容-2"><a href="#一、实验内容-2" class="headerlink" title="一、实验内容"></a>一、实验内容</h3><p>编程内容与实验1相同，操作系统为windows。了解Windows与Linux平台编程环境的差异，掌握Winsock编程接口及编程方法。</p><h3 id="二、实验思想-2"><a href="#二、实验思想-2" class="headerlink" title="二、实验思想"></a>二、实验思想</h3><p>利用并发服务中的线程池技术来完成本实验，监听端口设为8189</p><h3 id="三、实验设计-2"><a href="#三、实验设计-2" class="headerlink" title="三、实验设计"></a>三、实验设计</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>创建端口并监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Socket socket = <span class="hljs-keyword">null</span>;<br>   ServerSocket listenSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8189</span>);<br></code></pre></td></tr></table></figure><p>接收到客户端请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">socket = listenSocket.accept();<br>System.out.println(<span class="hljs-string">&quot;Accepted connection from client&quot;</span>);<br></code></pre></td></tr></table></figure><p>进行通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream inStream = socket.getInputStream();<br>OutputStream outStream = socket.getOutputStream();<br>BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(inStream));<br>PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(outStream);<br><br>String str = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">while</span>((str=in.readLine())!=<span class="hljs-keyword">null</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;Message from client:&quot;</span> + str);<br>out.println(str);<br>out.flush();<br>   &#125;<br></code></pre></td></tr></table></figure><p>关闭socket</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">socket.close();<br>listenSocket.close();<br></code></pre></td></tr></table></figure><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>创建socket并建立连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">BufferedReader stdIn = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));<br><br>   Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8189</span>);<br>   System.out.println(<span class="hljs-string">&quot;Connected to Server&quot;</span>);<br></code></pre></td></tr></table></figure><p>进行通信与关闭socket</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">   InputStream inStream = socket.getInputStream();<br>   OutputStream outStream = socket.getOutputStream();<br>   BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(inStream));<br>   PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(outStream);<br><span class="hljs-keyword">while</span>((input=stdIn.readLine())!=<span class="hljs-keyword">null</span>)<br>   &#123;<br>       out.println(input);<br>       out.flush();<br>       echoMessage = in.readLine();<br>       System.out.println(<span class="hljs-string">&quot;Echo from server: &quot;</span> + echoMessage);<br>   &#125;<br>   socket.close();<br></code></pre></td></tr></table></figure><h3 id="四、实验结果-2"><a href="#四、实验结果-2" class="headerlink" title="四、实验结果"></a>四、实验结果</h3><p>客户端、服务端连接后，互相通信</p><p><img src="/images/Network/image-20220625205852023.png"></p><p><img src="/images/Network/image-20220625205911199.png"></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 实验报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 实验报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理笔记</title>
      <link href="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><h2 id="老师给的重点"><a href="#老师给的重点" class="headerlink" title="老师给的重点"></a>老师给的重点</h2><h3 id="第一章-概念"><a href="#第一章-概念" class="headerlink" title="第一章 概念"></a>第一章 概念</h3><h3 id="第二章："><a href="#第二章：" class="headerlink" title="第二章："></a>第二章：</h3><ol><li>文字-&gt;正规式</li><li>词法分析器 由源程序输入，输出为记号</li><li>正规式的等价证明</li><li>:star:正规式-&gt;NFA-&gt;DFA-&gt;最小化</li></ol><h3 id="第三章："><a href="#第三章：" class="headerlink" title="第三章："></a>第三章：</h3><ol><li>上下文无关文法</li><li>自动机：下推自动机</li><li>自上而下分析构造预测分析表</li><li>为什么要消除左递归：避免死循环</li><li>自下而上：句柄</li><li>如何证明一个文法是二义文法(二义性??)：有两棵语法树</li><li>SLR1分析表</li></ol><h3 id="第四章："><a href="#第四章：" class="headerlink" title="第四章："></a>第四章：</h3><ol><li>语义规则的两种表达 综合分析</li><li>变量声明</li><li>参数传递</li><li>常用中间代码</li><li>三元式、四元式</li><li>注释语法树</li><li>语义-&gt;中间代码</li><li>声明语句的翻译</li><li>短路计算</li></ol><h2 id="CH1"><a href="#CH1" class="headerlink" title="CH1"></a>CH1</h2><p><strong>词法规则</strong>：单词符号的形成规则</p><p><strong>语法规则</strong>：语法单位的形成规则</p><h3 id="编译程序的五个阶段"><a href="#编译程序的五个阶段" class="headerlink" title="编译程序的五个阶段"></a><strong>编译程序的五个阶段</strong></h3><ul><li>词法分析：输入源程序，对其字符串进行扫描和分解，识别一个个单词（符号）</li><li>语法分析：根据语言的语法规则，将单词符号串分解成各类语法单位</li><li>语义分析与中间代码生成：对上面识别出的各类语法范畴分析其含义，并进行初步翻译（产生中间代码）</li><li>代码优化：对前段产生的中间代码进行加工变换，以求在最后阶段能产生更为高效的目标代码</li><li>目标代码生成：把中间代码变换成特定机器上的低级语言代码</li></ul><p><strong>编译程序的基本结构</strong>：</p><ul><li>表格管理：登记源程序中的各类信息的编译中各阶段的进展状况</li><li>出错处理：处理错误</li></ul><p><strong>编译的遍数</strong>：对源程序/其中间结果从头到尾扫描一次，并做有关的加工处理，生成新的中间结果或目标程序。</p><p>​    因素：源语言、设计要求、硬件设备</p><h4 id="课后填空："><a href="#课后填空：" class="headerlink" title="课后填空："></a>课后填空：</h4><ol><li>编译方式与解释方式的根本区别在于<code>是否生成目标代码</code> </li><li>从功能上说，程序语言的语句大体可分为 <code>执行性语句</code>  和 <code>说明性语句</code> 两大类。</li><li>扫描器的任务是从 <code>源程序</code> 识别出一个个 <code>单词符号</code> 。</li></ol><h4 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h4><ul><li><strong>编译程序</strong>：编译程序是指一种能够把某一种语言程序（源语言程序）转换成另一种语言程序（目标语言程序）的程序。</li><li><strong>语义</strong>：一种语言的单词符号和语法单位的意义。</li><li><strong>语法</strong>：任何语言程序都可以看成是一定字符集（称为字母表）上的一字符串（有限序列）。并且一个程序语言只使用一个有限字符集作为字母表。所谓一个语言的语法是指这样的一组规则，用它可以形成和产生一个合式的程序。</li><li><strong>遍</strong>：同上</li></ul><h4 id="简答题："><a href="#简答题：" class="headerlink" title="简答题："></a>简答题：</h4><ol><li><p><strong>编译程序在逻辑上由哪几部分组成</strong>？</p><p>词法分析，语法分析，语义分析，中间代码生成，中间代码优化和目标代码生成</p></li><li><p><strong>何谓编译的前端和后端</strong>？</p><p>前端主要由与源语言有关但与目标机无关的那部分组成。这些部分通常包括词法分析、语法分析、语义分析与中间代码产生，有的代码优化工作也可包括在前端。</p><p> 后端包括编译程序中与目标机有关的那些部分，如与目标机有关的代码优化和目标代码生成等。通常，后端不依赖于源语言而仅仅依赖于中间语言。</p></li><li><p><strong>画出编译程序的总体结构图，简述各部分的主要功能</strong>。</p><p><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg"></p></li><li><p><strong>试分析编译程序是否分遍应考虑的因素及多遍扫描编译程序的优缺点.</strong></p><p>决定趟程的因素：</p><ul><li>计算机存贮容量大小</li><li>编译程序功能强弱</li><li>源语言繁简</li><li>目标程序优化程度</li><li>设计和实现编译程序时使用工具的先进程度 </li><li>参加人员多少和素质</li></ul><p> 多遍扫描编译程序优点：</p><ul><li><p>加工充分</p></li><li><p>出错处理细致</p></li><li><p>目标程序质量高</p></li></ul><p>缺点：编译时间长，开销大。</p></li></ol><h2 id="CH2"><a href="#CH2" class="headerlink" title="CH2"></a>CH2</h2><p><strong>程序语言的记号</strong>：</p><ul><li>关键字：程序中有固定含义</li><li>标识符：变量名</li><li>字面量：直接写出的数据</li><li>运算符：op</li><li>分界符：标点符号</li></ul><p><strong>词法分析器的任务</strong>：</p><ul><li>识别各个单词符号，将其转换为内部编码形式</li><li>删除无用的空白符、回车及无用的非实质性字符</li><li>删除注释</li><li>进行词法检查，报告错误</li></ul><p><strong>工作方式</strong>：</p><ul><li>独立工作：单独进行一遍扫描，以源程序作为输入，以记号流作为输出</li><li>其作为子程序执行：当语法分析器需要记号时就调用词法分析器，得到一个识别出的记号</li><li>并行工作：提高编译效率，相当于“生产/消费”</li></ul><p><strong>工作过程</strong>：将预处理的源代码（去除注释、无用的空白符、跳格等）读入到输入缓冲区，然后读入固定长度的字符到扫描缓冲区，最后对扫描缓冲区进行符号识别</p><p><strong>语言</strong>：有限字母表Σ上有限长度的字符串的集合</p><p>字符串集合的运算：合并、连接、方幂、Kleene闭包（自反闭包）、正闭包</p><p><strong>正规式</strong>：按照一组定义规则，由较简单的正规式构成，每个正规式r表示一个语言L(r)</p><p>正规式等价：若正规式P和Q表示同一正规集，则称P和Q等价的，记为P=Q</p><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/正规式代数性质.jpg" alt="img" style="zoom:67%;"><p>NFA、DFA</p><h3 id="Thompson算法"><a href="#Thompson算法" class="headerlink" title="Thompson算法"></a><strong>Thompson算法</strong></h3><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/识别NFA1.jpg" alt="img" style="zoom:67%;"><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/识别NFA2.jpg" alt="img" style="zoom:67%;"><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/识别NFA3.jpg" alt="img" style="zoom:67%;"><h3 id="star-DFA最小化（子集法）"><a href="#star-DFA最小化（子集法）" class="headerlink" title=":star:DFA最小化（子集法）"></a>:star:<strong>DFA最小化</strong>（子集法）</h3><ol><li><strong>初始划分：终态与非终态；</strong></li><li><strong>利用可区分的概念，反复分裂划分中的组Gi，直到不可再分裂；</strong></li><li><strong>由最终划分构造D’，关键是选代表和修改状态转移；</strong></li><li><strong>消除可能的死状态和不可达状态。</strong></li></ol><p><code>lex</code>：词法分析器生成器；由定义、识别规则、辅助函数三部分组成</p><p><code>yacc</code>：语法分析器生成器</p><h4 id="课后填空：-1"><a href="#课后填空：-1" class="headerlink" title="课后填空："></a>课后填空：</h4><ol><li><p>词法分析器的任务是从源程序中识别出一个个 <code>单词</code> </p></li><li><p>表示源程序中信息单元的字符序列叫做  <code>记号</code>   </p></li><li><p>有限字母表<strong>S</strong>上有限长度的字符串的集合叫做   <code>语言 </code></p></li><li><p>确定有限自动机 DFA 是 <code>NFA</code> 的一个特例</p></li><li><p>LEX源程序的三个组成部分 <code>定义部分</code> 、<code> 识别规则部分</code> 和<code> 辅助函数部分</code>。</p></li></ol><h4 id="名词解释：-1"><a href="#名词解释：-1" class="headerlink" title="名词解释："></a>名词解释：</h4><p><strong>正规式</strong>：（又称正规表达式）是按照一组定义规则，由较简单的正规式构成的，每个正规式<em>r</em>表示一个语言<em>L</em>(<em>r</em>)。定义规则告诉我们<em>L</em>(<em>r</em>)是怎样以各种方式从<em>r</em>的子正规式所表示的语言组合而成的。</p><p><strong>非确定型有限自动机（NFA）</strong>是一个五元组：</p><p><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/clip_image002.gif" alt="img"></p><p>​    其中：</p><p> （1）S是一个有限的状态（State）集合；</p><p> （2）å（输入符号字母表）是一个输入符号的集合；</p><p> （3）move一个状态转换函数，move <img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/clip_image004.gif" alt="img">表示当前状态<img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/clip_image006.gif" alt="img">下若遇到输入字符ch，则转移到状态<img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/clip_image008.gif" alt="img">；</p><p> （4）状态<img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/clip_image010.gif" alt="img">是唯一的开始状态；</p><p> （5）状态集合F是终态集（接受状态集合）,并且F Í S<em>。</em></p><h4 id="简答题：-1"><a href="#简答题：-1" class="headerlink" title="简答题："></a>简答题：</h4><ol><li><p><strong>简要说明词法分析器的功能</strong>.</p><p>词法分析器的功能为依次扫描字符串形式的源程序中的各个字符，逐个识别出其中的单词，并将其转换为内部编码形式的单词符号串作为输出。</p></li><li><p><strong>简要叙述从正规式构造词法分析器的一般方法和过程</strong></p><p>从正规式构造词法分析器的一般方法和过程如下：</p><ol><li>用正规式对模式进行描述</li><li>为每一个正规式构造NFA</li><li>将构造出的NFA转换成等价的DFA，这一过程也被成为确定化</li><li>把DFA化为最简形式，这一过程也被成为最小化</li><li>从简化后的DFA构造词法分析器</li></ol></li></ol><h2 id="CH3"><a href="#CH3" class="headerlink" title="CH3"></a>CH3</h2><p><strong>0、1、2、3 型文法与自动机</strong>:</p><p> 若文法 G=（N,T,P,S）的每个产生式α→β中，均有 α∈（N∪T)*，且至少含有一个非终结符，β∈（N∪T)*，则称G 为0 型文法。对 0 型文法施加以下第 i 条限制，即可得到 i 型文法。</p><ol><li>G 的任何产生式α→β（S→ε除外）均满足|α|≤|β|（|x|表示x 中文法符号的个数）</li><li>G 的任何产生式 A→β，其中 A∈N，β∈（N∪T)* </li><li>G 的任何产生式 A→α或者 A→aB（或者 A→Ba），其中A,B∈N，a∈T0 型文法→图灵机、1 型文法→线性界限自动机、2 型文法→下推自动机、3 型文法→有限自动机</li></ol><p><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/prinscarce\XDU\STDUY\大三下\编译原理\复习Mine\image-20220615195407770.png" alt="image-20220615195407770"></p><p><strong>CFG 的定义、构成:</strong></p><p>上下文无关文法 CFG 是一个四元组 G=（N,T,P,S）</p><ul><li> N：非终结符有限集合 </li><li> T：终结符有限集合 </li><li> P：产生式有限集合 </li><li> S：是非终结符，被称为文法的开始符号</li></ul><p><strong>文法的二义性</strong>：原因：缺少文法符号优先级，结合性的规定</p><h3 id="自上而下递归"><a href="#自上而下递归" class="headerlink" title="自上而下递归"></a><strong>自上而下递归</strong></h3><p>​    从左到右扫描输入序列，自上而下建立它的语法树</p><p>​    ①公共左因子 避免回溯 ②左递归 避免陷入死循环。需要先消除左递归，再提取左因子。</p><h4 id="消除文法的左递归："><a href="#消除文法的左递归：" class="headerlink" title="消除文法的左递归："></a><strong>消除文法的左递归</strong>：</h4><p>​    改写为 <strong>A-&gt;βA’ ,  A’-&gt;αA’|ε</strong></p><h4 id="消除回溯提取的左因子："><a href="#消除回溯提取的左因子：" class="headerlink" title="消除回溯提取的左因子："></a><strong>消除回溯提取的左因子：</strong></h4><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/image-20220614101355077.png" alt="image-20220614101355077" style="zoom:67%;"><p>​    </p><p><strong>递归下降分析法</strong></p><h3 id="预测分析表"><a href="#预测分析表" class="headerlink" title="预测分析表"></a><strong>预测分析表</strong></h3><ol><li><p>首先构造<strong>FIRST</strong>集合与<strong>FOLLOW</strong>集合</p></li><li><p>然后根据两个集合构造预测分析表</p><p><code>将FIRST(α)加入到预测分析表中，若FIRST集含有ε，再将FOLLOW(α)加入表中(推出ε)</code></p></li></ol><p><strong>下推自动机：</strong></p><p>下推自动机 M 是如下的一个七元组 ( Q, Σ, Γ, δ, q0, Z0, F ) ，其中：</p><ul><li> Q 是一个有穷状态集合；</li><li> Σ 是一个字母表，称为输入字母表。</li><li> Γ 是一个字母表，称为栈字母表。</li><li> q0 属于 Q ，是初始状态。</li><li> Z0 属于 Γ ，是一个特殊的栈符号，称为栈起始符号。</li><li> F 包含于 Q ，是终结状态集合。</li><li> δ : Q×(Σ∪{ε})×Γ -&gt; Q×Γ* 是 M 的动作函数。</li></ul><h3 id="star-FIRST"><a href="#star-FIRST" class="headerlink" title=":star:FIRST"></a>:star:<strong>FIRST</strong></h3><p><strong>从α开始可以推导出的所有开头终结符</strong></p><ol><li>若X∈T，则FIRST(X)={X}；</li><li><strong>若X是非终结符且有X→ε，则加入ε到FIRST(X)；</strong></li><li>若X是非终结符且有X→Y1Y2…Yk，并设Y0=ε，Yk+1=ε。那么对所有j(0≤j≤k)，若a∈FIRST(Yj+1)且ε∈FIRST(Yj),则加入a到FIRST(X)。</li></ol><h3 id="star-FOLLOW"><a href="#star-FOLLOW" class="headerlink" title=":star:FOLLOW"></a>:star:<strong>FOLLOW</strong></h3><p> <strong>从开始符号可以推导出的所有紧跟A之后的终结符</strong></p><ol><li><p>加入&#35;到FOLLOW(S)，其中S是开始符号，&#35;是输入结束标记。</p></li><li><p>若有产生式A→αBβ，则除ε外，FIRST(β)的全体加入到FOLLOW(B)。</p><p><code>Normal: follow(B)+=first(β)-&#123;ε&#125;</code></p></li><li><p>若有产生式A→αB或A→αBβ而ε∈FIRST(β)，则FOLLOW(A)的全体加入到FOLLOW(B)。</p><p><code>若β为ε或β-&gt;ε，则follow(B)+=follow(A)</code></p><p>2、3可能同时满足</p></li></ol><blockquote><p>自下而上计算FIRST、自上而下计算FOLLOW</p></blockquote><blockquote><p>exp: </p></blockquote><blockquote><p>L →E;L|ε<br>E →TE’<br>E’→+TE’|-TE’|ε<br>T →FT’<br>T’→*FT’|/FT’|mod FT’|ε<br>F →(E)|id|num </p></blockquote><blockquote><p>FIRST(F)  =    {(  id  num}<br>FIRST(T’) =    {*  /  mod  ε}<br>FIRST(T)  = FIRST(F) =    {(  id  num}<br>FIRST(E’) =    {+  -  ε}<br>FIRST(E)  = FIRST(T) = FIRST(F) = {(  id  num}<br>FIRST(L)  = {ε}∪FIRST(E) = {ε (  id  num} </p></blockquote><blockquote><p>FOLLOW(L)  = {&#35;}<br>FOLL0W(E)  = {) ;}<br>FOLLOW(E’) = {) ;}<br>FOLLOW(T)  = {+  -  ; )}<br>FOLLOW(T’) = {+  -  ; )}<br>FOLLOW(F)  = {+  -  *  /  mod  ) ;}</p></blockquote><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/image-20220614161131104.png" alt="image-20220614161131104" style="zoom:67%;"><h3 id="star-LL-1-文法"><a href="#star-LL-1-文法" class="headerlink" title=":star:LL(1)文法"></a>:star:<strong>LL(1)文法</strong></h3><ul><li><p><strong>L</strong>(从左往右输入，每次读入一个非终结符进行推导)，<strong>L</strong>(产生式使用最左推导)，<strong>1</strong>表示每次每一步只需要向前看一个符号就能确定下一步的语法分析动作。</p></li><li><p>判断方法1：预测分析表中不含多重定义的条目</p></li><li><p>判断方法2：任何两个产生式 A-&gt;α|β满足</p><ul><li>对任何终结符a，α和β不能同时推导出以a开始的串；</li><li>α和β最多有一个可以推导出ε</li><li>若β=*&gt;ε,则α不能导出以FOLLOW(A)中终结符开始的任何串。</li></ul></li><li><p><strong>将文法改写为等价的LL(1)文法</strong>：消除左递归、左因子</p></li></ul><blockquote><p>exp:</p><p>E→E+T|T</p><p>T→T*F|F  </p><p>F→(E)|-F|id</p></blockquote><blockquote><p>E →TE’ </p><p>E’→+TE’|ε </p><p>T →FT’ </p><p>T’→*FT’|ε </p><p>F →(E) |-F|id </p></blockquote><p>**自下而上语法分析： ** <strong>识别可归约串</strong></p><p>​    从句子ω开始，从左到右扫描ω，反复用产生式的左部替换产生式的右部、，最终得到文法的开始符号，或者发现一个错误。 </p><p><strong>句柄</strong>：</p><p>​    设αβδ是文法 G 的一个句型，若存在 S⇒*αAδ，A⇒+β，则称β是句型αβδ相对于A的<strong>短语</strong>。特别的，若有 A→β，则称β是句型αβδ相对于产生式 A→β的<strong>直接短语</strong>。一个句型的最左直接短语被称为<strong>句柄</strong>。</p><p><strong>活前缀</strong>：是指<strong>规范句型</strong>的一个前缀，这种前缀不含<strong>句柄</strong>之后的任何符号。即，对于规范句型αβδ，β为句柄，如果αβ=u1u2…ur，则符号串u1u2…ui(1≤i≤r)是αβδ的活前缀。(δ必为终结符串)</p><p><strong>ε-闭包-closure(I)</strong><br>设I是的状态集的一个子集，定义I的**ε-闭包-closure(I)**为:<br>  i) 若s∈I，则s-closure(I)；<br>  ii) 若s∈I，则从s出发经过任意条ε 弧而能到达的任何状态s’都属于-closure(I)<br>-closure(I)=I{s’|从某个s∈I出发经过任意条ε 弧能到达s’}</p><p>**GO(I，X): **状态转换函数；所有从I经文法符号X能到达的项目全体</p><h3 id="star-SLR-1"><a href="#star-SLR-1" class="headerlink" title=":star:SLR(1)"></a>:star:<strong>SLR(1)</strong></h3><p>当一个项目集中同时存在：</p><ol><li><p>A→β1.β2和B→β1.：既可移进又可归约，移进/归约冲突</p></li><li><p>A→α.和B→α.：均可指导下一步分析，归约/归约冲突</p></li></ol><p>解决方法：简单向前看一个终结符a：</p><ol><li><p>移进/归约冲突：若FIRST(β2)∩FOLLOW(B)=Φ，冲突可解决</p></li><li><p>归约/归约冲突：若FOLLOW(A)∩FOLLOW(B)=Φ，冲突可解决</p></li></ol><p>若冲突可以解决，则称文法为SLR(1)文法，构造的分析表为SLR(1)分析表。</p><p><strong>判断SLR(1)</strong>: 考察上述两种冲突，写出FIRST/FOLLOW集，若冲突可以解决则是SLR(1)</p><p><strong>项目集规范族的构造：</strong></p><ol><li>进行扩广文法</li><li>若X-&gt;α.Aβ，A为非终结符，则需要加上所有的A-&gt;.γ</li></ol><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/image-20220614165607682.png" alt="image-20220614165607682" style="zoom:67%;"><p><strong>SLR分析表的构造：</strong></p><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/image-20220614203451785.png" alt="image-20220614203451785" style="zoom:80%;"><p>exp：</p><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/image-20220614203331639.png" alt="image-20220614203331639" style="zoom:67%;"><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/image-20220614203402677.png" alt="image-20220614203402677" style="zoom:67%;"><h4 id="课后填空：-2"><a href="#课后填空：-2" class="headerlink" title="课后填空："></a>课后填空：</h4><ol><li><p>一个上下文无关文法所含四个组成部分是 <code>一组终结符号</code>、<code>一组非终结符号</code>、<code>一个开始符号</code>和<code>一组产生式</code> 。</p></li><li><p>设G是一个给定的文法，S是文法的开始符号，如果S*⇒x（其中x∈（N∪T)*），则称x是文法的一个 <code>句型</code>  。</p></li><li><p>设G是一个给定的文法，S是文法的开始符号，如果S*⇒x(其中x∈T*),则称x是文法的一个 <code>句子 </code>。</p></li><li><p>在语法分析中，最常见的两种方法一定是 <code>自上而下分析法</code>，另一是 <code>自下而上分析法</code>。</p></li><li><p>在自上而下的语法分析中，应先消除文法的<code>间接</code> 递归，再消除文法的 <code>直接</code> 递归。 </p><blockquote><p>先消除左递归</p></blockquote></li><li><p>规范归约是指在移进过程中，当发现栈顶呈现<code>句柄</code>时，就用相应产生式的 <code>左部</code> 符号进行替换。 </p></li><li><p>自下而上的语法分析方法的基本思想是：从给定的终极符串开始，根据文法的规则一步一步的向上进行 <code>扫描(?)</code> ，试图 <code>归约</code> 到文法的 <code>开始符号</code> 。</p></li><li><p>在LR（0）分析法的名称中，L的含义是 <code>自左向右的扫描输入串</code> ，R的含义是 <code>最左归约/最右推导的逆过程</code> ，0 的含义是 <code>在确定分析器的每一步动作时向前看0个终结符 </code>。</p></li></ol><blockquote><p>LL(1)分析法是自上而下的分析法。LR(0), LR(1), SLR(1), LALR(1)是自下而上的分析法。</p><p>最右推导：规范推导/最左规约的逆过程</p><p>最左规约：规范规约/最右推导的逆过程</p></blockquote><h4 id="名词解释：-2"><a href="#名词解释：-2" class="headerlink" title="名词解释："></a>名词解释：</h4><p><strong>上下文无关文法：</strong></p><p>是一个四元组（N,T, P, S），其中：</p><ol><li><p>T是一个非空有限集合，其元素称为终结符。在我们谈论程序设计语言的文法时，记号是终结符的同义词。</p></li><li><p>N是一个非空有限集合，其元素称为非终结符，并有T∩N = f。非终结符定义终结符串的集合，它们用来帮助定义由文法决定的语言。</p></li><li><p>S是非终结符，称为开始符号，它定义的终结符串集就是文法定义的语言。</p></li><li><p>P是产生式的有限集合，每个产生式的形式是A -&gt; a（有时用::=代替箭头），其中A∈N，被称为该产生式左部，a∈(T∪N )*，被称为该产生式的右部。开始符号至少出现在某个产生式的左部。产生式指出了终结符和非终结符组成串的方式。</p></li></ol><p><strong>句柄</strong>：一个句型的最左直接短语</p><p><strong>活前缀</strong>：对于文法G[S]，若有S*⇒αβ，β∈T* 则称α为规范前缀，也称为活前缀。</p><h2 id="CH4"><a href="#CH4" class="headerlink" title="CH4"></a>CH4</h2><p><strong>语义分析的作用：</strong></p><ul><li>检查语言结构的语义是否正确</li><li>执行所规定的语义动作</li></ul><p><strong>属性：</strong>综合和继承</p><ul><li><p><strong>综合</strong>属性用于“<strong>自下而上</strong>”传递信息</p></li><li><p><strong>继承</strong>属性用于“<strong>自上而下</strong>”传递信息</p></li><li><p>E.val（值）  </p><p> E.type（类型）</p><p> E.code（代码序列）</p><p> E.place（存储空间）</p></li></ul><p><strong>语义规则两种表示方式：</strong></p><ul><li>用抽象的属性和运算符号表示的语义规则称为语法制导定义</li><li>用具体属性和运算表示的语义规则称为翻译方案</li></ul><p>语法制导定义仅考虑“做什么”，用抽象的属性表示文法符号所代表的语义</p><p>翻译方案不但需要考虑“做什么”，还需要考虑“如何做”。两者类似于算法和程序</p><p><strong>后缀式</strong>：后序遍历</p><p>三地址码： x : = y op z (x, y, z为名字、常数或编译时产生的临时变量)</p><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/prinscarce\XDU\STDUY\大三下\编译原理\复习Mine\PTRH0C`V`X`I%HF]9BV7.jpg" alt="img" style="zoom:67%;"><h3 id="三元式"><a href="#三元式" class="headerlink" title="三元式"></a><strong>三元式</strong></h3><ul><li> (i) (op, arg1, arg2) 表示的计算是 (i) := arg1 op arg2</li><li>编号的含义：代表三元式；代表其存放的结果</li></ul><p><strong>三元式的语法制导翻译</strong>：</p><ul><li>属性 .code：三元式代码，指示标识符的存储单元或三元式表中的序号；</li><li>属性 .name：标识符的名字；</li><li>函数 trip( op，arg1，arg2 )：生成一个三元式，返回三元式的序号；</li><li>函数 entry(id.name)：返回标识符在符号表中的位置或存储位置。</li></ul><p>产生式 语义规则</p><blockquote><p>(1) A→id:=E {A.code:=trip(:=，entry(id.name)，E.code)}</p><p>(2) E→E1+E2 {E.code:=trip(+，E1.code，E2.code)}</p><p>(3) E→E1*E2 {E.code:=trip(*，E1.code，E2.code)}</p><p>(4) E→(E1) {E.code:=E1.code}</p><p>(5) E→-E1 {E.code:=trip(@，E1.code， )}</p><p>(6) E→id {E.code:=entry(id.name)}</p></blockquote><p>x:=a-b*c <strong>注释语法树</strong>:</p><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/prinscarce\XDU\STDUY\大三下\编译原理\复习Mine\image-20220615103820125.png" alt="image-20220615103820125" style="zoom:67%;"><h3 id="四元式"><a href="#四元式" class="headerlink" title="四元式"></a><strong>四元式</strong></h3><ul><li>(op, arg1, arg2, result)    op为运算符，其余为指针</li></ul><p><strong>四元式特点</strong>：</p><ol><li><strong>四元式与三元式的唯一区别：将由序号所表示的运算结果改为由临时变量来表示。</strong></li><li>此改进使得四元式的运算结果与其位置无关，为代码优化提供了极大方便：可以删除或移动四元式而不影响运算结果。</li></ol><p><strong>四元式的语法制导翻译：</strong></p><ul><li><p>属性.code：表示存放运算结果的变量；</p></li><li><p>函数newtemp：返回一个新的临时变量，如T1，…等；</p></li><li><p>过程emit( op，arg1，arg2, result)：生成一个四元式，若为一元运算，则arg2可空。</p></li></ul><p><strong>产生式与语义规则</strong>：</p><blockquote><p>(1)A→id:=E {A.code:=newtemp; emit(:=, entry(id.name), E.code,</p><p> A.code)}</p><p>(2)E→E1+E2 {E.code:=newtemp; emit(+, E1.code, E2.code, E.code)}</p><p>(3)E→E1*E2 {E.code:=newtemp; emit(*, E1.code, E2.code, E.code)}</p><p>(4)E→(E1) {E.code:=E1.code}</p><p>(5)E→-E1 {E.code:=newtemp; emit(@, E1.code, , E.code)}</p><p>(6)E→id {E.code:=entry(id.name)}</p></blockquote><p>赋值句x:=(a+b)*(a+b)的树的中间代码表示：</p><p><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/prinscarce\XDU\STDUY\大三下\编译原理\复习Mine\image-20220615143337487.png" alt="image-20220615143337487"></p><p><strong>变量声明的语法制导翻译：</strong></p><ul><li><p>全程量offset：记录当前符号存储的偏移量，初值设为0</p></li><li><p>属性.type和.width：变量的类型和所占据的存储空间</p></li><li><p>过程enter(name, type, offset)：为type类型的变量name建立符号表条目，并为其分配存储空间(位置)offset</p></li></ul><blockquote><p>(1)D→D;D</p><p>(2)D→id:T                             {enter(id.name, T.type, offset);   offset:=offset+T.width;}</p><p>(3)T→int                               {T.type:=integer; T.width:=4;}</p><p>(4)T→real                             {T.type:=real; T.width:=8;}</p><p>(5)T→array [num] of T1    {T.type:=array(num.val, T1.type);    T.width:=num.val*T1.width;}</p><p>(6)T→^T1                              {T.type:=pointer(T1.type); T.width:=4;} </p></blockquote><img src="file:///C:\Users\W\Documents\Tencent Files\1205321243\Image\Group2\W2\4F\W24FWJ1@Z$3V4UJ6WFL]0WQ.jpg" alt="img" style="zoom:67%;"><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><strong>参数传递</strong></h3><ul><li><p>值调用（call by value）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ---------- 值调用参数传递的演示程序</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> temp;  <br>        temp=x;  x=y;  y=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;before:  a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;   b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    <span class="hljs-built_in">swap</span>(a, b);<br>    cout&lt;&lt;<span class="hljs-string">&quot;after:   a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;   b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>引用调用（call by reference） 实参必须是左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ---------- 引用调用参数传递的演示程序</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> temp;  <br>        temp=x;  x=y;  y=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;before:  a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;   b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    <span class="hljs-built_in">swap</span>(a, b);<br>    cout&lt;&lt;<span class="hljs-string">&quot;after:   a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;   b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>复写－恢复（copy-in/copy-out）实参必须是左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//  --------- 引用调用的副作用的程序实例</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-keyword">int</span> a=<span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_one</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span></span>&#123; a=x+<span class="hljs-number">1</span>;  x=x+<span class="hljs-number">1</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   cout&lt;&lt;<span class="hljs-string">&quot;before:  a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    <span class="hljs-built_in">add_one</span>(a);<br>    cout&lt;&lt;<span class="hljs-string">&quot;after:   a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">// ----------引用调用模拟复写-恢复参数传递的演示程序</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-keyword">int</span> a=<span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_one</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> local_x=x;  a=local_x+<span class="hljs-number">1</span>; local_x++; x=local_x;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   cout&lt;&lt;<span class="hljs-string">&quot;before:  a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    <span class="hljs-built_in">add_one</span>(a);<br>    cout&lt;&lt;<span class="hljs-string">&quot;after:   a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>换名调用（call by name）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ---------- 换名调用副作用的演示程序</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-keyword">int</span> temp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> swap(x, y) temp=x;  x=y;  y=temp;<span class="hljs-comment">// 宏定义</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span><span class="hljs-comment">// 引用调用</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">int</span> temp;  temp=x;  x=y;  y=temp; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, b[]</span>=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    cout&lt;&lt;<span class="hljs-string">&quot;before:  a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;  b=&quot;</span>&lt;&lt;b[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>    <span class="hljs-built_in">swap</span>(a, b[a]);<br>    cout&lt;&lt;<span class="hljs-string">&quot;after:   a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;  b=&quot;</span>&lt;&lt;b[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//折中方法：内联函数</span><br><span class="hljs-comment">//----------- 宏定义</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> macro_swap(x, y) temp=x;  x=y;  y=temp; </span><br><br><span class="hljs-comment">//----------- 内联函数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inline_swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> temp; temp=x;  x=y;  y=temp;&#125;<br><br><span class="hljs-comment">//----------- 引用调用</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">procedure_swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> temp; temp=x;  x=y;  y=temp;&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a><strong>布尔表达式</strong></h3><blockquote><p>E→ E or E | E and E | not E | (E) | id relop id | id | true | false</p></blockquote><h4 id="短路计算"><a href="#短路计算" class="headerlink" title="短路计算"></a>短路计算</h4><p>短路计算以if-then-else的方式解释布尔表达式，控制逻辑如下</p><pre><code> A or B ： if A then true else B  A and B： if A then B else false   not A  ： if A then false else true</code></pre><p>布尔表达式A or B and not C采用短路计算，等价于下述解释：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pascal"><span class="hljs-keyword">if</span> A  <br><span class="hljs-keyword">then</span> true<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>   B<br><span class="hljs-keyword">then</span> <span class="hljs-keyword">if</span> C <span class="hljs-keyword">then</span> false <span class="hljs-keyword">else</span> true<br><span class="hljs-keyword">else</span> false<br></code></pre></td></tr></table></figure><p>对于语句：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pascal"><span class="hljs-keyword">while</span> ptr&lt;&gt;<span class="hljs-keyword">nil</span> <span class="hljs-keyword">and</span> ptr^.data=x <span class="hljs-keyword">do</span> ...<br></code></pre></td></tr></table></figure><p>短路计算可以回避对ptr^.data=x的判断，从而避免程序运行时错误。</p><p>语义规则：</p><blockquote><p>(1)E→E1 or E2     {E1.true:= E.true; E1.false:=newlabel;</p><pre><code>                             E2.true:= E.true; E2.false:=E.false;                                  E.code := E1.code||emit(E1.false &#39;:&#39;)||E2.code;&#125;</code></pre><p>(2) |E1 and E2     {E1.false:= E.false; E1.true:=newlabel;</p><pre><code>                              E2.false:= E.false; E2.true:=E.true;                                  E.code := E1.code||emit(E1.true&#39;:&#39;)||E2.code;&#125;</code></pre><p>(3) |not E1    {E1.false:=E.true;  E1.true:=E.false;}</p><p>(4) |(E1)     {E1.false:=E.false; E1.true:=E.true;} </p><p>(5) |id1 relop id2      { E.code := emit(‘if’id1.place relop.op  id2.place’goto’E.true) || emit(‘goto’ E.false);}</p><p>(6) |id     { E.code := emit(‘if’ id.place ‘goto’ E.true)</p><p>​                 || emit(‘goto’ E.false);}</p><p>(7) |true     {E.code := emit(‘goto’ E.true);}</p><p>(8) |false     {E.code := emit(‘goto’ E.false);}</p></blockquote><p>再考虑布尔表达式a&lt;b or c&lt;d and e&lt;f的短路计算：</p><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/prinscarce\XDU\STDUY\大三下\编译原理\复习Mine\image-20220615145315394.png" alt="image-20220615145315394" style="zoom: 67%;"><p>三地址码序列: </p><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/prinscarce\XDU\STDUY\大三下\编译原理\复习Mine\image-20220615145339282.png" alt="image-20220615145339282" style="zoom: 67%;"><img src="/2022/06/14/2022/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%A4%8D%E4%B9%A0/prinscarce\XDU\STDUY\大三下\编译原理\复习Mine\image-20220615145414892.png" alt="image-20220615145414892" style="zoom:67%;"><p>p.s. 不能执行</p><h3 id="课后填空"><a href="#课后填空" class="headerlink" title="课后填空"></a>课后填空</h3><ol><li><p>所谓属性文法是  <code>在上下文无关文法的基础上为每个文法符号（终结符或非终结符）配备若干相关的“值” </code>。</p></li><li><p>语义规则的描述方法有  <code>语法制导翻译</code> 和  <code>翻译方案</code>  。</p></li><li><p>综合属性是用于 <code>自下而上</code>  传递信息，继承属性是用于 <code>自上而下</code> 传递信息。</p></li><li><p>终结符只有 <code>综合</code> 属性，它由词法分析器提供。</p></li><li><p>在使用高级语言编程时,首先可通过编译程序发现源程序 的 <code>词法</code> 错误和部分 <code>语法</code>  错误。</p></li><li><p>语法制导翻译既可以用来产生 <code>中间</code> 代码，也可用来产生 <code>目标</code> 指令，甚至可用来对<code>输入串</code>进行 解释执行 。</p></li><li><p>在语法树中，一个结点的综合属性的值由其  <code>子结点</code>  的属性值确定，而继承属性则由该结点的  <code>父结点、兄弟结点  </code>的某些属性确定</p></li></ol><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ol><li><p>三元式:</p><p>用op、arg1、arg2这三个域，并用临时变量值的语句位置来引用临时变量，这样的三地址码的记录方式。</p></li><li><p>语义规则</p><p>对于文法的每个产生都配备了一组属性的计算规则，称为语义规则</p></li><li><p>翻译方案</p><p>用具体属性和运算表示的语义规则称为翻译方案。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用MOM消息队列技术实现一个分布式随机信号分析系统</title>
      <link href="/2022/04/29/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E5%9B%9B/exp4/"/>
      <url>/2022/04/29/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E5%9B%9B/exp4/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式计算——第四次作业"><a href="#分布式计算——第四次作业" class="headerlink" title="分布式计算——第四次作业"></a>分布式计算——第四次作业</h2><p>写得不好…</p><blockquote><p>JDK-17.0.1 </p><p>IntelliJ IDEA 2021.3.3 (Community Edition) </p></blockquote><h3 id="1-实验题目"><a href="#1-实验题目" class="headerlink" title="1 实验题目"></a>1 实验题目</h3><p>利用MOM消息队列技术实现一个分布式随机信号分析系统</p><h3 id="2-实验要求"><a href="#2-实验要求" class="headerlink" title="2 实验要求"></a>2 实验要求</h3><p>具体要求:</p><ol><li><p>随机信号产生器微服务<strong>每隔100毫秒</strong>左右就产生一 个<strong>正态分布的随机数字</strong>，并作为一个<strong>消息发布</strong></p></li><li><p>一个随机信号统计分析微服务，对信号进行如下分析:</p><ul><li><p><strong>计算过去N个随机信号的均值和方差</strong>(N为常量,可设置)</p></li><li><p><strong>计算所有历史数据中的最大值和最小值</strong></p></li><li><p>定时地将分析结果打包成一个<strong>新消息并通过MOM发布出去</strong></p></li></ul></li><li><p>一 个实时数据显示微服务:</p><ul><li><p><strong>实时绘制</strong>过去一段时间内<strong>随机信号的折线图</strong></p></li><li><p>实时<strong>显示随机信号统计分析结果</strong></p></li></ul></li></ol><h3 id="3-实验方法与解释"><a href="#3-实验方法与解释" class="headerlink" title="3 实验方法与解释"></a>3 实验方法与解释</h3><h4 id="总体结构："><a href="#总体结构：" class="headerlink" title="总体结构："></a><strong>总体结构</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> analysis;<br>Publisher.java<span class="hljs-comment">//发布消息</span><br>ASyncConsumer_extreme.java<span class="hljs-comment">//分析数据最值</span><br>    ASyncConsumer_com.java<span class="hljs-comment">//分析数据均值&amp;&amp;方差</span><br>ASyncConsumer_chart.java<span class="hljs-comment">//数据折线图</span><br>        <br>    RealTimeChart.java<span class="hljs-comment">//Xchart实现生成折线图</span><br></code></pre></td></tr></table></figure><h4 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a><strong>Publisher</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String brokerURL = <span class="hljs-string">&quot;tcp://localhost:61616&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConnectionFactory factory;<br>    <span class="hljs-keyword">private</span> Connection connection;<br>    <span class="hljs-keyword">private</span> Session session;<br>    <span class="hljs-keyword">private</span> MessageProducer producer;<br>    <br>    <span class="hljs-keyword">private</span> Topic topic;<br>    <span class="hljs-keyword">private</span> Random random = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Publisher</span><span class="hljs-params">(String topicName)</span> <span class="hljs-keyword">throws</span> JMSException<span class="hljs-comment">//initialization</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JMSException<span class="hljs-comment">//close the connection</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> JMSException<span class="hljs-comment">//send message</span></span><br><span class="hljs-function">&#125;        </span><br></code></pre></td></tr></table></figure><h4 id="ASyncConsumer-extreme"><a href="#ASyncConsumer-extreme" class="headerlink" title="ASyncConsumer_extreme"></a>ASyncConsumer_extreme</h4><p>通过使用<code>BigDecimal</code>来保证数的精度，使用<strong>Collections</strong>的**max()<strong>，</strong>min()**函数来获取最大最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener_extreme</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MessageListener</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            num++;<br>            String str = ((TextMessage)message).getText();<br>            BigDecimal tmp = <span class="hljs-keyword">new</span> BigDecimal(str);<br>            arrayList.add(tmp);<br><br>            maxNum = (BigDecimal) Collections.max(arrayList);<br>            minNum = (BigDecimal) Collections.min(arrayList);<br><br>            System.out.println(<span class="hljs-string">&quot;current max: &quot;</span> + maxNum.toString() + <span class="hljs-string">&quot;  &quot;</span> + <span class="hljs-string">&quot;current min: &quot;</span> + minNum.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ASyncConsumer_extreme</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> JMSException</span><br><span class="hljs-function">        <span class="hljs-comment">//...</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="ASyncConsumer-com-java"><a href="#ASyncConsumer-com-java" class="headerlink" title="ASyncConsumer_com.java"></a>ASyncConsumer_com.java</h4><p>通过使用<code>BigDecimal</code>来保证数的精度，使用BigDecimal的内置函数来计算均值和方差</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener_com</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MessageListener</span> </span>&#123;<br>    BigDecimal va = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0&quot;</span>);<br>    BigDecimal avg = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0&quot;</span>);<br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//...</span><br>            BigDecimal sum = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0&quot;</span>);<br>            BigDecimal sum_var = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;0&quot;</span>);<br><br>            <span class="hljs-keyword">if</span> (num &gt; N) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arrayList.size()-<span class="hljs-number">1</span>; i &gt;= arrayList.size()-N; i--) &#123;<br>                    BigDecimal d1 = (BigDecimal)arrayList.get(i);<br>                    sum = sum.add(d1);<br>                &#125;<br>                avg = sum.divide(BigDecimal.valueOf(N), <span class="hljs-number">10</span>, BigDecimal.ROUND_UP);<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arrayList.size()-<span class="hljs-number">1</span>; i &gt;= arrayList.size()-N; i--) &#123;<br>                    BigDecimal d2 = (BigDecimal)arrayList.get(i);<br>                    sum_var = sum_var.add((d2.subtract(avg)).multiply(d2.subtract(avg)));<br>                &#125;<br>                va = sum_var.divide(BigDecimal.valueOf(N), <span class="hljs-number">10</span>, BigDecimal.ROUND_UP);<br>                System.out.println(<span class="hljs-string">&quot;current var: &quot;</span> + va.toString() + <span class="hljs-string">&quot;  &quot;</span> +<br>                        <span class="hljs-string">&quot;current avg: &quot;</span> + avg.toString());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ASyncConsumer_com</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> JMSException</span><br><span class="hljs-function">        <span class="hljs-comment">//...</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="RealTimeChart"><a href="#RealTimeChart" class="headerlink" title="RealTimeChart"></a>RealTimeChart</h4><p>参考Xchart示例，将折线图封装成包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealTimeChart</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> SwingWrapper&lt;XYChart&gt; swingWrapper;<br>    <span class="hljs-keyword">private</span> XYChart chart;<br>    <span class="hljs-keyword">private</span> JFrame frame;<br><br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> String seriesName;<br>    <span class="hljs-keyword">private</span> List&lt;Double&gt; seriesData;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> String <span class="hljs-title">getSeriesName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSeriesName</span><span class="hljs-params">(String seriesName)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> String <span class="hljs-title">getTitle</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTitle</span><span class="hljs-params">(String title)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-title">RealTimeChart</span><span class="hljs-params">(String title, String seriesName)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-title">RealTimeChart</span><span class="hljs-params">(String title, String seriesName, <span class="hljs-keyword">int</span> size)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plot</span><span class="hljs-params">(<span class="hljs-keyword">double</span> data)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="ASyncConsumer-chart"><a href="#ASyncConsumer-chart" class="headerlink" title="ASyncConsumer_chart"></a>ASyncConsumer_chart</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener_chart</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MessageListener</span> </span>&#123;<br>    <br>    RealTimeChart chart = <span class="hljs-keyword">new</span> RealTimeChart(<span class="hljs-string">&quot;RandomSignalAnalysis&quot;</span>, <span class="hljs-string">&quot;cost&quot;</span>, <span class="hljs-number">200</span>);<br><span class="hljs-comment">//生成title为RandomSignalAnalysis，series为cost，最多显示200个点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            String str = ((TextMessage)message).getText();<br>            <span class="hljs-keyword">double</span> randomNum = Double.parseDouble(str);<br>            chart.plot(randomNum);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ASyncConsumer_chart</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> JMSException</span><br><span class="hljs-function">        <span class="hljs-comment">//...</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="4-具体功能"><a href="#4-具体功能" class="headerlink" title="4 具体功能"></a>4 具体功能</h2><ul><li><p>计算过去N个随机信号的均值和方差(N为常量,可设置)</p></li><li><p>计算所有历史数据中的最大值和最小值</p></li><li><p>实时绘制过去一段时间内随机信号的折线图</p></li><li><p>实时显示随机信号统计分析结果</p></li></ul><h2 id="5-实验测试"><a href="#5-实验测试" class="headerlink" title="5 实验测试"></a>5 实验测试</h2><p>启动ActiveMQ</p><img src="/2022/04/29/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E5%9B%9B/exp4/image-20220429232649398.png" alt="image-20220429232649398" style="zoom:67%;"><p>打开<a href="http://127.0.0.1:8161/admin/%E7%A1%AE%E5%AE%9A%E7%99%BB%E5%BD%95%E5%AE%8C%E6%88%90">http://127.0.0.1:8161/admin/确定登录完成</a></p><blockquote><p>账号密码都为admin</p></blockquote><img src="/2022/04/29/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E5%9B%9B/exp4/image-20220429232738171.png" alt="image-20220429232738171" style="zoom:67%;"><p>分别开始运行Publisher.java、ASyncConsumer_extreme.java、ASyncConsumer_com.java、ASyncConsumer_chart.java</p><p>ASyncConsumer_com 实时显示方差与均值，精度为10</p><img src="/2022/04/29/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E5%9B%9B/exp4/image-20220429233233958.png" alt="image-20220429233233958" style="zoom:67%;"><p>ASyncConsumer_extreme 实时显示最大值与最小值</p><img src="/2022/04/29/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E5%9B%9B/exp4/image-20220429233357303.png" alt="image-20220429233357303" style="zoom:67%;"><p>Xchart生成折线图</p><img src="/2022/04/29/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E5%9B%9B/exp4/image-20220429233215898.png" alt="image-20220429233215898" style="zoom:67%;"><p>查看目前的topic数值</p><img src="/2022/04/29/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E5%9B%9B/exp4/image-20220429233451517.png" alt="image-20220429233451517" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> 分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MOM Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用RPC技术一个书籍信息管理系统</title>
      <link href="/2022/04/05/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%89/exp3/"/>
      <url>/2022/04/05/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%89/exp3/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式计算——第三次作业"><a href="#分布式计算——第三次作业" class="headerlink" title="分布式计算——第三次作业"></a>分布式计算——第三次作业</h2><p>19030100024 王子希</p><blockquote><p>JDK-17.0.1 </p><p>IntelliJ IDEA 2021.3.3 (Community Edition) </p></blockquote><h3 id="1-实验题目"><a href="#1-实验题目" class="headerlink" title="1 实验题目"></a>1 实验题目</h3><p>利用RPC技术实现一个书籍信息管理系统</p><h3 id="2-实验要求"><a href="#2-实验要求" class="headerlink" title="2 实验要求"></a>2 实验要求</h3><p>具体要求：</p><ol><li><p>客户端实现用户交互，服务器端实现书籍信息存储和管理。客户端与服 务器端利用RPC机制进行协作。</p></li><li><p>服务器端至少暴露如下RPC接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">bool <span class="hljs-title">add</span><span class="hljs-params">(Book b)</span> <span class="hljs-comment">//添加一个书籍对象</span></span><br><span class="hljs-function">Book <span class="hljs-title">queryByID</span><span class="hljs-params">(intbookID)</span> <span class="hljs-comment">//查询指定ID号的书籍对象。</span></span><br><span class="hljs-function">BookList <span class="hljs-title">queryByName</span><span class="hljs-params">(String name)</span> <span class="hljs-comment">//按书名查询符合条件的书籍对象列表，支持模糊查询。</span></span><br><span class="hljs-function">bool <span class="hljs-title">delete</span><span class="hljs-params">((intbookID)</span> <span class="hljs-comment">//删除指定ID号的书籍对象。</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-实验方法与解释"><a href="#3-实验方法与解释" class="headerlink" title="3 实验方法与解释"></a>3 实验方法与解释</h3><h4 id="总体结构："><a href="#总体结构：" class="headerlink" title="总体结构："></a><strong>总体结构</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> BMS;<br>Book.java<span class="hljs-comment">//存储book的数据类型</span><br>    book.txt<span class="hljs-comment">//存储书单</span><br>    BookList.java<span class="hljs-comment">//存储bookList的数据类型</span><br>    BookManagement.java<br>    BookManagementImpl.java<span class="hljs-comment">//BMS功能的主要实现</span><br>    <br>    <span class="hljs-comment">//使用RMI作为中间件</span><br>    RMIClient.java<br>    RMIServer.java<br></code></pre></td></tr></table></figure><h4 id="Book"><a href="#Book" class="headerlink" title="Book"></a><strong>Book</strong></h4><p>​        创建含有以下API的数据类型Book，构造一个包含书号和书名的Book类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bookID;<br>    <span class="hljs-keyword">private</span> String bookName;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span><span class="hljs-comment">//initialization of Book</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getID</span><span class="hljs-params">()</span> <span class="hljs-comment">//return bookID</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-comment">//return bookName</span></span><br><span class="hljs-function">    <span class="hljs-keyword">private</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> <span class="hljs-comment">//get the information of book</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span>  <span class="hljs-comment">//show book</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="BookList"><a href="#BookList" class="headerlink" title="BookList"></a><strong>BookList</strong></h4><p>​        将Book存储在ArrayList中，方便进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    ArrayList&lt;Book&gt; BookList = <span class="hljs-keyword">new</span> ArrayList();<span class="hljs-comment">//initialization</span><br>    BookList()&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span>   <span class="hljs-comment">//show the info bookList</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="BookManagementImpl"><a href="#BookManagementImpl" class="headerlink" title="BookManagementImpl"></a><strong>BookManagementImpl</strong></h4><p>​        完成图书管理系统的主要功能实现，包括增加书、使用书号进行查找、使用书名进行模糊查找、使用书号/书名进行删除操作，打印书单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookManagementImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">rmi</span>.<span class="hljs-title">server</span>.<span class="hljs-title">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BookManagement</span></span>&#123;<br><br>    BookManagementImpl() <span class="hljs-keyword">throws</span> RemoteException<span class="hljs-comment">//Initialization</span><br><br>    ArrayList&lt;Book&gt; books = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    BookList list = <span class="hljs-keyword">new</span> BookList();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBook</span><span class="hljs-params">()</span><span class="hljs-comment">//Initialization</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveBook</span><span class="hljs-params">()</span><span class="hljs-comment">//save in book.txt</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Book b1)</span><span class="hljs-comment">//Add a book</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> Book <span class="hljs-title">queryByID</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bookID)</span><span class="hljs-comment">//Query the book by ID number</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> BookList <span class="hljs-title">queryByName</span><span class="hljs-params">(String name)</span><span class="hljs-comment">//Query the book by Book Name</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteByID</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bookID)</span><span class="hljs-comment">//Delete the book with ID number</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteByName</span><span class="hljs-params">(String name)</span><span class="hljs-comment">//Delete the book with Book Names</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> String <span class="hljs-title">booksInfo</span><span class="hljs-params">()</span><span class="hljs-comment">//return string of booksInfo</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showBooks</span><span class="hljs-params">()</span><span class="hljs-comment">//print books info</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="RMIServer"><a href="#RMIServer" class="headerlink" title="RMIServer"></a><strong>RMIServer</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取注册中心的引用，注册中心运行在IDEA中，port为8889</span><br>BookManagement var1 = <span class="hljs-keyword">new</span> BookManagementImpl();<br>LocateRegistry.createRegistry(<span class="hljs-number">8889</span>);<br>Naming.bind(<span class="hljs-string">&quot;rmi://localhost:8889/BookManagement&quot;</span>, var1);<br>System.out.println(<span class="hljs-string">&quot;BookManagement is online successfully&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="RMIClient"><a href="#RMIClient" class="headerlink" title="RMIClient"></a>RMIClient</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在port8889进行通信</span><br>BookManagement bookManagement = (BookManagement) Naming.lookup(<span class="hljs-string">&quot;rmi://localhost:8889/BookManagement&quot;</span>);<br>bookManagement.initBook();<br></code></pre></td></tr></table></figure><h3 id="4-具体功能"><a href="#4-具体功能" class="headerlink" title="4 具体功能"></a>4 具体功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> ---------------menu---------------<br>|   <span class="hljs-number">1.</span>add a <span class="hljs-keyword">new</span> book               |<br>|   <span class="hljs-number">2.</span>Query the book by ID number  |<br>|   <span class="hljs-number">3.</span>Query the book by Book Name  |<br>|   <span class="hljs-number">4.</span>Delete book by ID number     |<br>|   <span class="hljs-number">5.</span>Delete book by Book Names    |<br>|   <span class="hljs-number">6.</span>print the book list          |<br> ----------------------------------<br></code></pre></td></tr></table></figure><ol><li>通过书号和书名添加一本新书，当书号已存在时返回错误提醒</li><li>通过书号进行查询，书号不存在返回错误提醒</li><li>使用<code>matcher.find()</code>通过书名进行模糊查找，最终通过BookList进行打印</li><li>通过ID进行删除，ID不存在返回错误提醒</li><li>通过书名进行删除，书名不存在返回错误提醒</li><li>打印书单</li></ol><h3 id="5-实验测试"><a href="#5-实验测试" class="headerlink" title="5 实验测试"></a>5 实验测试</h3><p>运行RMIServer</p><img src="/2022/04/05/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%89/exp3/image-20220407095530614.png" alt="image-20220407095530614" style="zoom:50%;"><p>运行RMIClient</p><img src="/2022/04/05/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%89/exp3/image-20220407095557370.png" alt="image-20220407095557370" style="zoom:50%;"><p>使用功能6，打印目前书单</p><img src="/2022/04/05/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%89/exp3/image-20220407100051988.png" alt="image-20220407100051988" style="zoom:50%;"><p>使用功能1，新增6 math</p><p><img src="/2022/04/05/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%89/exp3/image-20220407100148215.png" alt="image-20220407100148215"></p><p>使用功能2，查询书号6</p><p><img src="/2022/04/05/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%89/exp3/image-20220407100250561.png" alt="image-20220407100250561"></p><p>使用功能3，查询书名Co，得到模糊查找</p><p><img src="/2022/04/05/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%89/exp3/image-20220407100337211.png" alt="image-20220407100337211"></p><p>使用功能4，删除书号5</p><p>使用功能5，删除书名Math</p><p>使用功能6，返回最终书目</p><p><img src="/2022/04/05/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%89/exp3/image-20220407100515313.png" alt="image-20220407100515313"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx负载均衡实验</title>
      <link href="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/"/>
      <url>/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx负载均衡实验"><a href="#nginx负载均衡实验" class="headerlink" title="nginx负载均衡实验"></a>nginx负载均衡实验</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>​        跨多个应用程序实例的负载平衡是优化资源利用率、最大化吞吐量、减少延迟和确保容错配置的常用技术。</p><p>​        使用 nginx 作为一个非常高效的 HTTP 负载平衡器来将流量分配到多个应用程序服务器，并通过其来提高 Web 应用程序的性能、可伸缩性和可靠性。</p><h2 id="二、nginx命令和配置文件介绍"><a href="#二、nginx命令和配置文件介绍" class="headerlink" title="二、nginx命令和配置文件介绍"></a>二、nginx命令和配置文件介绍</h2><p><strong>命令</strong>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">start</span> nginx<span class="hljs-comment">#开启nginx服务</span><br>nginx.exe -s stop/quit  <span class="hljs-comment">#关闭nginx服务，quit相对stop较平滑安全</span><br>nginx.exe -s reload <span class="hljs-comment">#重载nginx服务</span><br></code></pre></td></tr></table></figure><p><strong>配置文件</strong>：/conf/nginx.conf</p><ul><li>全局块：全局指令，指定运行时的用户组，进程id存放位置，日志存放位置，进程数量等。</li><li>Events块：影响nginx服务器和用户网络链接的配置，包括每个进程的最大链接数，事件驱动模型的选择，网络链接过程中的多开、序列化等</li><li>http块：配置代理、缓存、日志等绝大多数功能，可嵌套多个server块，不同的server块可对应不同的域名（虚拟主机），每个虚拟主机之间相互独立。</li></ul><h2 id="三、负载均衡方法"><a href="#三、负载均衡方法" class="headerlink" title="三、负载均衡方法"></a>三、负载均衡方法</h2><p>nginx 支持以下负载均衡机制（或方法）：</p><ol><li><p><strong>轮询</strong>：对应用程序服务器的请求以循环方式分发（weight可不加）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> myserver &#123;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:2333</span> weight=<span class="hljs-number">1</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.2:2334</span> weight=<span class="hljs-number">1</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.3:2335</span> weight=<span class="hljs-number">1</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.4:2336</span> weight=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>权重</strong>：指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。通过改变weight的大小，来确定访问的概率，本实验中所使用为50％，30%，10%，10%</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> myserver &#123;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:2333</span> weight=<span class="hljs-number">50</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.2:2334</span> weight=<span class="hljs-number">30</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.3:2335</span> weight=<span class="hljs-number">10</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.4:2336</span> weight=<span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Session persistence</strong>(会话持久性)：</p><p>使用循环或连接最少的负载平衡，每个后续客户端的请求都可能被分发到不同的服务器，不能保证同一个客户端总是被定向到同一个服务器。<br>如果需要将客户端绑定到特定的应用程序服务器——换句话说，使客户端的会话“粘性”或“持久”，总是试图选择特定的服务器——ip-hash 负载平衡机制可以是用过的。<br>使用 ip-hash，客户端的 IP 地址被用作散列键来确定应该为客户端的请求选择服务器组中的哪个服务器。此方法确保来自同一客户端的请求将始终定向到同一服务器，除非该服务器不可用。<br>要配置 ip-hash 负载平衡，只需将 ip_hash 指令添加到服务器组配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> myserver &#123;<br>ip_hash;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:81</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.2:80</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Least connected load balancing</strong> (最少连接负载均衡)<br>另一个负载平衡规则是连接最少的。在某些请求需要更长时间才能完成的情况下，最少连接允许更公平地控制应用程序实例上的负载。<br>使用最少连接的负载平衡，nginx 将尽量不因过多的请求而使繁忙的应用程序服务器过载，而是将新请求分配给不太繁忙的服务器。<br>当将least_conn指令用作服务器组配置的一部分 时，会激活 nginx 中的最少连接负载平衡 ：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> myserver &#123;<br>least_conn;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:2333</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.2:2334</span>;<br>&#125;   <br></code></pre></td></tr></table></figure></li></ol><h2 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h2><ol><li><p>安装nginx、curl、nodejs</p><p><code>nginx</code>：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p><img src="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/image-20220122172241595.png" alt="image-20220122172241595" style="zoom:50%;"><p><code>curl</code>：<a href="https://curl.se/windows/">https://curl.se/windows/</a></p><p>​    根据自己的电脑选择下载版本</p><img src="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/image-20220122172427390.png" alt="image-20220122172427390" style="zoom: 33%;"><p><code>nodejs</code>：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><img src="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/image-20220122172625037.png" alt="image-20220122172625037" style="zoom:50%;"><p>​    可通过node -v查询node是否安装完成</p><p><img src="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/image-20220122172740332.png" alt="image-20220122172740332"></p></li><li><p>配置nginx.conf文件（默认轮询）</p><p>主要添加负载均衡的配置（vscode内有对应nginx的高亮插件，可自行选用）：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> myserver &#123;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:2333</span> weight=<span class="hljs-number">1</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.2:2334</span> weight=<span class="hljs-number">1</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.3:2335</span> weight=<span class="hljs-number">1</span>;<br><span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.4:2336</span> weight=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/image-20220122173030844.png" alt="image-20220122173030844" style="zoom: 67%;"></li><li><p>通过vscode写webserver的测试文件</p><p>此处仅列举其中一个测试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;<br>    res.write(<span class="hljs-string">&quot;myserver one.&quot;</span>);<br>    res.end();<br>&#125;);<br>server.listen(<span class="hljs-number">2333</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;running at http://127.0.0.1:2333&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>测试nginx负载均衡</p><p>到达目录下进行start nginx</p><img src="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/image-20220122175119033.png" alt="image-20220122175119033" style="zoom:80%;"><p>通过node运行code</p><img src="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/image-20220122175046501.png" alt="image-20220122175046501" style="zoom: 67%;"><h4 id="进行测试："><a href="#进行测试：" class="headerlink" title="进行测试："></a>进行测试：</h4><p><code> 默认轮询</code> ：chrome访问没有完全根据轮询的方式，所以这里使用curl来进行模拟</p><img src="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/image-20220122175335988.png" alt="image-20220122175335988" style="zoom: 67%;"><p><code>权重</code>：本实验中所使用为50％，30%，10%，10%</p><img src="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/image-20220122175714083.png" alt="image-20220122175714083" style="zoom: 67%;"><p><code>Session persistence</code>：仅访问了服务器1</p><img src="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/image-20220122181127006.png" alt="image-20220122181127006" style="zoom: 67%;"><p><code>Least connected load balancing</code>：将会连接最小负载，本实验中俩实验负载近乎相同，所以实验结果为交替出现</p></li></ol><img src="/2022/01/22/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%AE%9E%E9%AA%8C1/image-20220122182050983.png" alt="image-20220122182050983" style="zoom: 67%;">]]></content>
      
      
      <categories>
          
          <category> 分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>边缘计算在物联网领域的应用</title>
      <link href="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="边缘计算在物联网领域的应用"><a href="#边缘计算在物联网领域的应用" class="headerlink" title="边缘计算在物联网领域的应用"></a><strong>边缘计算在物联网领域的应用</strong></h1><h2 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1 基本定义"></a><strong>1 基本定义</strong></h2><h3 id="1-1-物联网的定义"><a href="#1-1-物联网的定义" class="headerlink" title="1.1 物联网的定义"></a><strong>1.1 物联网的定义</strong></h3><p>随着物联网的快速发展和4G/5G网络的普及，万物互联的时代已经到来，生活中的所使用的冰箱、电视、空调甚至是台灯都已经变得智能化。从灯泡等常见的家用物品，到应急使用的医疗物资医疗设备，再到我们随身所能携带的手表、道路上行径的车辆，甚至是智能城市，物与物之间都能够通过互联网彼此相连，以达到互相影响的作用，更是有助于人们的日常生活使用等。</p><p><strong>物联网 （The Internet of Things，简称 IoT）</strong>是指将日常物理对象连接到互联网的过程。其概念在1999年提出，其意在把所有物品通过射频识别等信息传感设备与互联网连接起来，从而实现智能化试别和管理。物联网已经完全融入到了我们的生活之中，例如智能灯泡，可以通过我们人为的语音命令输入或是通过手机app等手段对其进行操控，以达成无需亲自去开关灯，仅仅通过互联网来完成这一作用；或是智能喂食机，通过主人自己的设置，并且智能计算家里宠物的状态，自动达成喂食，同时其机器上往往还有摄像头等设备，使主人可以远程观察是否还需要额外喂食等。</p><p>物联网除了在日常生活中有着广泛应用，在工业等领域也有着巨大作用：</p><p>(1) <strong>工业物联网（IIoT）</strong>：IIoT表示制造业、能源及其他工业实践中联网的设备。它能够使得工业机器的自动化和自我监测程度提升，有助于提高效率，意义重大。比如在工厂的设备零件上，随着时间的推移，不同的专业人士会使这些机械产生不同的损耗，不好整体估算在它们在运行过程中是否会出现故障，大概在多少时间之后需要更新新的零件。所以我们可以为最容易损坏和过度使用的机械零件安装专用传感器。这些传感器可以让维修人员在零件因耗损发生故障时能够预先维修，提高工作人员们的维修效率，帮其完成实时数据收集和分析，还可以向机械的设计工程师提供长期数据分析的反馈，为工程师提供新机型改进方向。</p><p>以下是工业物联网 的一些常见使用场景：</p><ul><li>智能制造</li><li>互联资产以及预防性和预测性维护</li><li>智能电网</li><li>智能城市</li><li>互联物流</li><li>智能数字供应链</li></ul><p>(2) <strong>物流和运输业物联网</strong>：物联网在物流和运输行业的早期应用，是通过使用射频识别（RFID）设备在运输容器上张贴标签。这些标签存储的数据可以通过无线电波采集，便于物流公司在某些 RFID 检查站跟踪集装箱的运输动态，随时在运输过程中进行调整。现在，物联网的进步已经能够让电池供电的跟踪设备持续向物联网应用传输数据，而无需现场进行扫码，通过其自动化减少了人工可能会犯的错误，大大加快了效率，为公司带来了更多的利润，并且公司也可以对整个供应链中货物的实时数据进行分析。</p><p>(3) <strong>农业物联网</strong>：物联网使得农业发生了翻天覆地的变化，比如湿度传感器的应用。在田间安装这些传感器之后，农民们现在可以接收到更准确的数据，并以此来安排灌溉时间。湿度传感器还可以连接到控制灌溉机械本身的物联网应用，根据传感器数据自动触发灌溉作业。</p><p>借助低成本计算、云、大数据、分析和移动领域的技术手段，如今我们能让智能化的物品自动进行收集、分析和共享数据，尽可能减少人为干预。在这个高度互联的世界里，数字系统可以记录、监视和调整正处于联网状态物品之间的每一次交互。物理世界与数字世界就此开始了交汇融合，相互协作。</p><h3 id="1-2-边缘计算的定义"><a href="#1-2-边缘计算的定义" class="headerlink" title="1.2 边缘计算的定义"></a><strong>1.2 边缘计算的定义</strong></h3><p>众所周知，物联网是新一代信息技术的重要组成部分，是以互联网、电信网为信息载体，进行物和物之间信息交换和通信，实现对物的智能化识别、定位、跟踪监控和管理。基于物联网的应用非常广泛，除了上文提及的例子外，还遍及智能交通、智能家居、智能楼宇、智慧城市、环境监测、公共安全、车联网、工业制造等众多行业和领域。基于物联网的行业应用有着各种各样的业务要求，比如传输时延、传输带宽、数据安全、数据聚合、数据处理、数据分析和智能决策等。其中对高实时性、高带宽和安全性等有着非常高要求的应用都迫切需要尽可能在靠近网络的边缘侧提供集中的智能管理控制功能。</p><p>为了实现这样的智能管理控制功能，能够处理在网络边缘产生了海量的数据，研究者们想出了一种全新的计算范式——边缘计算。边缘计算是指在用户或数据源的物理位置附近进行的计算，通过将服务靠近这些位置进行计算，用户能够使用更快速更可靠的服务，公司则能够享受混合云计算带来的灵活性。</p><p>并且边缘计算除了能够在本地提供类似于云计算集中的计算存储力、快速弹性等基本特征外，还可提供当前云计算技术无法保证的低时延、高可靠、高带宽和隐私安全等业务保障能力，边缘计算这些能力非常适合解决目前物联网行业应用中所面临的各种挑战。</p><p>边缘计算正与实际生活中的行业等进行融合。目前许多边缘用例都源于在本地实时处理数据的需要，因为某些真实应用场景中，将数据传输到数据中心进行处理会导致不可接受的延迟。比如目前现代化的制造厂就需要实时进行数据处理，需求处理：在工厂中，物联网将各种设备紧密联系在了一起，但大量的现代化设备往往每月将产生2TB及以上的数据，若要机器想要进行数据的分析处理的话需要将这部分海量数据传输到远程的云数据中心进行处理，这将会消耗大量的时间且财力，而在工厂设备附近便进行处理则会大大减少这部分数据传输的时间，成本也会更低，计算效率也会大大增加，这便是边缘计算在制造业的应用。</p><p>与我们生活贴近的例子，那便是自动驾驶汽车了。目前国内外大量学者都在进行自动驾驶汽车的研究。作为一种完全不需要操作的车辆，主动实现功能便是通过实时监测环境的变化以及自动进行实时导航切换路线。导航这部分功能自然不用多说，地图路由在导航的应用已经通过dijkstra算法进行优化，目前的GPS系统已经非常完善，重点则放在了实时监测上面。首先，在车辆行进过程中，所要采集的环境数据非常庞大，若仅仅通过云计算来进行计算判断车辆的行进路线，是非常危险的，云计算还需要车辆上传数据到云端再进行计算，在瞬息万变的道路上，一点点时延都有可能造成不可挽回的错误。此时边缘计算便发挥了作用，通过使用边缘计算，使得在其环境周边便能进行数据采集并高效完成数据处理并计算，使得正在行驶的汽车能够及时应对周边人员或是车道上可能出现的事件。这样方才能称之为安全的自动驾驶车辆，同时也是边缘计算的一大应用。</p><h2 id="2-现状分析"><a href="#2-现状分析" class="headerlink" title="2 现状分析"></a><strong>2 现状分析</strong></h2><h3 id="2-1-国内外发展状况"><a href="#2-1-国内外发展状况" class="headerlink" title="2.1 国内外发展状况"></a><strong>2.1 国内外发展状况</strong></h3><p>于2005年信息社会世界峰会上，国际电信联盟正式提出“物联网”概念，提出无所不在的“物联网”通信时代即将来临。世界上所有物体，从轮胎到牙刷、从房屋到纸巾都可以通过因特网主动进行信息交换。</p><p>国外大量国家非常重视物联网的战略地位。其中首当其冲的便是美国，2009年2月奥巴马签署7870亿美元经济刺激计划，其中计划投入智慧电网110亿美元，智慧医疗190亿美元。2009年10月，欧盟委员会以政策文件的形式对外发布了物联网战略，提出要让欧洲在基于互联网的智能基础设施发展领先全球。2006年韩国提出了为期10年的U—Kore8战略，2010年9月韩国通信委员会通过了《物联网基础设施构建基本规划》，将物联网市场确定为新增长动力，确定了构建物联网基础设施、发展物联网服务、研发物联网技术、营造物联网扩散环境等4大领域、12项课题。日本、澳大利亚、新加坡、法国、德国等其他发达国家也加快部署下一代物联网网络基础设施的步伐。</p><p>我国高度重视物联网产业的发展，将物联网作为战略性新兴产业予以重点关注和推进。国务院2006年发布的《国家中长期科学和技术发展规划纲要(2006～2020年)》’中关于“重要领域及其优先主题”、“重大专项”和“前沿技术”均有涉及物联网的内容。几年来，中国物联网发展的政策环境不断改善，技术进步明显加快。市场培育持续深化，标准制定全面提速，产业投资大幅增长。以国家在无锡设覆国家传感嘲创新示范区为标志，中国物联网正加速发展，工业互联网作为中国智能制造业发展的重要支撑，已经得到我国政府高度重视，“十三五”规划、《国务院关于积极推进“互联网+”行动的指导意见》、《关于深化制造业与互联网融合发展的指导意见》都明确提出发展工业互联网。</p><p>另一方面，边缘计算也正发展迅速。2013年，美国太平洋西北国家实验室的Ryan LaMothe在一个2页纸的内部报告中提出“edge computing”一词，这是现代“edge computing”的首次提出。此时，边缘计算的涵义已经既有云服务功能的下行，还有万物互联服务的上行。</p><p>在学术界，2016年5月，美国韦恩州立大学施巍松教授团队给出了边缘计算的一个正式定义边缘计算是指在网络边缘执行计算的一种新型计算模型，边缘计算操作的对象包括来自于云服务的下行数据和来自于万物互联服务的上行数据，而边缘计算的边缘是指从数据源到云计算中心路径之间的任意计算和网络资源，是一个连续统。并发表了“Edge Computing: Vision and Challenges”一文， 第1次指出了边缘计算所面临的挑战，该文在2018年底被他引650次.同年10月，ACM和IEEE开始联合举办边缘计算顶级会议（ACM/IEEE Symposium on Edge Computing，SEC)，这是全球首个以边缘计算为主题的科研学术会议.自此之后，ICDCS, INFOCOM, Middleware, WWW 等重要国际会议也开始增加边缘计算的分会（tack)或者专题研讨会(workshop)。</p><p>2018年是边缘计算发展过程中的重要节点，尽管此前业内已经对边缘计算报以了很大期望，而 2018年边缘计算被推向前台，开始被大众熟知。这一阶段，边缘计算的参与者范围扩大很快，如表1所示，参与者已经基本涵盖了计算机领域的方方面面，本文将它们分为6类：云计算公司、硬件厂商、CDN 公司、通信运营商、科研机构和产业联盟/开源社区，并在表1中列举它们近2年在边缘计算领域的事件。</p><p><img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.001.png"></p><p><img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.002.png"></p><p>而将两者联合起来，便汇成了本文所要表述的重点。物联网是实现行业数字化转型的重要手段，并将催生新的产业生态和商业模式。而借助于边缘计算和人工智能等新技术将更能提升物联网的智能化，促使物联网在各个垂直行业落地生根。图1示例了应用于物联网中的边缘计算的设备形态和所处的位置。</p><p><img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.003.png"></p><blockquote><p>图1 边缘计算应用于物联网</p></blockquote><p>由于互联网和电信网本身能够支持和提供的网络带宽和传输时延有限，目前边缘计算在物联网应用的发展面临诸多挑战。</p><p><strong>1)网络能力限制。</strong></p><p>4G/5G的普及给网络能力带来了很大的提升，但联网终端设备的超速增长和多种多样的业务应用将带来数据爆炸式增长，这些海量数据在为我们提供商业价值的同时，也对数据处理提出挑战，海量数据的传输和处理将带来更大的网络流量压力并需要更多的云数据中心。 </p><p><strong>2)终端资源限制。</strong></p><p>物联网终端由于自身的计算、存储能力以及供电方式的限制，难以应对实时产生的大量数据处理和分析要求，而将数据发送到云端进行处理又难以满足物联网终端在时延性、可靠性或隐私安全等方面的要求。</p><p><strong>3)异构系统互联。</strong></p><p>在物联网环境下，终端类型和采用的连接协议多种多样，物联网应用难以对联接的终端在数据收集、数据分析、终端控制等方面进行适配操作。</p><p><strong>4)安全和隐私挑战。</strong> </p><p>物联网领域面临窃听、跟踪、攻击、欺骗、重放、克隆、物理破解、篡改信息、DDoS、病毒等安全和隐私威胁，很容易引发个人信息泄露、财产损失、法律风险、生产停顿、人身安全或生产事故。</p><h3 id="2-2-文献分析"><a href="#2-2-文献分析" class="headerlink" title="2.2 文献分析"></a><strong>2.2 文献分析</strong></h3><p>对于国内数据，以CNKI为来源数据库，运用其高级检索模块，以“边缘计算”为关键词，精确检索，时间为 2016.1.1-2020.12.31（为 符 合 CiteSpace 时间片设置，以下内容统称为 2016-2020年），共检索出 1078条中文文献。而对于国外数据，以 Web of science 核心库高被引文献为对象，以“Edge Computing”为主题，选取时间 2016-2020 年，并通过“Remove duplicates”进行去重，共获得高被引论文210篇。国内数据通过CNKI获取，对检索出的文献，以不 同年份利用图表将其展示出来，如下图所示。</p><p><img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.004.png"></p><blockquote><p>图2   2016-2020年国内边缘计算文献发文量</p></blockquote><p>从图 2我们可以分析得出，国内对于边缘计算的研究大致可以分三个阶段，第一阶段是2016-2017年，该阶段边缘计算定义刚刚提出，开始被相关学者、企业所关注，但并没有进行深入探讨，因边缘计算在理论体系、模型、机制等方面没有统一的方案；更因该年度云计算是研究的重点，注重云端，而忽略了边缘端。</p><p>第二阶段2017-2018年，这一阶段，对于边缘计算的研究处于明显的上升期，由于云计算暴露出的问题，如云端数据处理压力大，网络延迟等，使得专家学者逐渐开始从云端转向边缘端，文献量也明显增加。</p><p>第三阶段 2018-2020 年，该阶段对于边缘计算的研究明显处于激增状态，这是由多方原因引起。首先，云端研究遭遇瓶颈，如网络延迟、数据处理能力压力大等；其次，2019 年 IOT、CPS、移动网络等技术得到了飞速发展，使得更多边缘设备接入到互联网中，这也使得对边缘计算的关注不断提高。</p><p>另外，从图3可以看出，2018-2020年发文量较高，这是因为该年度相关企业、机构开始进入到边缘计算领域，如华为、中科院、中信院、腾讯、阿里、百度等，并成立了相关组织，旨在通过会议、资金的投入加大对边缘计算领域的研究，这直接助推了边缘计算的发展。</p><p>国外文献来源于 Web of science 高被引文献，选 取时间为近五年，其文献发文量趋势如图3所示。<img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.005.png"></p><blockquote><p>图3  2016-2020年国外边缘计算高被引文献发文量</p></blockquote><p>从图 3 中可知，国外对边缘计算的关注度在初期是明显高于国内，尤其是2017-2019年期间，对边缘计算的研究便已经处于激增状态，这种状态是因为边缘计算研究思想来源于国外，国外更早的掌握了边缘计算的基础知识和核心架构。另外，国外云计算、物联网、人工智能等相关领域技术的成熟，引导了边缘计算的发展。从发文量的增长趋势来看，边缘计算仍然会是国外未来一段时间研究的热点领域。</p><h2 id="3-相关技术"><a href="#3-相关技术" class="headerlink" title="3 相关技术"></a><strong>3 相关技术</strong></h2><h3 id="3-1-边云协同"><a href="#3-1-边云协同" class="headerlink" title="3.1 边云协同"></a><strong>3.1 边云协同</strong></h3><p>边缘计算和云计算在物联网应用中构成一个相辅相成的端到端系统，两者共同配合完成物联网应用的工作流，实现分布式最佳解决方 案。为契合物联网应用的发展，未来的云将呈现以集中式的云/数据中心和分布式的智能边缘计算互相协同的格局。 </p><p>云边缘，顾名思义是指中心云服务在边缘侧的延伸。它在逻辑上仍属于中心云服务的一部分，主要能力提供和核心业务逻辑的处理都依赖于中心云服务或需要与中心云服务紧密协同。各大云服务商已经在云边缘领域进入投入，比如华为云推出了IEF解决方案，阿里云有Link Edge解决方案，AWS则发布了Greengrass解决方案等。云服务商依靠自身的公有云和产业合作伙伴，将其公有云能力下沉至边缘，打造边缘基础设施服务、IoT服务、边缘数据存储/迁移服务等，并不断丰富和完善相关技术及服务，更好地实现边云协同。</p><p>在边云协同中，边缘计算侧重 于针对实时性、系统异构、短周期 数据、安全和隐私等要求比较高的 业务需求，比如对源或现场数据实 时处理、数据可视化、基本分析、 数据缓存、数据过滤和优化、M2M 通讯等；而云计算侧重于非实时、 长周期数据的业务需求，如大数据分析、数据仓储、业务逻辑、机器 推理、预测维护、日志存储等业务需求。为了减少对传输带宽的压力和传输成本，边缘计算需要把原始 数据过滤和清洗后再传送到云/数据 中心完成进一步的处理，形成“基于云计算的全局优化+基于边缘计 算的局部优化”的协同方式。 AII在边云协同研讨中，按照边缘计算和云计算提供的IaaS、PaaS 和SaaS对等层之间的交互原则，共识别有6类协同，即：IaaS资源&amp;安全协同、数据协同、智能协同、应用协同、业务协同、服务协同。边云协同相关的标准协议、接口技术需要围绕边云协同的典型应用场景 所识别出的需求进行制订。</p><p><img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.006.jpeg"></p><h3 id="3-2-使能5G"><a href="#3-2-使能5G" class="headerlink" title="3.2  使能5G"></a><strong>3.2  使能5G</strong></h3><p>随着信息技术向物联网领域的 延伸，支持物联网在网络吞吐量、 时延、连接数量和可靠性等方面业务需求的新一代5G通信技术将让万物互联在各个垂直行业应用落地成为可能。</p><p>5G不仅能提供速度更快的移动宽带，更代表着网络架构的升级，5G将颠覆移动网络的建网方式，并且这一架构所拥有的特性能够带来诸多商业价值。凭借端到端的网络虚拟化、网络切片、海量物联网通信、超低时延及移动边缘计算等特性，5G网络能够作为技术平台，帮助企业降低成本、提升客户体验、提高安全性，并创造新的收入来源。</p><p>边缘计算可以将5G无线网络能力信息抽象成各种类型的服务并开放给第三方应用和垂直行业，并借此在5G无线网络中提供多样化的业务场景。边缘计算为电信运营商实现灵活的网络功能部署与固移融合提供基础设施支撑，同时服务托管与基础服务能力也可以 帮助第三方应用提高用户体验。 通过边缘计算的使能，将促进 5G技术延伸到交通运输、智能驾 驶、车联网、工业互联网等各个垂 直行业。</p><p><img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.007.jpeg" alt="5G：使能垂直行业，开启数字平台-重庆智能工程职业学院"></p><h3 id="3-3-边缘切片"><a href="#3-3-边缘切片" class="headerlink" title="3.3 边缘切片"></a><strong>3.3 边缘切片</strong></h3><p>网络切片和边缘计算技术是 5G的两大关键技术，一直被业界 普遍认为是以低成本和方便快捷的 方式为用户提供个性化物联网业务 应用部署的使能技术。在不同的商 业模式下，物联网应用在网络吞吐 量、时延、连接数目和可靠性等方 面的性能指标都不尽相同，而且物 联网应用在基础资源需求和业务负 荷等方面都存在很大的动态性。网 络切片可将网络资源按照物联网应 用进行灵活地划分和管理，为垂直 行业提供物理/逻辑相互隔离的专 网，满足物联网应用对各类业务性 能指标的需求，提高服务质量保证 能力。应用于物联网的边缘切片对 网络进行定制化裁剪，可以实现灵 活的网元组网和最优的网络资源分 配，满足物联网业务应用的实时性 和动态性方面的需求。 边缘切片的实现将有助于与接 入网切片和核心网切片一起构成端到端的网络切片，满足大规模物联网应用部署的业务需 求，并保证物联网应用的快速发布和安全隔离。</p><h3 id="3-4-边缘智能"><a href="#3-4-边缘智能" class="headerlink" title="3.4 边缘智能"></a><strong>3.4 边缘智能</strong></h3><p>物联网终端数量庞大、终端类型和网络连接协议 繁多，存在很大的异构性，另外在生命周期管理、个性化需求、位置分布等方面都不相同，如何采用自治 的方式进行资源/设备自动发现、网络/应用自动部署和 运维、服务/业务自动提供也是边缘计算有待进一步研究的领域。</p><p><code> </code>近年来，物联网的普及让数以亿计的移动设备连接到互联网上，在网络边缘产生了海量的数据，使得一种全新的计算范式——边缘计算兴起。同时，得益于深度学习算法和摩尔定律的突破，使得人工智能的发展再一次迎来了高潮。在这一趋势下，将边缘计算与人工智能相结合是必然的，由此产生的新的交叉研究——边缘智能引了许多学者的广泛关注。机器学习/深度学习和人工智能技术与边缘计算的 结合将使能边缘计算在敏捷联接、实时响应、应用智能、数据优化、安全和隐私等各个层面的智能化，并保 证在脱离云计算的情况下，物联网应用也能够独立地、 灵活地运行，比如电梯的预测性维护、无人工厂实时动态自我优化。 边缘智能有助于促进各行业数字化转型的智能化。 智能化是以提供的智能化工具和策略为基础，对数据进 行智能化分析，从而实现智能决策和智能操作，以及业 务流程的持续智能优化。随着物联网智能化需求分布到 网络边缘侧，也将促进边缘计算的智能化发展，并进一 步实现物的自主化和协作化。</p><h3 id="3-5-开源实现"><a href="#3-5-开源实现" class="headerlink" title="3.5 开源实现"></a><strong>3.5 开源实现</strong></h3><p>为方便边缘计算产品功能的快速开发，以及加速 边缘计算在垂直行业的落地，建立边缘计算平台的开 源社区也是实现边缘计算生态培育的重要促进手段之 一。EdgeX Foundry旨在打造一个物联网边缘计算开放 框架，简化物联网边缘平台构建，降低边缘计算平台准 入门槛；OpenStack社区(2018年2月，OpenStack发布 《云边缘计算-跨越传统数据中心》白皮书，该白皮书 提倡创建一个跨行业联盟，来监督边缘计算所需工具的 打造和相关技术标准的制定)也成立了专门的边缘计算 工作组来关注云计算向边缘演化的趋势；Linux基金会 即将开源致力于边缘计算的Akraino Edge Stack项目， 以支持针对边缘计算系统和应用进行优化的高可用性云 服务，为5G和物联网应用提供新的生态系统。</p><h2 id="4-应用分析"><a href="#4-应用分析" class="headerlink" title="4 应用分析"></a><strong>4 应用分析</strong></h2><p><img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.008.png"></p><blockquote><p>图3  边缘计算在物联网中应用示例</p></blockquote><h3 id="4-1-智能制造"><a href="#4-1-智能制造" class="headerlink" title="4.1  智能制造"></a><strong>4.1  智能制造</strong></h3><p>智能制造是边缘计算在物联网 中非常典型的应用领域，借助于边缘计算将促进IT和OT系统的深度融合。工业机器人是实现智能制造的基础，最近几年工业机器人在中 国市场呈现蓬勃发展的趋势。据统 计，2016年中国市场工业机器人消 费总量达87 000台，接近世界销量的近三分之一，是世界上最大的工业机器人市场。工业机器人的应用 领域主要集中在汽车制造、3C行 业、物流、金属加工、塑料和化工等行业，通过机器人完成搬运和上下料、装配和拆卸、焊接等工作环 境恶劣、自动化/执行精度和安全程 度要求非常高的工作场景。 </p><p>工业机器人需要具备应对复杂 的现场环境并结合当前工作流程进 行综合分析和判断的能力，以及与其他机器人协作完成复杂工作任务 的能力。这些都需要机器人配备智能控制器以执行复杂的计算任务， 而对于工厂环境使用几十、上百台 机器人的应用场景，如果每台机器 人都配备复杂的智能控制器，这将增加机器人的成本。但是如果采用边缘技术，把工业机器人的智能控制器功能集中部署在生产车间的边缘节点，在保证时延的情况下还能实现集中控制，完成机器人之间的 联动协同，可以大大降低工业机器人的开发、部署和维护成本。图4 示例了把工厂车间里机器人的智能控制器集中部署在边缘计算节点 (边缘网关)的场景。</p><p><img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.009.png"></p><blockquote><p>图4 边缘计算对工厂车间内机器人集中控制示例</p></blockquote><h3 id="4-2-智慧交通"><a href="#4-2-智慧交通" class="headerlink" title="4.2 智慧交通"></a><strong>4.2 智慧交通</strong></h3><p>在城市道路交通中，每个路 口都会设置监控摄像头，每周甚 至每天都会有海量的视频数据产 生，如果这些监控设备产生的数 据聚在一起，会是个天文数字。 在云端进行实时的海量数据分析与储存对计算能力和网络带宽是一个巨大的挑战。如果借助边缘 计算，在本地对海量视频数据进 行存储和分析，仅识别和截取存在道路交通事故或违法行为的视 频传递给云/数据中心做进一步分 析和长久存储，这样可以大大减 少到云端的数据传输，并且能够 支持实时的智能交通控制。 图5示例了边缘计算在城市交通中的应用，通过边缘计算的实时数据处理和分析功能，可以支 持无人驾驶、交通流量疏导和拥 堵预测这类业务功能。另外也提供本地的监控数据存储，对数据进行处理和清洗后再把有效数据 传递给云/数据中心做进一步分析的边云协同。</p><p>无人驾驶汽车（如特斯拉、谷歌汽车）是车辆智能化的一种表现形式，其主要依靠车内以计算机系 统为主的智能驾车仪，通过车载传感系统感知路面环境，自动规划行车路线并控制车辆到达预定目标来实现无人驾驶。它能针对实时交通情况做出合理决策，并辅助甚至替代驾驶员驾驶车辆的能力，从而减小驾驶员的劳动强度，使车辆行驶过程变得更安 全。</p><p>此外，对于多飞行器之间的协调控制，边缘计算 模型除了能够实现飞行器本身所采集数据的实时处 理，同时与其他飞行器实时共享这些信息，这样降低了原有云计算模型下经数据中心中转的时间，并且 减少了因数据传输所消耗的电能。</p><p><img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.010.png"></p><blockquote><p>图5  边缘计算在智慧交通中的应用示例</p></blockquote><h3 id="4-3-智慧城市"><a href="#4-3-智慧城市" class="headerlink" title="4.3 智慧城市"></a><strong>4.3 智慧城市</strong></h3><p>智慧城市是构建“宜居、舒 适、安全”的城市生活环境，实现 城市“感知、互联和智慧”。智慧 城市建设是涉及诸多信息系统、综 合集成技术的大型信息化工程。物 联网技术将为城市基础设施的整体 升级提供智能化的支撑，而边缘计 算将丰富智慧城市的应用场景。如图6所示，一般智慧城市具 有家庭、小区、社区和城市4个层 级。每个层级都有对应的应用和服 务，比如家庭有智能家居、智能安防和家庭娱乐系统等；小区有门禁和视频监控、车辆人员管理和物业 服务等；社区有社区商场、社区医疗和社区政务等；城市有交通、物 流、医疗、金融和市政服务等。边 缘计算将在智慧城市这4个层级之 间提供层次化的管理和服务功能， 并协同彼此之间的发展。</p><p><img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.011.png"></p><blockquote><p> 图6 边缘计算在智慧城市中的应用示例</p></blockquote><p>边缘计算模型可从智能家居灵活地扩展到社区甚至城市的规模。根据边缘计算模型中将计算最大 程度迁移到数据源附近的原则，用户需求在计算模 型上层产生并且在边缘处理。边缘计算可作为智慧 城市中一种较理想的平台，主要取决于以下３个方面： </p><p><strong>１）大数据量</strong></p><p>据 思 科 全 球 云 指 数 预 测，到2019年，一个百万人口的城市每天将产生180PB的数据，其主要来自于公共安全、健康数据、公共设施以及交通运输等领域．用云计算模型处理这些海量 数据是不现实的，因为云计算模型会引起较重传输 带宽负载和较长传输延时。在网络边缘设备进行数据处理的边缘计算模型将是一种高效的解决方案。 </p><p><strong>２）低延时</strong></p><p>万物互联环境下，大多数应用具有低延时的需求（比如健康急救和公共安全），边缘计算模型可以降低数据传输时间，简化网络结构。此外，与云计算模型相比，边缘网络对决策和诊断信息 的收集将更加高效． </p><p><strong>３）位置识别</strong></p><p>如运输和设施管理等基于地理位置的应用，对于位置识别技术，边缘计算模型优于云计算模型．在边缘计算模型中，基于地理位置的数据 可进行实时处理和收集，而不必传送到云计算中心。</p><h3 id="4-4-智能家居"><a href="#4-4-智能家居" class="headerlink" title="4.4  智能家居"></a><strong>4.4  智能家居</strong></h3><p>在当前的智能家居中，智能家电设备基本上都是由智能单品构成的，比如密码锁、智能照明、智能空调、安防监控、智能卫浴、室内环境监控、家庭影院多媒体系统等，这些智能家电设备需要依赖于云平台才能实现手机端在外网的远程控制。这种基于云平台的智能家 居在网络出现故障时将无法进行控 制，特别是多个智能单品联动的场景将无法对多个设备进行协调。</p><p>智能家电设备都是通过Wi-Fi模块连接 到云/数据中心，用户对存放在云/ 数据中心的家庭数据也存在泄漏的担忧，另外大量的监控视频数据也会消耗智能家居设备到云/数据中心之间的通信带宽。 如图7所示，采用边缘计算技术，可以把家庭视频数据存放在本地边缘计算网关设备上，确保用户的隐私不被泄漏；多个智能单品之间的联动也可以通过本地边缘计算进行近实时的协调；边缘计算节点还能实现定期与云计算同步更新控 制和设备状态信息。家居生活随着万物互联应用的普及变得越来越智能和便利，如智能照明控制系统、智能电视、智能机器人等。然 而，在智能设备中，仅通过一种Wi-Fi模块连接到云计算中心的做法，远远不能满足智能家居的需求。智能家居环境中，除了联网设备外，廉价的无线传感器和控制器应部署到房间、管道、地板和墙壁等，出于数据传输负载和数据隐私的考虑，这些敏感数据的处理应在家庭范围内完成。传统的云计算模型已不能完全适用于智能家居类应用，而边缘计算模型是组建智能家居系统的最优平台。在家庭内部的边缘网关上运行边缘操作系统（edge operation system, Edge OS）。</p><p><img src="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/Aspose.Words.28e70789-de9a-442f-b7e7-efaad43b67cb.012.png"></p><blockquote><p>图7边缘计算在智能家居中的应用示例</p></blockquote><h2 id="5未来方向"><a href="#5未来方向" class="headerlink" title="5未来方向"></a><strong>5未来方向</strong></h2><p>本文通过国内外数据的对比，可发现国内相关方面还存在一些问题，今后可从以下几方面加大关注度。</p><p><strong>⑴ 边缘计算基础理论的研究。</strong></p><p>从国外文献关键词时序图谱可发现，国外更加注重对边缘计算相关理论的研究，而国内这方面比较欠缺，国内将更多的研究内容放在了其应用之上，但相关研究成果却并不是很多，这是边缘计算以及相关技术理论基础并不牢固所导致。国内应加深边缘计算理论研究，形成统一的理论认知体系，促进边缘计算及相关产业的发展。</p><p><strong>⑵ 立足自身产业优势，拓宽边缘计算领域研究。</strong></p><p>国内在产业领域的创新技术已然赶上国外水平，甚至是超过了国外。以国内的华为、阿里、腾讯为代表，如，可依托阿里云，发挥云计算的技术优势，助推边缘计算的发展，形成云边协同的发展态势，实现云边端三位一体的计算模式。依托由华为联合中科院、中信院、ARM成立的边缘计算产业联盟，构建边缘计算产业合作平台，推动IOT、人工智能、5G等相关产业的发展。</p><p><strong>⑶ 加大研究合作力度。</strong></p><p>相比于国外来说，国内边缘计算相关研究学者、机构、企事业单位缺乏合作。有目的性的合作可挖掘出更多潜在的价值信息，各研究方在国家政策下，广泛开展合作，积极探讨边缘计算领域知识，如云边协同平台实现问题、如何有效应对不同环境、技术、产业的冲击问题、边缘计算相关理论体系的一致性等，问题的解决，将使得边缘计算向着更加科学、平稳的状态发展。</p><p><code> </code><strong>⑷ 智能时代对边缘端的要求。</strong></p><p>数据密集型范式 的形成，加快了智能时代的到来。在智能时代背景下， 对基础设施的要求变得越来越高，尤其是IOT、CPS的 快速发展，使得越来越多的智能设备接入网络，促使 了设备需具备计算的能力。加大对设备的建设，必然需要更多的关注边缘计算、移动边缘计算领域。</p><h2 id="6-总结与展望"><a href="#6-总结与展望" class="headerlink" title="6 总结与展望"></a><strong>6 总结与展望</strong></h2><p>本文主要讨论了物联网和边缘计算的基本定义，结合国内外的发展背景，以及国内外论文的文献数，分析了目前在边缘计算以及物联网的发展趋势。结合边云协同、使能5G、边缘切片、边缘智能和开源实现等相关技术，探讨了边缘计算在物联网领域的发展以及应用，并举例了生活中的部分示例。</p><p>在边缘式大数据处理的时代下，云计算的问题已经显露：无法有效解决云中心负载、传输带宽、数据隐私保护等等。万物互联的背景下，能够低时延、安全的边缘计算得到了极大的发展。边缘计算是连接物与云，物理世界与云端计算的桥梁，是是信息技术向物理世界的延伸。</p><p>边云计算的协同性、自主化以及与机器/深度学习、人工智能和5G等新技术的融合将促进智能边缘计算的到来，并将继续扩展物联网的边界。相信按照这种发展趋势继续进行下去，边缘计算在万物互联中的应用定在不久的将来成为现实。</p>]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法上机实验</title>
      <link href="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"/>
      <url>/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="算法分析与设计"><a href="#算法分析与设计" class="headerlink" title="算法分析与设计"></a>算法分析与设计</h1><h2 id="渗透问题（Percolation）"><a href="#渗透问题（Percolation）" class="headerlink" title="渗透问题（Percolation）"></a>渗透问题（Percolation）</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>使用合并-查找（union-find）数据结构，编写程序通过蒙特卡罗模拟（Monte Carlo simulation）来估计渗透阈值的值。</p><h3 id="二、题目描述"><a href="#二、题目描述" class="headerlink" title="二、题目描述"></a>二、题目描述</h3><p><strong>模型。</strong> 我们使用N×N网格点来模型一个渗透系统。 每个格点或是open格点或是blocked格点。 一个full site是一个open格点，它可以通过一连串的邻近（左，右，上，下）open格点连通到顶行的一个open格点。如果在底行中有一个full site格点，则称系统是渗透的。（对于绝缘/金属材料的例子，open格点对应于金属材料，渗透系统有一条从顶行到底行的金属路径，且full sites格点导电。对于多孔物质示例，open格点对应于空格，水可能流过，从而渗透系统使水充满open格点，自顶向下流动。）</p><p><img src="/images/algs4/image-20211225134840912.png"></p><p><strong>问题。</strong> 在一个著名的科学问题中，研究人员对以下问题感兴趣：如果将格点以空置概率p独立地设置为open格点（因此以概率1-p被设置为blocked格点），系统渗透的概率是多少？ 当p = 0时，系统不会渗出; 当p=1时，系统渗透。 下图显示了20×20随机网格（左）和100×100随机网格（右）的格点空置概率p与渗滤概率。</p><p>​                                <img src="/images/algs4/image-20211225134910165.png">           <img src="images/algs4/image-20211225134919354.png"></p><p><strong>当N足够大时，存在阈值p</strong><em>，使得当p &lt;p* ，随机N N网格几乎不会渗透，并且当p&gt; p</em>时，随机N N网格几乎总是渗透。 尚未得出用于确定渗滤阈值p<em>的数学解。<strong>你的任务是编写一个计算机程序来估计p</strong></em>。</p><h3 id="三、解决方法"><a href="#三、解决方法" class="headerlink" title="三、解决方法"></a>三、解决方法</h3><p><strong>Percolation数据类型。</strong>模型化一个Percolation系统，创建含有以下API的数据类型Percolation。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Percolation</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Percolation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span>           <span class="hljs-comment">// create N-by-N grid, with all sites blocked</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span>         <span class="hljs-comment">// open site (row i, column j) if it is not already</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span>    <span class="hljs-comment">// is site (row i, column j) open?</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span>     <span class="hljs-comment">// is site (row i, column j) full?</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">percolates</span><span class="hljs-params">()</span>          <span class="hljs-comment">// does the system percolate?</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-comment">// test client, optional</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>约定行i列j下标在1和N之间，其中(1, 1)为左上格点位置：如果open(), isOpen(), or isFull()不在这个规定的范围，则抛出IndexOutOfBoundsException例外。如果N ≤ 0，构造函数应该抛出IllegalArgumentException例外。构造函数应该与N2成正比。所有方法应该为常量时间加上常量次调用合并-查找方法union(), find(), connected(), and count()。</p><p><strong>蒙特卡洛模拟（Monte Carlo simulation）</strong>. 要估计渗透阈值，考虑以下计算实验：</p><ul><li>初始化所有格点为blocked。</li><li>重复以下操作直到系统渗出：<ul><li>在所有blocked的格点之间随机均匀选择一个格点 (row i, column j)。</li><li>设置这个格点(row i, column j)为open格点。</li></ul></li><li>open格点的比例提供了系统渗透时渗透阈值的一个估计。</li></ul><p>例如，如果在20×20的网格中，根据以下快照的<em>open</em>格点数，那么对渗滤阈值的估计是204/400 = 0.51，因为当第204个格点被<em>open</em>时系统渗透。</p><img src="images/algs4/image-20211225135642643.png" alt style="zoom: 50%;"><p>通过重复该计算实验<em>T</em>次并对结果求平均值，我们获得了更准确的渗滤阈值估计。 令<em>xt</em>是第<em>t</em>次计算实验中<em>open</em>格点所占比例。 样本均值<em>m</em>提供渗滤阈值的一个估计值； 样本标准差<em>s</em>测量阈值的灵敏性。<br>$$<br>\mu=\frac { x_1+x_2+\ldots+x_T } { T }, \sigma^2=\frac { { (x_1-\mu) } ^2+ { (x_2-\mu) } ^2 + \ldots+ { (x_T-\mu) } ^2 } { T-1 }<br>$$<br>假设<em>T</em>足够大（例如至少30），以下为渗滤阈值提供95％置信区间：<br>$$<br>\left[\mu-\frac { 1.96\sigma } {\sqrt T},\ \mu+\frac { 1.96\sigma } { \sqrt T }\right]<br>$$<br>我们创建<strong>数据类型PercolationStats来执行一系列计算实验</strong>，包含以下API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PercolationStats</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PercolationStats</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> T)</span>    <span class="hljs-comment">// perform T independent computational experiments on an N-by-N grid</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">mean</span><span class="hljs-params">()</span>                <span class="hljs-comment">// sample mean of percolation threshold</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">stddev</span><span class="hljs-params">()</span>               <span class="hljs-comment">// sample standard deviation of percolation threshold</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">confidenceLo</span><span class="hljs-params">()</span>         <span class="hljs-comment">// returns lower bound of the 95% confidence interval</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">confidenceHi</span><span class="hljs-params">()</span>         <span class="hljs-comment">// returns upper bound of the 95% confidence interval</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>    <span class="hljs-comment">// test client, described below</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>在N ≤ 0或T ≤ 0时，构造函数应该抛出java.lang.IllegalArgumentException例外。</p><p>此外，还包括一个main( )方法，它取两个命令行参数N和T，在N×N网格上进行T次独立的计算实验（上面讨论），并打印出均值μ、标准差σ和95％ 渗透阈值的置信区间。 使用标准库中的标准随机数生成随机数； 使用标准统计库来计算样本均值和标准差。</p><h3 id="四、算法及解释"><a href="#四、算法及解释" class="headerlink" title="四、算法及解释"></a>四、算法及解释</h3><p>使用<strong>quick-find</strong>算法实现Percolation数据类型。进行实验表明当<em>N</em>加倍时对运行时间的影响；<strong>使用近似表示法</strong>，给出在计算机上的总时间，它是<strong>输入N和T的函数表达式</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickFindUF</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<span class="hljs-comment">//number of components</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] id;<span class="hljs-comment">//id[i] = component identifier of i</span><br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QuickFindUF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span><span class="hljs-comment">//初始化</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span><span class="hljs-comment">//返回连通分量的个数</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span> <span class="hljs-comment">//若p，q在同一分量中则返回true</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span><span class="hljs-comment">//返回根节点</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span><span class="hljs-comment">//Union p and q </span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>使用<strong>weighted quick-union</strong>算法实现Percolation数据类型。进行实验表明当N加倍时对运行时间的影响；使用近似表示法，给出在计算机上的总时间，它是<strong>输入N和T的函数表达式</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeightedQuickUnionUF</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<span class="hljs-comment">//number of components</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] id;<span class="hljs-comment">//id[i] = component identifier of i</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] sz;<span class="hljs-comment">//权值大小</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeightedQuickUnionUF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span><span class="hljs-comment">//初始化</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span><span class="hljs-comment">//返回连通分量的个数</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span> <span class="hljs-comment">//若p，q在同一分量中则返回true</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span><span class="hljs-comment">//返回根节点</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span><span class="hljs-comment">//Union p and q </span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>构造Percolate_problem类</strong>，使其能够实现存储渗透的点阵，并能够判断最后其点阵是否渗透。以下简单说明各函数功能以及实现要点。</p><ol><li><p>初始化时构造一个虚拟的顶部以及底部，以便判断是否渗透。因为有这俩顶点，所以进行初始化时QF和WQU都为<strong>N*N+2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)QF = <span class="hljs-keyword">new</span> QuickFindUF(N*N+<span class="hljs-number">2</span>);<br><span class="hljs-keyword">else</span>WQU = <span class="hljs-keyword">new</span> WeightedQuickUnionUF(N*N+<span class="hljs-number">2</span>);<br>   <br>virtualTop = perRowColumnSize * perRowColumnSize;<br>virtualBottom = virtualTop + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>构建一个TransIndex函数，以便在查询节点位置中更简洁更易理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">TransIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> column)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (row - <span class="hljs-number">1</span>) * perRowColumnSize + column - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>输入t，以区分目前open的节点正在使用quickfind或是WeightedQuickUnion算法。open新节点时需连接上下左右，此时需小心是否溢出边界，是否直接为首行或者尾行（直接与虚顶和虚底进行连接）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//QuickFindUF</span><br><span class="hljs-keyword">int</span> loc = TransIndex(row,column);<br><span class="hljs-keyword">if</span>(sites[loc])  <span class="hljs-keyword">return</span>;<br>sites[loc] = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">int</span> neighbor;    <br><span class="hljs-comment">//若在首排或者尾排</span><br>   <span class="hljs-keyword">if</span>(row == <span class="hljs-number">1</span>)  QF.union(loc, virtualTop);<br>   <span class="hljs-keyword">if</span>(row == perRowColumnSize)  QF.union(loc, virtualBottom);<br>   <br><span class="hljs-comment">//连接上下左右</span><br>   <span class="hljs-keyword">if</span>(row&gt;<span class="hljs-number">1</span>) &#123;<br>    neighbor = TransIndex(row-<span class="hljs-number">1</span>,column);<br>    <span class="hljs-keyword">if</span>(sites[neighbor]) QF.union(loc, neighbor);<br>&#125;<br>   <span class="hljs-keyword">if</span>(row&lt;perRowColumnSize) &#123;<br>    neighbor = TransIndex(row+<span class="hljs-number">1</span>,column);<br>    <span class="hljs-keyword">if</span>(sites[neighbor]) QF.union(loc, neighbor);<br>   &#125;<br>   <span class="hljs-keyword">if</span>(column&gt;<span class="hljs-number">1</span>) &#123;<br>    neighbor = TransIndex(row,column-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(sites[neighbor]) QF.union(loc, neighbor);<br>   &#125;<br>   <span class="hljs-keyword">if</span>(column&lt;perRowColumnSize) &#123;<br>    neighbor = TransIndex(row,column+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(sites[neighbor]) QF.union(loc, neighbor);<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>通过判断顶部和底部是否连接来判断该模型是否渗透</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPercolated</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(t == <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> QF.isConnected(virtualTop, virtualBottom);<br><span class="hljs-keyword">else</span>   <span class="hljs-keyword">return</span> WQU.isConnected(virtualTop, virtualBottom);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用变量以及函数的简单介绍：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Percolate_problem</span> </span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] sites;<span class="hljs-comment">//渗透点阵</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> perRowColumnSize;<span class="hljs-comment">//每行数量</span><br><span class="hljs-keyword">private</span> WeightedQuickUnionUF WQU;<br><span class="hljs-keyword">private</span> QuickFindUF QF;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> virtualTop;<span class="hljs-comment">//虚拟顶部和尾部</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> virtualBottom;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Percolate_problem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">//初始化</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">TransIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> column)</span><span class="hljs-comment">//找到row，col对应索引</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> column)</span><span class="hljs-comment">//是否已经open</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> column, <span class="hljs-keyword">int</span> t)</span>；<span class="hljs-comment">//open节点</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPercolated</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span>；<span class="hljs-comment">//是否渗透</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>构造PercolateStatistics类</strong>：使其能得到随机的open节点，计算均值、标准差、置信区间以及输出结果。</p><ol><li><p>PercolateStatistics函数进行初始化：输入N*N的矩阵，T次循环，t来进行选择使用的算法</p></li><li><p>再不断循环t次中，每单次实验，不断得到随机数并open节点，直到渗透为止。以及open过的节点可以直接跳过不占用更多的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//single_test</span><br>Percolate_problem percolation = <span class="hljs-keyword">new</span> Percolate_problem(N, t);<br><span class="hljs-keyword">int</span> openCount = <span class="hljs-number">0</span>;<span class="hljs-comment">//Opened节点数</span><br><span class="hljs-keyword">while</span>(!percolation.isPercolated(t)) &#123;<br><span class="hljs-comment">//生成随机open点</span><br><span class="hljs-keyword">int</span> row = (<span class="hljs-keyword">int</span>)(Math.random() * n) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> col = (<span class="hljs-keyword">int</span>)(Math.random() * n) + <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//若已经open过了跳过</span><br><span class="hljs-keyword">if</span>(percolation.isOpen(row, col)) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>percolation.open(row, col, t);<br>openCount++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过prob数组记录每次实验所得到的比值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//记录每次得到的比例</span><br>prob[i] = (<span class="hljs-keyword">double</span>)openCount / (n * n);<br>Mean = mean(prob);<br>Stddev = stddev(prob);<br>Confidence_Low = confidenceLow(prob);<br>Confidence_High = confidenceHigh(prob);<br></code></pre></td></tr></table></figure><p>4.输出测试结果</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PercolateStatistics</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> prob[];<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> Mean;<span class="hljs-comment">//均值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> Stddev;<span class="hljs-comment">//标准差</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> Confidence_Low;<span class="hljs-comment">//置信区间_low</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> Confidence_High;<span class="hljs-comment">//置信区间_high</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PercolateStatistics</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N,<span class="hljs-keyword">int</span> T,<span class="hljs-keyword">int</span> t)</span> <span class="hljs-comment">//初始化</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getMean</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSteddev</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getConfidenceLow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getConfidenceHigh</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">confidenceHigh</span><span class="hljs-params">(<span class="hljs-keyword">double</span> prob[])</span><span class="hljs-comment">//计算置信区间_high</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">confidenceLow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> prob[])</span><span class="hljs-comment">//计算置信区间_low</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">mean</span><span class="hljs-params">(<span class="hljs-keyword">double</span> prob[])</span><span class="hljs-comment">//计算均值</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">stddev</span><span class="hljs-params">(<span class="hljs-keyword">double</span> prob[])</span><span class="hljs-comment">//计算标准差</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-comment">//输出结果</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h3><p><strong>测试数据：</strong></p><p><strong>N = 10， Times = 100；</strong></p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211224135818426.png" alt="image-20211224135818426" style="zoom: 80%;"><p><strong>N = 20， Times = 100；</strong></p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211224140433628.png" alt="image-20211224140433628" style="zoom:80%;"><p><strong>N = 40， Times = 100；</strong></p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211224141036095.png" alt="image-20211224141036095" style="zoom:80%;"><p><strong>N = 80， Times = 100；</strong></p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211224141117706.png" alt="image-20211224141117706" style="zoom:80%;"><p><strong>N = 100， Times = 100；</strong></p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211224140022141.png" alt="image-20211224140022141" style="zoom: 67%;"><p><strong>N = 160， Times = 100；</strong></p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211224141231709.png" alt="image-20211224141231709" style="zoom:67%;"><p><strong>N = 200，Times = 100；</strong></p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211224135619797.png" alt="image-20211224135619797" style="zoom:80%;"><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211224135632977.png" alt="image-20211224135632977" style="zoom:80%;"><p><strong>特殊情况：N = 2， Times = 100000；</strong></p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211224140957414.png" alt="image-20211224140957414" style="zoom:80%;"><h3 id="六、分析与总结"><a href="#六、分析与总结" class="headerlink" title="六、分析与总结"></a>六、分析与总结</h3><p>==<strong>分析：</strong>==</p><p><strong>T=100，时间单位都为ms</strong></p><table><thead><tr><th align="center"></th><th align="center">N=10</th><th align="center">N=20</th><th align="center">N=40</th><th align="center">N=80</th><th align="center">N=160</th><th align="center">N=100</th><th align="center">N=200</th></tr></thead><tbody><tr><td align="center">quick-find用时</td><td align="center">25</td><td align="center">160</td><td align="center">368</td><td align="center">3334</td><td align="center">47267</td><td align="center">7675</td><td align="center">137033</td></tr><tr><td align="center">weighted  quick-union用时</td><td align="center">34</td><td align="center">63</td><td align="center">108</td><td align="center">333</td><td align="center">957</td><td align="center">431</td><td align="center">1531</td></tr><tr><td align="center">QF的p*</td><td align="center">0.6055</td><td align="center">0.5872</td><td align="center">0.5956</td><td align="center">0.5903</td><td align="center">0.5937</td><td align="center">0.5921</td><td align="center">0.5929</td></tr><tr><td align="center">WQU的p*</td><td align="center">0.5846</td><td align="center">0.5929</td><td align="center">0.5877</td><td align="center">0.5923</td><td align="center">0.5917</td><td align="center">0.5915</td><td align="center">0.592</td></tr></tbody></table><blockquote><p>CPU: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz   1.80 GHz with 8GB RAM</p><p>OS: Windows 10 64位</p></blockquote><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211226142031488.png" alt="image-20211226142031488"></p><p>通过总结可以明显看出，在N极小的时候，两种算法的区别并不大，甚至当N=10，T=100时QF略快一筹。考虑其算法，此结果应该时由于WQU算法有额外数组的生成所导致的。</p><p>当N逐渐增大时，WQU加权的优化便明显体现出来了。在N=80时便已经有10倍的差距，在N=200时甚至达到了近90倍的差距。</p><p>最后根据两种方法求得的阈值进行加权平均，解得题目对应的阈值 p*=0.5925</p><p><strong>==总结==</strong></p><p>实际进行实验时，在逐渐加大N值时也明显感受到QF变得非常的缓慢，WQU的结果很快便出来了，QF却一直没出现，一度以为应用程序是否停止响应了。WQU这个优化虽然看上去不大，仅仅加了一个数组和一点实现，但最终呈现出来的速度差距竟然如此之大，使用正确的数据结构以及更快的算法才能得到更好的程序，受益匪浅。</p><hr><h2 id="几种排序算法的实验性能比较"><a href="#几种排序算法的实验性能比较" class="headerlink" title="几种排序算法的实验性能比较"></a>几种排序算法的实验性能比较</h2><h3 id="一、实验目的-1"><a href="#一、实验目的-1" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>通过对多种排序算法的实现，针对不同输入规模的数据进行实验，比 较各种排序算法的时间性能。</p><h3 id="二、题目描述-1"><a href="#二、题目描述-1" class="headerlink" title="二、题目描述"></a>二、题目描述</h3><p>实现插入排序（Insertion Sort，IS），自顶向下归并排序（Top-down Mergesort，TDM），自底向上归并排序（Bottom-up Mergesort，BUM），随机快速排序（Random Quicksort，RQ），Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）。</p><h3 id="三、解决方法-1"><a href="#三、解决方法-1" class="headerlink" title="三、解决方法"></a>三、解决方法</h3><p>在你的计算机上针对<strong>不同输入规模数据</strong>进行实验，对比上述排序算法的时间性能。要求对于每次输入运行10次，记录每次时间，取平均值。</p><h3 id="四、算法及解释-1"><a href="#四、算法及解释-1" class="headerlink" title="四、算法及解释"></a>四、算法及解释</h3><ol><li><p>插入排序 Insertion_Sort </p><p>不断插入一个数，并保持其已插入的数有序。也因为是直接插入，所以可以保持其稳定性，并且为原地排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>    <span class="hljs-keyword">int</span> key = arr[j];<br>    <span class="hljs-keyword">int</span> i = j<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[i] &gt; key) &#123;<br>        arr[i+<span class="hljs-number">1</span>] = arr[i];<br>        i--;<br>    &#125;<br>    arr[i+<span class="hljs-number">1</span>] = key;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自顶向下归并排序 Top-down Mergesort<br>自定向下的归并排序是逐渐递归的过程，因为使用了辅助数组，所以不是原地排序，但因为处理时对一分为二两个数组merge时的操作，所以保持了稳定性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cutSortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> array[],<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span>&#123;<br><span class="hljs-comment">//分割数组，一分为2，二分为四，，，</span><br><span class="hljs-keyword">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (low &lt; high)&#123;<br><span class="hljs-built_in">cutSortArray</span>(array, low, mid);<br><span class="hljs-built_in">cutSortArray</span>(array, mid + <span class="hljs-number">1</span>, high);<br><span class="hljs-built_in">merge</span>(array, low, mid, high);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p> 自底向上归并排序 Bottom-up Mergesort</p></li></ol><p>   自底向上归并排序是一个迭代的过程，通过不断增加size的的大小来进行排序。其他与上同理，是稳定的排序方法。</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BottomUp_Mergesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> array[], <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>    <span class="hljs-comment">// merge_length 由 1 开始逐步倍增</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> merge_length = <span class="hljs-number">1</span>; merge_length &lt; length; merge_length &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// start 为两个归并串开始的索引，一次增加两倍的 merge_length</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>; start &lt; length; start += merge_length &lt;&lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> first = start, first_tail = start + merge_length &lt; length ? start + merge_length : length;<br>            <span class="hljs-keyword">int</span> second = first_tail, second_tail = second + merge_length &lt; length ? second + merge_length : length;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 归并操作,两个序列均未取完，则先取小的</span><br>            <span class="hljs-keyword">while</span> (first &lt; first_tail &amp;&amp; second &lt; second_tail) &#123;<br>                tmp[i++] = array[first] &lt; array[second] ? array[first++] : array[second++];<br>            &#125;<br>            <span class="hljs-comment">// 存在一个序列已经取完，则将另一序列剩下的元素取尽</span><br>            <span class="hljs-keyword">while</span> (first &lt; first_tail) tmp[i++] = array[first++];<br>            <span class="hljs-keyword">while</span> (second &lt; second_tail) tmp[i++] = array[second++];<br>            <span class="hljs-comment">// 回填</span><br>            <span class="hljs-keyword">while</span> (--second_tail &gt;= start) array[second_tail] = tmp[--i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><p>随机快速排序 Random Quicksort</p><p>随机快排是在快排的基础上，为了避免完全逆序等特殊情况，首先将其打乱再进行排序的算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">RandomPivotPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> pvt, n, temp;<br>n = <span class="hljs-built_in">rand</span>();<br>pvt = low + n%(high-low+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">swap</span>(a[high], a[pvt]);<br> <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Partition</span>(a, low, high);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Random_Quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> pindex;<br><span class="hljs-keyword">if</span>(low &lt; high)<br>&#123;<br>pindex = <span class="hljs-built_in">RandomPivotPartition</span>(a, low, high);<br><span class="hljs-built_in">Random_Quicksort</span>(a, low, pindex<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">Random_Quicksort</span>(a, pindex+<span class="hljs-number">1</span>, high);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Dijkstra 3-路划分快速排序 Quicksort with Dijkstra 3-way Partition</p><p>QD3P将数组分为三个部分，分别是&lt;v, =v, &gt;v的三项，然后从v作为分割轴开始左边自增，右边交换中进行自减</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span>&amp; i, <span class="hljs-keyword">int</span>&amp; j)</span></span><br><span class="hljs-function"></span>&#123;<br>    i = l - <span class="hljs-number">1</span>, j = r;<br>    <span class="hljs-keyword">int</span> p = l - <span class="hljs-number">1</span>, q = r;<br>    <span class="hljs-keyword">int</span> v = a[r];<br> <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">//首先找到大于等于v的值</span><br>        <span class="hljs-keyword">while</span> (a[++i] &lt; v)<br>            ;<br><br>        <span class="hljs-keyword">while</span> (v &lt; a[--j])<br>            <span class="hljs-keyword">if</span> (j == l)<span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span> (i &gt;= j)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>        <span class="hljs-keyword">if</span> (a[i] == v) &#123;<br>            p++;<br>            <span class="hljs-built_in">swap</span>(a[p], a[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a[j] == v) &#123;<br>            q--;<br>            <span class="hljs-built_in">swap</span>(a[j], a[q]);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-built_in">swap</span>(a[i], a[r]);<br>    j = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt; p; k++, j--)<br>        <span class="hljs-built_in">swap</span>(a[k], a[j]);<br> <br>    i = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = r - <span class="hljs-number">1</span>; k &gt; q; k--, i++)<br>        <span class="hljs-built_in">swap</span>(a[i], a[k]);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QD_3Partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (r &lt;= l)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-built_in">partition</span>(a, l, r, i, j);<br> <br>    <span class="hljs-built_in">QD_3Partition</span>(a, l, j);<br>    <span class="hljs-built_in">QD_3Partition</span>(a, i, r);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="五、实验结果-1"><a href="#五、实验结果-1" class="headerlink" title="五、实验结果"></a>五、实验结果</h3><p>==<strong>随机数列</strong>==</p><p><strong>Insertion_Sort</strong></p><p> N = 1000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225231812865.png" alt="image-20211225231812865"></p><p>N = 10000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225231708477.png" alt="image-20211225231708477"></p><p>N = 100000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225232313832.png" alt="image-20211225232313832"></p><p><strong>TopDown_Mergesort</strong></p><p>N = 1000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225232446880.png" alt="image-20211225232446880"></p><p>N = 10000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225232528472.png" alt="image-20211225232528472"></p><p>N = 100000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225232545226.png" alt="image-20211225232545226"></p><p><strong>BottomUp_Mergesort：</strong></p><p>N = 1000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225232922040.png" alt="image-20211225232922040"></p><p>N = 10000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225233006554.png" alt="image-20211225233006554"></p><p>N = 100000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225233036114.png" alt="image-20211225233036114"></p><p><strong>Random Quicksort</strong></p><p>N = 1000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225233209613.png" alt="image-20211225233209613"></p><p>N = 10000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225233239226.png" alt="image-20211225233239226"></p><p>N = 100000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225233413539.png" alt="image-20211225233413539"></p><p><strong>QD_3Partition</strong></p><p>N = 1000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225233549999.png" alt="image-20211225233549999"></p><p>N = 10000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225233615498.png" alt="image-20211225233615498"></p><p>N = 100000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225233641684.png" alt="image-20211225233641684"></p><p><strong>使用vector+sort</strong></p><p>N = 100000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211226132801236.png" alt="image-20211226132801236"></p><p>==<strong>升序数列</strong>==</p><p><strong>Insertion_Sort</strong></p><p>N = 100000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211226134407209.png" alt="image-20211226134407209"></p><p><strong>TopDown_Mergesort</strong></p><p>N = 100000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211226134520903.png" alt="image-20211226134520903"></p><p><strong>BottomUp_Mergesort：</strong></p><p>N = 100000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211226134707777.png" alt="image-20211226134707777"></p><p><strong>Random Quicksort</strong></p><p>N = 100000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211226134830259.png" alt="image-20211226134830259"></p><p><strong>使用vector+sort</strong></p><p>N = 100000</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211226135256393.png" alt="image-20211226135256393"></p><h3 id="六、分析与总结-1"><a href="#六、分析与总结-1" class="headerlink" title="六、分析与总结"></a>六、分析与总结</h3><p><strong>随机数列</strong></p><p>N = 100000，Comparison of running time of sorting algorithms (in Micro Seconds)</p><table><thead><tr><th align="center"></th><th align="center">Run2</th><th align="center">Run3</th><th align="center">Run4</th><th align="center">Run5</th><th align="center">Run6</th><th align="center">Run1</th><th>Run7</th><th align="center">Run8</th><th align="center">Run9</th><th align="center">Run10</th><th align="center">Average</th></tr></thead><tbody><tr><td align="center">IS</td><td align="center">22.176</td><td align="center">23.255</td><td align="center">23.2</td><td align="center">22.964</td><td align="center">22.174</td><td align="center">22.376</td><td>24.074</td><td align="center">25.045</td><td align="center">24.479</td><td align="center">22.741</td><td align="center">23.2484</td></tr><tr><td align="center">TDM</td><td align="center">0.096</td><td align="center">0.103</td><td align="center">0.097</td><td align="center">0.098</td><td align="center">0.102</td><td align="center">0.117</td><td>0.095</td><td align="center">0.095</td><td align="center">0.0109</td><td align="center">0.107</td><td align="center">0.1019</td></tr><tr><td align="center">BUM</td><td align="center">0.06</td><td align="center">0.063</td><td align="center">0.061</td><td align="center">0.063</td><td align="center">0.066</td><td align="center">0.061</td><td>0.063</td><td align="center">0.066</td><td align="center">0.059</td><td align="center">0.06</td><td align="center">0.0622</td></tr><tr><td align="center">RQ</td><td align="center">0.087</td><td align="center">0.084</td><td align="center">0.074</td><td align="center">0.072</td><td align="center">0.07</td><td align="center">0.071</td><td>0.069</td><td align="center">0.071</td><td align="center">0.076</td><td align="center">0.078</td><td align="center">0.0752</td></tr><tr><td align="center">QD3P</td><td align="center">0.053</td><td align="center">0.061</td><td align="center">0.052</td><td align="center">0.057</td><td align="center">0.058</td><td align="center">0.054</td><td>0.055</td><td align="center">0.055</td><td align="center">0.058</td><td align="center">0.057</td><td align="center">0.056</td></tr><tr><td align="center">sort</td><td align="center">0.028</td><td align="center">0.028</td><td align="center">0.028</td><td align="center">0.027</td><td align="center">0.027</td><td align="center">0.034</td><td>0.028</td><td align="center">0.027</td><td align="center">0.028</td><td align="center">0.028</td><td align="center">0.0283</td></tr></tbody></table><p>本图与上述表格为同一张表，打开pdf后发现无法完整显示表格，所以另补了完整的图</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211226143852703.png" alt="image-20211226143852703"></p><blockquote><p>CPU: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz   1.80 GHz with 8GB RAM</p><p>OS: Windows 10 64位</p></blockquote><p><strong>升序数列</strong></p><p>N = 100000，Comparison of running time of sorting algorithms (in Micro Seconds)</p><table><thead><tr><th align="center"></th><th align="center">Run1</th><th align="center">Run2</th><th align="center">Run3</th><th align="center">Run4</th><th align="center">Run5</th><th align="center">Run6</th><th align="center">Run7</th><th align="center">Run8</th><th align="center">Run9</th><th align="center">Run10</th><th align="center">Average</th></tr></thead><tbody><tr><td align="center">IS</td><td align="center">0</td><td align="center">0.001</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0.001</td><td align="center">0</td><td align="center">0</td><td align="center">0.001</td><td align="center">0</td><td align="center">0.0003</td></tr><tr><td align="center">TDM</td><td align="center">0.018</td><td align="center">0.016</td><td align="center">0.016</td><td align="center">0.016</td><td align="center">0.015</td><td align="center">0.017</td><td align="center">0.015</td><td align="center">0.016</td><td align="center">0.015</td><td align="center">0.015</td><td align="center">0.0159</td></tr><tr><td align="center">BUM</td><td align="center">0.009</td><td align="center">0.01</td><td align="center">0.008</td><td align="center">0.01</td><td align="center">0.007</td><td align="center">0.011</td><td align="center">0.011</td><td align="center">0.009</td><td align="center">0.01</td><td align="center">0.009</td><td align="center">0.0094</td></tr><tr><td align="center">RQ</td><td align="center">0.016</td><td align="center">0.013</td><td align="center">0.014</td><td align="center">0.013</td><td align="center">0.013</td><td align="center">0.013</td><td align="center">0.013</td><td align="center">0.014</td><td align="center">0.013</td><td align="center">0.016</td><td align="center">0.0138</td></tr><tr><td align="center">sort</td><td align="center">0.017</td><td align="center">0.016</td><td align="center">0.017</td><td align="center">0.017</td><td align="center">0.017</td><td align="center">0.017</td><td align="center">0.016</td><td align="center">0.017</td><td align="center">0.017</td><td align="center">0.017</td><td align="center">0.0168</td></tr></tbody></table><blockquote><p>CPU: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz   1.80 GHz with 8GB RAM</p><p>OS: Windows 10 64位</p></blockquote><p>排序算法是唯一实验中使用c++的一次实验，因为一直很好奇在大规模数据的处理中，数组和vector对于数据的影响到底有多大，所以五种排序算法我首先都使用了数组的形式来完成，虽然预想之内，纯数组的实现会比vector和Java快很多，但没想到会快这么多…初次进行测试的时候甚至怀疑了代码的正确性，尝试打印数组查看后发现成功完成排序操作。</p><p>而由于没有算上vector和数组初始化的时间，仅通过直接调用algorithm库中的函数，通过查询<a href="https://www.cplusplus.com/reference/algorithm/sort/">sort</a>在c++官网上的定义，发现其不具备稳定性，并且大约为N*log2(N)次元素的比较。为何使用vector会比数组快，得出本次结果应该是因为在测试时我没有将初始化数组和初始化vector的时间加入一起计算，仅计算了算法本身的运行时间，按理论来说，vector+sort会比使用数组直接进行排序慢很多。</p><p>回答以下问题：</p><ol><li>Which sort worked best on data in constant or increasing order (i.e., already sorted data)? Why do you think this sort worked best?</li></ol><p>插入排序在正向有序时表现最好，此时无需插入数据，算法复杂度为O(n)</p><ol start="2"><li>Did the same sort do well on the case of mostly sorted data? Why or why not?</li></ol><p>插入排序在正向基本有序时表现仍然很好，因为算法中基本无需向有序序列中插入，只在尾部添加</p><ol start="3"><li>In general, did the ordering of the incoming data affect the performance of the sorting algorithms? Please answer this question by referencing specific data from your table to support your answer.</li></ol><p>数据的次序对归并排序影响很小，对IS、RQ和QD3P影响很大</p><ul><li><p>正向有序时，IS复杂度为O(n)，RQ和QD3P复杂度为O(n^2)</p></li><li><p>反向有序时，IS复杂度为O(n)，RQ和QD3P复杂度都为O(n^2)</p></li></ul><p>归并排序始终维持O(nlogn)</p><ol start="4"><li>Which sort did best on the shorter (i.e., <em>n</em> = 1,000) data sets? Did the same one do better on the longer (i.e., <em>n</em> = 10,000) data sets? Why or why not? Please use specific data from your table to support your answer.</li></ol><p>在随机数据中QD3P表现最好，因为QD3P判断和交换次数少，也解决了快速排序在大量重复数据时表现不好的问题</p><ol start="5"><li>In general, which sort did better? Give a hypothesis as to why the difference in performance exists.</li></ol><p>QD3P表现的最好，插入排序比较和交换过多，没有充分利用数据间已存在的大小关系，归并排序无视已有的大小关系，所以时间复杂度稳定，快速排序由于有随机化的步骤，所以消耗更多时间</p><ol start="6"><li>Are there results in your table that seem to be inconsistent? (e.g., If I get run times for a sort that look like this {1.3, 1.5, 1.6, 7.0, 1.2, 1.6, 1.4, 1.8, 2.0, 1.5] the 7.0 entry is not consistent with the rest). Why do you think this happened?</li></ol><p>​    在运行程序时如果同时让CPU占用率始终保持100%则由于操作系统调度可能导致程序分到的时间片过少，需要使用更长的实际时间才能完成排序</p><hr><h2 id="地图路由（Map-Routing）"><a href="#地图路由（Map-Routing）" class="headerlink" title="地图路由（Map Routing）"></a>地图路由（Map Routing）</h2><h3 id="一、实验目的-2"><a href="#一、实验目的-2" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>实现经典的Dijkstra最短路径算法，并对其进行优化。 这种算法广泛应用于地理信息系统（GIS），包括MapQuest和基于GPS的汽车导航系统。</p><h3 id="二、题目描述-2"><a href="#二、题目描述-2" class="headerlink" title="二、题目描述"></a>二、题目描述</h3><p><strong>地图。</strong> 本次实验对象是图maps或graphs，其中顶点为平面上的点，这些点由权值为欧氏距离的边相连成图。 可将顶点视为城市，将边视为相连的道路。 为了在文件中表示地图，我们列出了顶点数和边数，然后列出顶点（索引后跟其x和y坐标），然后列出边（顶点对），最后列出源点和汇点。 例如，如下左图信息表示右图：</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225151732144.png" alt="image-20211225151732144"></p><p><strong>Dijkstra算法</strong>。 Dijkstra算法是最短路径问题的经典解决方案。 它在教科书第21章中有描述。 基本思路不难理解。 对于图中的每个顶点，我们维护从源点到该顶点的最短已知的路径长度，并且将这些长度保持在优先队列（<em>priority queue</em>, <em>PQ</em>）中。 初始时，我们把所有的顶点放在这个队列中，并设置高优先级，然后将源点的优先级设为<strong>0.0</strong>。 算法通过从<em>PQ</em>中<strong>取出最低优先级的顶点</strong>，然后检查可从该顶点经由一条边可达的所有顶点，以<strong>查看这条边是否提供了从源点到那个顶点较之之前已知的最短路径的更短路径。</strong> 如果是这样，它会降低优先级来反映这种新的信息。</p><p>这里给出了Dijkstra算法计算从0到5的最短路径0-1-2-5的详细过程。</p><p>process 0 (0.0)</p><p>​    lower 3 to 3841.9</p><p>​    lower 1 to 1897.4</p><p>process 1 (1897.4)</p><p>​    lower 4 to 3776.2</p><p>​    lower 2 to 2537.7</p><p>process 2 (2537.7)</p><p>​    lower 5 to 6274.0</p><p>process 4 (3776.2)</p><p>process 3 (3841.9)</p><p>process 5 (6274.0)</p><p>该方法计算最短路径的长度。 为了记录路径，我们还<strong>保持每个顶点的源点到该顶点最短路径上的前驱</strong>。 文件Euclidean Graph.java，Point.java，IndexPQ.java，IntIterator.java和Dijkstra.java提供了针对map的Dijkstra算法的基本框架实现，你应该以此作为起点。 客户端程序ShortestPath.java求解一个单源点最短路径问题，并使用图形绘制了结果。 客户端程序Paths.java求解了许多最短路径问题，并将最短路径打印到标准输出。 客户端程序Distances.java求解了许多最短路径问题，仅将距离打印到标准输出。</p><h3 id="三、解决方法-2"><a href="#三、解决方法-2" class="headerlink" title="三、解决方法"></a>三、解决方法</h3><p><strong>目标。 优化Dijkstra算法，使其可以处理给定图的数千条最短路径查询。</strong> 一旦你读取图（并可选地预处理），你的程序应该在亚线性时间内解决最短路径问题。 一种方法是预先计算出所有顶点对的最短路径；然而，你无法承受存储所有这些信息所需的二次空间。 你的目标是减少每次最短路径计算所涉及的工作量，而不会占用过多的空间。 建议你选择下面的一些潜在想法来实现， 或者你可以开发和实现自己的想法。</p><p><strong>想法1</strong>. <strong>Dijkstra算法的朴素实现检查图中的所有V个顶点。</strong> 减少检查的顶点数量的一种策略是一旦发现目的地的最短路径就停止搜索。 通过这种方法，可以使每个最短路径查询的运行时间与<em>E</em>‘ log <em>V</em>‘成比例，其中<em>E</em>‘和<em>V</em>‘是Dijkstra算法检查的边和顶点数。 然而，这需要一些小心，因为只是重新初始化所有距离为∞就需要与<em>V</em>成正比的时间。由于你在不断执行查询，因而只需重新初始化在先前查询中改变的那些值来大大加速查询。</p><p><strong>想法*2</strong>. <strong>你可以利用问题的欧式几何来进一步减少搜索时间</strong>，这在算法书的第21.5节描述过。对于一般图，Dijkstra通过将d[w]更新为d[v] + 从v到w的距离来松弛边v-w。 对于地图，则将d[w]更新为d[v] + 从v到w的距离 + 从w到d的欧式距离 - 从v到d的欧式距离。 这种方法称之为A*算法。这种启发式方法会有性能上的影响，但不会影响正确性。</p><p><strong>想法3</strong>. <strong>使用更快的优先队列。</strong> 在提供的优先队列中有一些优化空间。 你也可以考虑使用Sedgewick程序20.10中的多路堆。</p><p><strong>测试</strong>。 美国大陆文件<a href="ftp://ftp.cs.princeton.edu/pub/cs226/map/usa.txt"><code>usa.txt</code></a>包含87,575个交叉口和121,961条道路。 图形非常稀疏 - 平均的度为2.8。 你的主要目标应该是快速回答这个网络上的顶点对的最短路径查询。 你的算法可能会有不同执行时间，这取决于两个顶点是否在附近或相距较远。 我们提供测试这两种情况的输入文件。 你可以假设所有的<em>x</em>和<em>y</em>坐标都是0到10,000之间的整数。</p><h3 id="四、算法及解释-2"><a href="#四、算法及解释-2" class="headerlink" title="四、算法及解释"></a>四、算法及解释</h3><p>IndexPQ基本参考使用了algs4所提供的 IndexPQ.java，这里不再进行过多的阐述。</p><p><strong>构造Dijkstra类，并在其中进行三个想法的优化。</strong></p><ol><li>Dijkstra算法无法支持负权值的边，所以需对边的权值进行判断，若&lt;0，抛出异常    </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Edge e : G.edges()) &#123;<br><span class="hljs-keyword">if</span> (e.weight() &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;edge &quot;</span> + e + <span class="hljs-string">&quot; has negative weight&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>初始化时将distTo[]数组全部设为无穷大（初始时最短路径都为∞）。并将源点的优先级设为 0.0</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; G.V(); v++) &#123;<br>distTo[v] = Double.POSITIVE_INFINITY;<span class="hljs-comment">//初始化为无穷大</span><br>&#125;<br>distTo[s] = <span class="hljs-number">0.0</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>不断取得pq中的点，并对其邻接边进行松弛。</li></ol><p><code>优化 1：</code><strong>一旦发现目的地的最短路径就停止搜索。</strong>当遍历pq时，一旦发现了汇点，立即停止搜索。就不需要将所有点到源点的最短路径都求出来，以此来进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br><span class="hljs-keyword">int</span> v = pq.delMin();<br><span class="hljs-comment">//优化1：一旦发现目的地的最短路径就停止搜索</span><br>    <span class="hljs-keyword">if</span> (v == d)<span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">for</span> (Edge e : G.adj(v)) &#123;<br>    relax(e, v, Nodes, d); <span class="hljs-comment">//对邻近点进行松弛</span><br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>边的松弛中，引入A*算法来进行优化</li></ol><p><code>优化 2:</code><strong>利用问题的欧式几何来进一步减少搜索时间</strong>；对于图来说，常将distTo[w] 更新为 distTo[v] +  v到w的距离。对于地图，将distTo看作s-&gt;v的最短距离+v-&gt;d的直接距离。相当于distTo不止考虑当前点到出发点的距离，也将考虑到目的地的距离。</p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/image-20211225205912415.png" alt="image-20211225205912415" style="zoom:67%;"><p><code>优化3：</code><strong>使用更快的优先队列。</strong>使用多路堆的方式来优化单路堆，使用教材源码IndexMultiwayMinPQ来代替初始化IndexPQ。没有进行单独实现，直接使用了algs4.jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> edu.princeton.cs.algs4.*;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dijkstra</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span>[] distTo;<span class="hljs-comment">//length of shortest path : s-&gt;v</span><br>    <span class="hljs-keyword">private</span> Edge[] edgeTo;<br><span class="hljs-comment">//    private IndexPQ pq;</span><br>    <span class="hljs-keyword">private</span> IndexMultiwayMinPQ&lt;Double&gt; pq;<span class="hljs-comment">//优化3：使用更快的优先队列</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(EdgeWeightedGraph G, <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> d, <span class="hljs-keyword">double</span>[][] Nodes)</span><span class="hljs-comment">//初始化</span></span><br><span class="hljs-function">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">relax</span><span class="hljs-params">(Edge e, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">double</span>[][] Nodes, <span class="hljs-keyword">int</span> d)</span><span class="hljs-comment">//松弛边</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathTo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> <span class="hljs-comment">//判断目标节点是否可达</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> Iterable&lt;Edge&gt; <span class="hljs-title">pathTo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span><span class="hljs-comment">//遍历边</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>构造MapRouting类</strong>，进行usa.txt的读取，读入点和边的信息，并进行结果的输出。</p><ol><li><p>不断用usa.txt中读入点和边的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读入点的坐标</span><br><span class="hljs-keyword">int</span> v;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pointCount; i++) &#123;<br>v = in.readInt();<br>Nodes[v][<span class="hljs-number">0</span>] = in.readDouble();<span class="hljs-comment">//x</span><br>Nodes[v][<span class="hljs-number">1</span>] = in.readDouble();<span class="hljs-comment">//y</span><br>&#125;<br><span class="hljs-comment">//读入边的信息       </span><br><span class="hljs-keyword">int</span> v1, v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edgeCount; i++) &#123;<br>v1 = in.readInt();<br>v2 = in.readInt();<br>G.addEdge(<span class="hljs-keyword">new</span> Edge(v1, v2, Distance(v1, v2)));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置distance函数来计算优化2中的欧式距离以及加边时存储的两点的距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Distance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;<br><span class="hljs-keyword">double</span> x1 = Nodes[v1][<span class="hljs-number">0</span>], y1 = Nodes[v1][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">double</span> x2 = Nodes[v2][<span class="hljs-number">0</span>], y2 = Nodes[v2][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> Math.sqrt(Math.pow((x1-x2), <span class="hljs-number">2</span>) + Math.pow((y1-y2), <span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>输出源点和汇点的距离</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> edu.princeton.cs.algs4.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapRouting</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> EdgeWeightedGraph G;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span>[][] Nodes;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getGraph</span><span class="hljs-params">(In in)</span><span class="hljs-comment">//读入usa.txt，初始化点和边</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Distance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span><span class="hljs-comment">//得到两点之间的距离</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-comment">//输出测试结果</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="五、实验结果-2"><a href="#五、实验结果-2" class="headerlink" title="五、实验结果"></a>五、实验结果</h3><p>未优化版本：</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/map1.png" alt="map1"></p><p>优化1：</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/map2.png" alt="map2"></p><p>优化2：</p><p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/map3.jpg" alt="map3"></p><p>优化3：</p><img src="/2021/12/25/2021/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/19DD17838CE46200EAA147CAA44A520D.png" alt="19DD17838CE46200EAA147CAA44A520D" style="zoom: 80%;"><h3 id="六、分析与总结-2"><a href="#六、分析与总结-2" class="headerlink" title="六、分析与总结"></a>六、分析与总结</h3><table><thead><tr><th>算法种类</th><th>初始算法</th><th>优化1</th><th>优化2</th><th>优化3</th></tr></thead><tbody><tr><td>时间</td><td>0.399s</td><td>0.332s</td><td>0.173s</td><td>0.24s</td></tr></tbody></table><blockquote><p> CPU: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz   1.80 GHz with 8GB RAM</p><p>OS: Windows 10 64位</p></blockquote><p>本次测试的数据为0-&gt;10000的最短路径。能从数据看出，进行优化1后，能明显感受到运行速度变快，因为其本质没有使用新的数据结构，通过减少计算次数来优化算法，所以时间减少明显。对于优化2来说，优化了一倍左右的时间，这是由于采用了Dijkstra算法的优化，A*算法，在松弛边时有着很大的提升。而对于优化3，在0-&gt;10000这个测试中没有完全发挥出其优势，由于距离不够长，所以导致其耗时比优化2略高一点，但理论来说，大规模地图数据应为优化3最佳，但0-&gt;10000的略低了一些，所以有了此结果。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码整洁之道 程序员的职业素养</title>
      <link href="/2021/09/04/2021/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%20%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB/"/>
      <url>/2021/09/04/2021/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%20%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="代码整洁之道-程序员的职业素养"><a href="#代码整洁之道-程序员的职业素养" class="headerlink" title="代码整洁之道 程序员的职业素养"></a>代码整洁之道 程序员的职业素养</h1><h2 id="第一章-专业主义"><a href="#第一章-专业主义" class="headerlink" title="第一章 专业主义"></a>第一章 专业主义</h2><p><strong>不要破坏功能</strong></p><ol><li>让QA找不出任何问题：不要故意发送明知有缺陷的代码</li><li>要确信代码正常运行：尽可能多地执行自动化测试</li><li>自动化QA</li></ol><p><strong>专业软件开发人员必须精通的事项</strong></p><ul><li><p><input disabled type="checkbox">  设计模式。必须能描述GOF<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）">[1]</span></a></sup>书中的全部24种模式，同时还要有POSA<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="《面向模式的软件架构》（Pattern-Oriented Software Architecture)">[2]</span></a></sup>书中的多数模式的实战经验</p></li><li><p><input disabled type="checkbox">  设计原则。必须了解SOLID原则<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="单一功能、开闭原则、里氏替换、接口隔离以及依赖反转">[3]</span></a></sup>，而且要深刻理解组件设计原则</p></li><li><p><input disabled type="checkbox">  方法。必须理解XP、Scrum、精益、看板、瀑布、结构化分析及结构化设计等</p></li><li><p><input disabled type="checkbox">  实践。必须掌握测试驱动开发、面向对象设计、结构化编程、持续集成和结对编程</p></li><li><p><input disabled type="checkbox">  工件。必须了解如何使用UML图、DFD图、结构图、petri网络图、状态迁移图表、流程图和决策表</p></li></ul><p><strong>坚持学习</strong></p><p><strong>练习</strong></p><p><strong>合作</strong></p><p><strong>辅导</strong></p><p><strong>了解业务领域</strong></p><p><strong>与雇主/客户保持一致</strong></p><p><strong>谦逊</strong></p><h2 id="第二章-说“不”"><a href="#第二章-说“不”" class="headerlink" title="第二章 说“不”"></a>第二章 说“不”</h2><p>许诺“尝试”，就意味着你承认之前未尽全力，承认自己还有余力可施。许诺“尝试”，意味着只要你再加把劲还是可以达到目标的；而且，这也是一种表示你将再接再厉去实现目标的承诺。</p><p>如果你既没有新方案，又不准备改变自己的行为，如果事事仍然都按你承诺“尝试”之前的方法去做，那么所谓的“尝试”指的又是什么呢？从本质上讲，承诺“尝试”就是一种不诚实的表现.</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《<strong>设计模式：可复用面向对象软件的基础</strong>》（Design Patterns: Elements of Reusable Object-Oriented Software）<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>《<strong>面向模式的软件架构</strong>》（Pattern-Oriented Software Architecture)<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><strong>单一功能、开闭原则、里氏替换、接口隔离</strong>以及<strong>依赖反转</strong><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环</title>
      <link href="/2020/10/04/2020/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
      <url>/2020/10/04/2020/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>约瑟夫环 </p><h3 id="时间限制"><a href="#时间限制" class="headerlink" title="时间限制"></a>时间限制</h3><p>2 S </p><h3 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h3><p>10000 Kb </p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>习题集P79。编号为1,2,…,n的n个人按顺时针方向围坐一圈，每人持有一个密码（正整数）。现在给定一个随机数m&gt;0，从编号为1的人开始，按顺时针方向1开始顺序报数，报到m时停止。报m的人出圈，同时留下他的密码作为新的m值，从他在顺时针方向上的下一个人开始，重新从1开始报数，如此下去，直至所有的人全部出圈为止。 </p><h3 id="问题输入"><a href="#问题输入" class="headerlink" title="问题输入"></a>问题输入</h3><p>输入数据第一行为两个正整数n和m，分别表示人的个数及初始随机数，每组数据的第二行为n个整数，表示每个人持有的密码。 </p><h3 id="问题输出"><a href="#问题输出" class="headerlink" title="问题输出"></a>问题输出</h3><p>用一行输出n个整数表示依次出圈人的编号，整数之间用空格分隔 </p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>7 20</p><p>3 1 7 2 4 8 4</p><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>6 1 4 7 2 3 5 </p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>使用不带头节点的循环链表 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1.构造线性表 </span><br><span class="hljs-comment">// 2.录入密码</span><br><span class="hljs-comment">// 3.约瑟夫环</span><br><span class="hljs-comment">// 4.打印线性表 </span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> ElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>ElemType data;<br>ElemType sequence;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LNode,*LinkList; <span class="hljs-comment">//创建单链表存储结构</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateList</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-keyword">int</span> n)</span></span>;   <span class="hljs-comment">//创建并输入数据 </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Josephus</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span></span>;<span class="hljs-comment">//约瑟夫环的实现+打印出圈人 </span><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br><br>LinkList L;<br>CreateList(L, n);<br>Josephus(L, n, m);<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateList</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> n)</span></span>&#123; <br><br><span class="hljs-comment">//输入第一个密码 </span><br>LinkList head = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>head-&gt;sequence = <span class="hljs-number">1</span>;<br>head-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;head-&gt;data);<br>L = head;<br><br>LinkList p = head;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>LinkList s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>s-&gt;sequence = i;<br>s-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;s-&gt;data);<br><br>p-&gt;next = s;<br>p = s;<br>&#125;<br>p-&gt;next = L;<br><br>&#125;<span class="hljs-comment">//创建并输入数据 </span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Josephus</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span></span>&#123;<br><br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;<br>LinkList p = L, q = L;<br><br><span class="hljs-keyword">while</span>(p-&gt;next!=p)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>q = p;<br>p = p-&gt;next;<br>&#125;<span class="hljs-comment">//i == m; </span><br>m = p-&gt;data;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,p-&gt;sequence);<span class="hljs-comment">//输出出圈人的编号</span><br><br>q-&gt;next = p-&gt;next;<br><span class="hljs-built_in">free</span>(p);<br>p = q-&gt;next; <span class="hljs-comment">//删除出圈人 </span><br>&#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p-&gt;sequence);<span class="hljs-comment">//输出最后一个出圈人的编号</span><br><span class="hljs-built_in">free</span>(p);<br><br>&#125;<span class="hljs-comment">//约瑟夫环的实现+打印出圈人 </span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构XDOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XDOJ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一元稀疏多项式计算器</title>
      <link href="/2020/10/04/2020/%E4%B8%80%E5%85%83%E7%A8%80%E7%96%8F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2020/10/04/2020/%E4%B8%80%E5%85%83%E7%A8%80%E7%96%8F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>一元稀疏多项式计算器</p><h3 id="时间限制"><a href="#时间限制" class="headerlink" title="时间限制"></a>时间限制</h3><p>2S </p><h3 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h3><p>10000 Kb </p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>见习题集P81 </p><h3 id="问题输入"><a href="#问题输入" class="headerlink" title="问题输入"></a>问题输入</h3><p>每组数据有3行构成，第1行为3个正整数n，m，t， n表示第一个多项式的项数，m表示第二个多项式的项数，t表示运算类型，0为加法，1为减法，每组数据的第2行包含2n个整数，每两个整数分别表示第一个多项式每一项的系数和指数；第3行包含2m个整数，每两个整数分别表示第二个多项式每一项的系数和指数。 </p><h3 id="问题输出"><a href="#问题输出" class="headerlink" title="问题输出"></a>问题输出</h3><p>在一行上以多项式形式输出结果，指数按从低到高的顺序 </p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>6 3 0</p><p>1 0 1 1 -3 2 1 3 1 4 1 5</p><p>-1 3 -2 4 1 5 </p><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>1+x-3x^2-x^4+2x^5</p><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>1.初始化链表，创建多项式线性表 polynomial-&gt;coefficient, polynomial-&gt;index存储<br>2.switch case/if else完成加减法选择<br>3.比较系数大小，指数大小将<br>4.L1,L2插入到L3里 #注意加减法<br>5.打印一元稀疏多项式</p><h4 id="输出注意事项"><a href="#输出注意事项" class="headerlink" title="输出注意事项"></a>输出注意事项</h4><p>输出结果时，写一个flag和cnt分别记录是否输出与是否为第一次输出</p><p>1.指数为0，直接打印系数，cnt++</p><p>2.系数为0，continue</p><p>3.系数为1时，指数不同的输出</p><p>4.指数为1时，系数不同的输出</p><p>5.最普通的情况，系数为负直接输出，系数为正带‘+’输出</p><p>6.当多项式相加减的结果为0时，输出为0**#用例942**</p><p><img src="/images/QQ%E6%88%AA%E5%9B%BE20201004095005.png"></p><p>代码最后Print函数写的比较繁琐…有基本思路就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br><span class="hljs-keyword">int</span> coef;<br><span class="hljs-keyword">int</span> index;<br>&#125;Term;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">polynomial</span>&#123;</span><br>Term term;<br>polynomial* next;<br>&#125;polynomial,*LinkList;<span class="hljs-comment">//创建单链表存储结构</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span>;    <span class="hljs-comment">//初始化链表</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Term a,Term b)</span></span>;            <span class="hljs-comment">//比较系数大小 </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertNode</span><span class="hljs-params">(LinkList &amp;L,Term e)</span></span>;    <span class="hljs-comment">//L1,L2插入到L3里</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreatePolyn</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> m)</span></span>;   <span class="hljs-comment">//创建m项系数的一元多项式</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddPolyn</span><span class="hljs-params">(LinkList &amp;L,LinkList L1,LinkList L2)</span></span>;   <span class="hljs-comment">//L1+L2 </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SubtractPolyn</span><span class="hljs-params">(LinkList &amp;L,LinkList L1,LinkList L2)</span></span>; <span class="hljs-comment">//L1-L2</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintPolyn</span><span class="hljs-params">(LinkList L)</span></span>; <span class="hljs-comment">//Print List</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-keyword">int</span> n,m,t;<br>LinkList L1,L2;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;t);<br><br>CreatePolyn(L1,n);<br>CreatePolyn(L2,m);<br><br>LinkList add,sub;<br><span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>)&#123;<br>InitList(add);<br>AddPolyn(add,L1,L2);<br>PrintPolyn(add);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>InitList(sub);<br>SubtractPolyn(sub,L1,L2);<br>PrintPolyn(sub);<br>&#125;<br><br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br><br><span class="hljs-comment">//创建头结点 </span><br>L = (polynomial*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(polynomial));<br>L-&gt;term.coef = <span class="hljs-number">0</span>;<br>L-&gt;term.index = <span class="hljs-number">-1</span>;<br>L-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>&#125;<span class="hljs-comment">//初始化链表</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Term a,Term b)</span></span>&#123;<br><br><span class="hljs-comment">//compare</span><br><span class="hljs-keyword">if</span>(a.index&gt;b.index)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.index==b.index)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br>&#125;<span class="hljs-comment">//比较系数大小</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertNode</span><span class="hljs-params">(LinkList &amp;L,Term e)</span></span>&#123;<br><br>polynomial* q = L;<br><span class="hljs-keyword">while</span>(q-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">if</span>(cmp(q-&gt;next-&gt;term,e)==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//q的下一个指数&gt;要插入的指数 </span><br>q = q-&gt;next;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<span class="hljs-comment">//找到要插入的前一位 </span><br><br><span class="hljs-keyword">if</span>(q-&gt;next!=<span class="hljs-literal">NULL</span> &amp;&amp; cmp(q-&gt;next-&gt;term,e)==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//指数相同 </span><br>q-&gt;next-&gt;term.coef += e.coef;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>polynomial* node = (polynomial*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(polynomial));<br>node-&gt;term.coef = e.coef;<br>node-&gt;term.index = e.index;<br><span class="hljs-keyword">if</span>(q-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>node-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//若为尾结点，node最后加为NULL </span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>node-&gt;next = q-&gt;next;<br>&#125; <br>q-&gt;next = node;<br>&#125;<br><br>&#125;<span class="hljs-comment">//L1,L2插入到L3里</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreatePolyn</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> m)</span></span>&#123;<br><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>Term e;<br>InitList(L);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;e.coef,&amp;e.index);<br>InsertNode(L,e);<br>&#125;<br><br>&#125;<span class="hljs-comment">//创建m项系数的一元多项式</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddPolyn</span><span class="hljs-params">(LinkList &amp;L,LinkList L1,LinkList L2)</span></span>&#123;<br><br>polynomial* q;<br><span class="hljs-keyword">for</span>(q=L1-&gt;next;q!=<span class="hljs-literal">NULL</span>;q=q-&gt;next)&#123;<br>InsertNode(L,q-&gt;term);<br>&#125;<span class="hljs-comment">//L += L1 </span><br><span class="hljs-keyword">for</span>(q=L2-&gt;next;q!=<span class="hljs-literal">NULL</span>;q=q-&gt;next)&#123;<br>InsertNode(L,q-&gt;term);<br>&#125;<span class="hljs-comment">//L +=L2</span><br> <br>&#125;<span class="hljs-comment">//L1+L2</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SubtractPolyn</span><span class="hljs-params">(LinkList &amp;L,LinkList L1,LinkList L2)</span></span>&#123;<br><br>polynomial* q;<br><span class="hljs-keyword">for</span>(q=L1-&gt;next;q!=<span class="hljs-literal">NULL</span>;q=q-&gt;next)&#123;<br>InsertNode(L,q-&gt;term);<br>&#125;<span class="hljs-comment">//L += L1</span><br><span class="hljs-keyword">for</span>(q=L2-&gt;next;q!=<span class="hljs-literal">NULL</span>;q=q-&gt;next)&#123;<br>q-&gt;term.coef = - (q-&gt;term.coef);<br>InsertNode(L,q-&gt;term);<br>&#125;<span class="hljs-comment">//L += -L2</span><br><br>&#125;<span class="hljs-comment">//L1-L2</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintPolyn</span><span class="hljs-params">(LinkList L)</span></span>&#123;<br><br><span class="hljs-comment">//指数或系数为1时，省略1 </span><br>polynomial* q = L;<br><span class="hljs-keyword">int</span> flag;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(q-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>q = q-&gt;next;<br>flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(q-&gt;term.coef==<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//coef==0,pass</span><br><br><span class="hljs-keyword">if</span>(q-&gt;term.index==<span class="hljs-number">0</span>&amp;&amp;flag==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,q-&gt;term.coef);<br>cnt++;<br>flag = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//index==0,cnt++</span><br><br><span class="hljs-keyword">if</span>((q-&gt;term.coef==<span class="hljs-number">1</span>||q-&gt;term.coef==<span class="hljs-number">-1</span>)&amp;&amp;flag==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(q-&gt;term.index==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(q-&gt;term.coef==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x&quot;</span>);<br>cnt++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+x&quot;</span>);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-x&quot;</span>);<br>cnt++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-x&quot;</span>);<br>&#125;<br><br>&#125; <br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(q-&gt;term.coef==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x^%d&quot;</span>,q-&gt;term.index);<br>cnt++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+x^%d&quot;</span>,q-&gt;term.index);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-x^%d&quot;</span>,q-&gt;term.index);<br>cnt++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-x^%d&quot;</span>,q-&gt;term.index);<br>&#125;<br>&#125;<br>&#125;<br>flag = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//coef==1/-1</span><br><br><span class="hljs-keyword">if</span>(q-&gt;term.index==<span class="hljs-number">1</span>&amp;&amp;flag==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(q-&gt;term.coef&gt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%dx&quot;</span>,q-&gt;term.coef);<br>cnt++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+%dx&quot;</span>,q-&gt;term.coef);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%dx&quot;</span>,q-&gt;term.coef);<br>cnt++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%dx&quot;</span>,q-&gt;term.coef);<br>&#125;<br>&#125;<br>flag = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//index==1</span><br><br><span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>||q-&gt;term.coef&lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>&amp;&amp;q-&gt;term.coef&lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%dx^%d&quot;</span>,q-&gt;term.coef,q-&gt;term.index);<br>cnt++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%dx^%d&quot;</span>,q-&gt;term.coef,q-&gt;term.index);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+%dx^%d&quot;</span>,q-&gt;term.coef,q-&gt;term.index);<br>&#125;<br>&#125;<span class="hljs-comment">//common</span><br>&#125;<br><br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>&#125;<br><br>&#125;<span class="hljs-comment">//Print List</span><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构XDOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XDOJ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笃行使命，向阳而生</title>
      <link href="/2020/09/13/2020/%E7%AC%83%E8%A1%8C%E4%BD%BF%E5%91%BD%EF%BC%8C%E5%90%91%E9%98%B3%E8%80%8C%E7%94%9F/"/>
      <url>/2020/09/13/2020/%E7%AC%83%E8%A1%8C%E4%BD%BF%E5%91%BD%EF%BC%8C%E5%90%91%E9%98%B3%E8%80%8C%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="新时代大学生应当怎样弘扬和践行爱国主义精神"><a href="#新时代大学生应当怎样弘扬和践行爱国主义精神" class="headerlink" title="新时代大学生应当怎样弘扬和践行爱国主义精神"></a>新时代大学生应当怎样弘扬和践行爱国主义精神</h4><ol><li>大变局中的中国与世界</li><li>正确认识中国经济发展</li><li>激扬新时代爱国主义的磅礴力量</li><li>确保如期打赢脱贫攻坚战</li></ol><p><strong>笃行使命，向阳而生</strong></p><p>2020年，我国即将实现全面小康，如今，已经进入了脱贫攻坚的最后的关键时期，全国上下都在咬紧牙关，丝毫不放松，进行最后攻坚战的冲刺。</p><p>自1971年中国恢复联合国席位，中国国际地位不断上升，1972年尼克松访华消融中美两国的冰雪，并于1979年正式与中国建交，20世纪末的苏联解体更是导致世界由两极格局变为一超多强。中国随着世界进程，不断进步，不断学习。现在的中国，已经是世界大国，已经是经济、国防、科技都不可小觑的超级大国，回想七十年间的峥嵘岁月，皆是前辈们打下的艰苦基石。</p><p>中国的不断崛起，我们中华民族的不断进步，大大提升了我们的民族自豪感，曾经作为青年的前辈们为了中国，挥洒汗水，拴紧裤腰带为中国打开一片天。如今作为新时代的大学生，我们也即将是未来各个工作岗位上的一员，有些可能也将是改变全球命运的研究人员。无论在哪，我们都是国家未来的新鲜血液，是要撑起未来十年乃至以后一片天的新时代大学生。“少年强则国强，少年进步则国进步。”我们是新时代青年，若要说，如何弘扬和践行爱国主义精神，那必是好好学习，不虚度光阴，用知识充实自己，用能力为自己打下一片天。只要我们始终坚定爱国主义精神，不违法犯法，积极向上对待生活，不收到左派等不良分子的影响，坚持为国家为社会做贡献，这就是我们作为新时代大学生，对爱国主义精神最好的弘扬与践行。</p><p>另一方面，我们作为大学生，在思想和知识上需引领一部分人，并且重视爱国主义教育及国防安全教育，也定当追随国家及党的脚步，并向周围的人宣传、普及国防教育，参与报告会、讲座等宣传教育，提高自己及国民的综合素质。</p><p>受新型冠状病毒影响，全球无论是经济还是国家其本身，都遭到了巨大的影响。1月下旬，或许还处于焦虑的状态，但到4月，我们已经完成了复工复产，部分学校开始上课，全国人民也对患病人数全面清零有着巨大信心。随着生活不断恢复正常，回看这黑暗却充满温馨的几个月，国家真是尽最大努力去挽救每一个中国国民，且全国人民团结一致抗击疫情。就同张迈曾先生所说“于奋战中矗中流砥柱，于组织中显精湛技能，于细微中见爱意纤毫，于凯旋中颂华歌豪情。”这是我们的胜利，也是我们早就知道结局的胜利。</p><p>这次抗击疫情，虽说我们作为学生，大多数人都不能作为抗疫一线的先锋军，但我们以我们自己的方式，保卫着这个国家。有能力的同学协助居委会等一家一户查看体温，不方便的同学便在家做好隔离，不随便外出给国家添麻烦。就算在家长达一月有余，我们仍听从国家号令，该稍稍放松时便放松些许，不宜出门时便好好呆在家里做好自己的本职工作。好好学习，把自己培养成为一个有用的人，为了将来给社会做出更多的贡献，不断丰富自我，完善能力。虽然现在可能还有些微不足道，但这就是我作为一个中国公民，作为新时代大学生，响应国家号召，所最应该做的，这就是我所尽力的爱国方式。</p><p>作为新时代的大学生，定当用自己所学所得，回报祖国，回报社会。做改革先锋，做有理想，有担当，有追求的新青年。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近代史课后思考题</title>
      <link href="/2020/08/19/2020/%E8%BF%91%E4%BB%A3%E5%8F%B2%E8%AF%BE%E5%90%8E%E6%80%9D%E8%80%83%E9%A2%98/"/>
      <url>/2020/08/19/2020/%E8%BF%91%E4%BB%A3%E5%8F%B2%E8%AF%BE%E5%90%8E%E6%80%9D%E8%80%83%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="ONE-1-3"><a href="#ONE-1-3" class="headerlink" title="ONE  1-3"></a>ONE  1-3</h2><h3 id="1-资本帝国主义的侵略给中国带来了什么？"><a href="#1-资本帝国主义的侵略给中国带来了什么？" class="headerlink" title="1.资本帝国主义的侵略给中国带来了什么？"></a><strong>1.资本帝国主义的侵略给中国带来了什么？</strong></h3><p><strong>政治</strong>：破坏了中国主权和领土完整，使中国沦为半殖民地半封建社会；推动了中国政治民主化的进程<br>经济：迫使中国自然经济的解体，推动资本主义在中国的发展，推动了中国工业化的进程；使中国沦为列强的原料产地和商品销售市场，成为经济附庸，被迫卷入资本主义世界市场<br><strong>思想文化</strong>：推动中国思想文化科学化、理性化的进程。</p><h3 id="2-近代中国进行的反侵略战争具有什么意义"><a href="#2-近代中国进行的反侵略战争具有什么意义" class="headerlink" title="2.近代中国进行的反侵略战争具有什么意义"></a>2.近代中国进行的反侵略战争具有什么意义</h3><p>第一，近代中国人民进行的反侵略战争，沉重打击了帝国主义侵华的野心，粉碎了他们瓜分中国和把中国变成完全殖民地的图谋。<br>帝国主义列强一次次对中国发动侵略战争，绝不仅仅是为了通商，而是为了掠夺和扩大殖民地，为了他们自身的殖民扩张利益。每一次战争，都伴随着更大的贪梦目的和更多的利益要求。但每一次侵略都遇到了中国人民的反抗，使他们的狂妄野心无法得逞。正是中国人民的英勇斗争，表现了中国人民不屈不挠的爱国主义精神，也给外国侵略者以沉重打击和深刻教训，使他们越来越清楚地认识到，中国是一个很难征服的国家。他们虽然可以强迫清政府签订一个又一个不平等条约，但是始终无法把中国变成他们的完全的殖民地。尤其是甲午战争以后，在瓜分危机的严重关头，中国各阶层人民救亡图存的努力探索和奋起抗争，使侵略者看到了中国人民中所隐含的不甘屈服的伟大力量，不得不放弃了瓜分中国的政策。<br>第二，近代中国人民进行的反侵略战争，教育了中国人民，振奋了中华民族的民族精神，鼓舞了人民反帝反封建的斗志，大大提高了中国人民的民族觉醒意识。<br>帝国主义的侵略给中华民族带来了巨大灾难，但没有哪一次巨大的历史灾难不是以历史的进步作为补偿的。列强发动的侵华战争以及中国人民反侵略战争的失败，从反面教育了中国人民，极大地促进了中国人民的思考、探索和奋起直追。<br>鸦片战争以后，先进的中国人开始痛定思痛，注意了解国际形势，研究外国历史地理，总结失败教训，寻找救国的道路和御敌的方法，于是有了师夷长技以制夷思想的提出。<br>甲午战争以后，中华民族面临生死存亡之际，帝国主义的瓜分狂潮和民族危机的刺激，全民族开始有了普遍的民族意识的觉醒，救亡图存的思想日益高涨。<br>正是这种亡国灭种的危机感，增强了中华民族整体民族利益休戚与共的民族认同感和凝聚力，成为中华民族自立自强并永远立于世界民族之林的根本所在。</p><h3 id="3-近代中国反侵略战争失败的根本原因和教训是什么"><a href="#3-近代中国反侵略战争失败的根本原因和教训是什么" class="headerlink" title="3.近代中国反侵略战争失败的根本原因和教训是什么"></a>3.近代中国反侵略战争失败的根本原因和教训是什么</h3><p>第一，近代中国社会制度的腐败是反侵略战争失败的根本原因。<br>在1840年以后中国逐渐沦为半殖民地半封建社会的过程中，清王朝统治者从皇帝到权贵，大都昏庸愚昧，不了解世界大势，不懂得御敌之策。由于政治腐败、经济落后和文化保守，一方面使清朝统治阶级封闭自守，妄自尊大，骄奢淫逸，盲目进攻；另一方面又使统治者和清军指挥人员在战争面前完全没有应变的能力和心态，不适应于近代战争，不少将帅贪生怕死，临阵脱逃，有的甚至出卖国家和民族的利益。清政府尤其害怕人民群众，担心人民群众动员起来会危及自身统治，所以不敢发动和依靠人民群众的力量。清朝统治集团在对外战争中妥协退让求和投降的一系列做法，已经使他失去在中国存在的理由，不推翻他是不能取得反侵略战争胜利的。<br>第二，近代中国经济技术的落后是反侵略战争失败的另一个重要原因。<br>当时的英国已经历过工业革命，资本主义生产力获得突飞猛进的发展，而中国仍停留在封建的自然经济水平上。经济技术的落后直接造成军事装备的落后，军队指挥员不了解近代军事战术，从而造成军队素质和战斗力的低下。经济技术落后是反侵略战争失败的重要原因，但并不表明经济技术落后就一定在反侵略战争中失败。正是因为当时的中国政府不能很好地组织反侵略战争，不能发动和利用人民群众的力量，甚至压制人民群众，其失败是不可避免的。<br>（3）中国近代历次反侵略战争失败的教训：中国人民必须把反对帝国主义的民族斗争和反对封建主义的阶级斗争统一起来，才能完成近代中国革命的任务。</p><h2 id="TWO-4-6"><a href="#TWO-4-6" class="headerlink" title="TWO    4-6"></a>TWO    4-6</h2><h3 id="1-如何认识太平天国农民战争的意义和失败的原因、教训？"><a href="#1-如何认识太平天国农民战争的意义和失败的原因、教训？" class="headerlink" title="1.如何认识太平天国农民战争的意义和失败的原因、教训？"></a>1.如何认识太平天国农民战争的意义和失败的原因、教训？</h3><p><strong>（1）太平天国农民战争的意义</strong></p><p>第一，沉重打击了封建统治阶级，强烈震撼了清政府的统治根基，加速了清王朝的衰败过程。</p><p>第二，是旧式农民战争的最高峰，具有不同以往农民战争的新的历史特点。</p><p>第三，冲击了空子和儒家经典的正统权威，在一定程度上削弱了封建统治的精神支柱。</p><p>第四，有力的打击了外国侵略势力，给了侵略者应有的教训。</p><p>第五，在19世纪中叶的亚洲民族解放运动中，起到推动作用。</p><p><strong>（2）太平天国农民战争失败的原因</strong></p><p>A、从主观上看：</p><p>第一，农民阶级不是新的是生产力和生产关系的代表。</p><p>第二，没有科学的思想理论，它不仅不能正确指导战争，而且给农民战争带来了危害。</p><p>第三，太平天国也没能正确对待儒学。</p><p>第四，不能把西方国家的侵略者与人民群众区别开来，对西方侵略者还缺乏理性的认识。</p><p>B、从客观上看：</p><p>中外反动势力勾结起来，联合镇压太平天国。</p><p>太平天国农民战争失败的教训：</p><p>太平天国起义及其失败表明，在半殖民地半封建的中国，农民具有伟大的革命潜力。但它自身不能担负起反帝反封建取得胜利的重任，单纯的农民战争不可能完成争取民族独立和人民解放的历史重任。</p><h3 id="2-如何认识洋务运动的性质，作用和失败的原因，教训"><a href="#2-如何认识洋务运动的性质，作用和失败的原因，教训" class="headerlink" title="2.如何认识洋务运动的性质，作用和失败的原因，教训"></a>2.如何认识洋务运动的性质，作用和失败的原因，教训</h3><p><strong>1.洋务运动的性质</strong><br>洋务运动是清朝封建统治阶级中的洋务派为了维护清朝的封建统治而实行的一场自救改革运动，即具有进步性，也具有落后保守性。<br><strong>2.洋务运动的历史作用</strong><br>第一，洋务运动的洋务派继承了魏源师夷长技以制夷的思想，提出“自强”“求富”的主张，通过所掌握的国家权力集中力量优先发展军事工业，同时发展若干民用企业，在客观上对中国的早期工业和民族资本主义的发展起了某些促进作用。<br>第二，开办了一批新式学堂，派出了最早的官派留学生，翻译了一批西学书籍，给当时的中国带来了新的知识，使人们打开了眼界。<br>第三，传统的“重本抑末”“重义轻利”等观念都受到冲击，社会风气和价值观念开始变化，工商业者地位上升。有利于资本主义经济的发展，也有利于社会风气的改变。<br><strong>3.洋务运动的失败的原因</strong><br>第一，洋务运动具有封建性。洋务运动的指导思想是“中学为体”“西学为用”，洋务派企图在不改变中国固有的制度与道德的前提下，以吸取西方近代生产技术为手段，来达到维护和巩固中国封建统治的目的，这就严重限制了洋务运动的发展。<br>第二，洋务运动对外国具有依赖性。西方列强依据种种特权，从政治经济等各方面加紧对中国的侵略控制，他们并不希望中国真正富强起来，而洋务派处处依赖外国，企图以此来达到自强求富的目的，无异与虎谋皮。<br>第三，洋务企业的管理具有腐朽性。洋务企业虽然具有一定的资本主义性质，但其管理确是封建式的，企业内部充斥着营私舞弊、贪污中饱、挥霍浪费等腐败现象。<br><strong>4.洋务运动失败的教训</strong><br>地主阶级不能担负起中国近代化的历史重任。<br>失败原因 ：<br>洋务运动在当时的中国，其失败命运是不可避免的。第一，在不触动腐朽的封建制度的前提下，洋务派试图利用西方资本主义的某些长处来维护封建专制统治，这种手段和基础的矛盾，使洋务运动注定是不可能成功的。同时，洋务运动处处受到顽固派的阻挠和破坏，从而加大了洋务运动开展的阻力。第二，洋务派本身的阶级局限性，决定了他们既是近代工业的创办者和经营者，也是其摧残者和破坏者，其封建衙门和官僚式的体制，必定导致洋务企业的失败。第三，洋务运动的目的之一是抵御外侮，但洋务派在主持外交活动中，坚持“外须和戎”，对外妥协投降，他们所创办的近代企业有抵御外侮和“稍分洋人之利”作用，但却不能改变中国半殖民地半封建社会地位。甲午战争，洋务派标榜的“求强”“求富”目标未能实现，洋务运动基本失败。<br>洋务派提倡「中学为体，西学为用」，希望利用先进的技术维护封建统治，改革不触动封建制度。<br>教训：在当时的社会背景下 仅学习西方先进技术是远远不够的 必须改革政治制度 摆脱半殖半封的社会性质<br>受阶级和时代的局限性 封建地主阶级不能领导中国走向富强</p><h3 id="3-如何认识戊戌维新运动的意义和失败的原因、教训"><a href="#3-如何认识戊戌维新运动的意义和失败的原因、教训" class="headerlink" title="3.如何认识戊戌维新运动的意义和失败的原因、教训"></a>3.如何认识戊戌维新运动的意义和失败的原因、教训</h3><p>①戊戌变法，是一次资产阶级改良运动，是资产阶级变革社会制度的初步尝试。维新派试图在政治上建立资产阶级君主立宪制。在经济上发展民族资本主义，符合历史发展趋势。②它是一次爱国救亡的政治运动。在民族危机加剧的时刻维新派希望通过变法使中国走向强大，从而摆脱帝国主义列强的侵略，表现出强烈的爱国热情，激发人民爱国思想和民族意识。③戊戌变法也是近代中国一次思想潮流的解放。资产阶级接维新派提倡新学，主张兴民权，对封建思想进行了猛烈的抨击，在这会上起了思想启蒙作用，促进了中国人民的觉醒。<br>失败原因和教训<br>资产阶级维新派采取改良的方法，。把希望寄托在没有实权的皇帝身上。在顽固势力的进攻面前。他们又寄希望于袁世凯和外国侵略者。脱离了广大人民群众。因此很快失败<br>教训<br>资产阶级改良道路在半殖民地半封建身会的中国行不通</p><h2 id="THREE-7-9"><a href="#THREE-7-9" class="headerlink" title="THREE  7-9"></a>THREE  7-9</h2><h3 id="1-革命派在与改良派论战中是如何论述革命的必要性、正义性、进步性的？"><a href="#1-革命派在与改良派论战中是如何论述革命的必要性、正义性、进步性的？" class="headerlink" title="1.革命派在与改良派论战中是如何论述革命的必要性、正义性、进步性的？"></a>1.革命派在与改良派论战中是如何论述革命的必要性、正义性、进步性的？</h3><p>必要性：资产阶级革命派指出，清政府是帝国主义的“鹰犬”，因此爱国必须革命，只有通过革命，才能免“瓜分之祸”，获得民族独立和社会进步。人们在革命过程中所付出的努力乃至作出的牺牲，是以换取历史的进步作为补偿的。<br>正义性:对于改良派所提出的“中国国民恶劣”说，革命派针锋相对地指出，不是“国民恶劣”，而是“政府恶劣”，民主共和是大势所趋，人心所向，拯救中国与建设中国都必须取法乎上，直接推行民主制度。只有“兴民权改民主”才是中国的唯一出路。<br>进步性：革命派强调，当时的中国存在着严重的“地主强权”和“地权失平”的现象，只有通过通过平均地权一实现土地国有，在进行政治革命的同时实现社会革命，才能避免贫富不均等一系列问题的出现。</p><h3 id="2-为什么说孙中山领导的辛亥革命引起了近代中国的历史性变化"><a href="#2-为什么说孙中山领导的辛亥革命引起了近代中国的历史性变化" class="headerlink" title="2.为什么说孙中山领导的辛亥革命引起了近代中国的历史性变化"></a>2.为什么说孙中山领导的辛亥革命引起了近代中国的历史性变化</h3><p>1、辛亥革命推翻封建势力和清朝统治，沉重打击帝国主义的侵略势力，为中国人民斗争的发展开辟了道路。</p><p>2、辛亥革命结束封建君主专制制度，建立资产阶级共和政府，使民主共和观念深人人心。正因为如此，当袁世凯、张勋先后复辟帝制时，均受到了社会舆论的强烈谴责和人民群众的坚决反抗。</p><p>3、辛亥革命推动人民的思想解放。激发了人民的爱国热情和民族觉醒，打开了禁调思想进步的闸门。</p><p>4、辛亥革命推动了中国的社会变革，为民族资本主义经济的发展创造条件。</p><p>5、辛乡革命推动了亚洲各国民族解放运动的高涨。</p><h3 id="3-辛亥革命为什么会失败-他的失败说明了什么"><a href="#3-辛亥革命为什么会失败-他的失败说明了什么" class="headerlink" title="3.辛亥革命为什么会失败?他的失败说明了什么?"></a>3.辛亥革命为什么会失败?他的失败说明了什么?</h3><p>因为资产阶级的软弱性和妥协性导致辛亥革命失败的根本原因。<br>　　没有自己的武装来阻止袁世凯篡夺革命的领导权， 没有改变中国半殖民地半封建的国家性质。<br>　　①资产阶级革命派始终没有一个彻底的反帝纲领。三民主义没有提出反对中华民族的主要敌人帝国主义。南京临时政府成立后还幻想得到帝国主义的支持。没有认清真正的敌人，是资产阶级革命派终归失败的原因之一。<br>　　②资产阶级革命派始终没有一个彻底的反封建纲领。三民主义没有彻底否定封建土地所有制，资产阶级革命没有解决农民的土地问题，因此得不到农民的支持。农民是中国革命的主要力量，没有农民的支持就无法战胜强大的敌人。<br>　　③资产阶级革命派始终没有建立起自己的武装力量。在辛亥革命中，资产阶级革命派发动的武装斗争都是短期的。“二次革命”中国民党人虽然掌握了一些军队，但并不是统一的革命力量，护法运动则依靠军阀的力量，因此每当遇到强大的反革命武装就不能不失败。<br>　　④资产阶级革命派的政党也是松散的。同盟会建立后缺乏严密的组织和纪律，武昌起义爆发前实际上已名存实亡，没有一个坚强的革命政党，就不能使革命者紧密地团结起来形成坚强的战斗力。袁世凯能够窃取辛亥革命果实，也与同盟会的涣散、领导成员政见不一有关。</p><h2 id="FOUR-10-12"><a href="#FOUR-10-12" class="headerlink" title="FOUR  10-12"></a>FOUR  10-12</h2><h3 id="1-中国的先进分子为什么和怎样选择的马克思主义"><a href="#1-中国的先进分子为什么和怎样选择的马克思主义" class="headerlink" title="1.中国的先进分子为什么和怎样选择的马克思主义"></a>1.中国的先进分子为什么和怎样选择的马克思主义</h3><p>1.农民阶级的局限性(太平天国) ,资产阶级的软弱性和妥协性(辛亥革命)使他们在中国的政治制度的探索失败,说明他们都不能完成反封反帝的认务<br>2.五四运动后无产阶级登上历史舞台,随着俄国十月革命后马克思主义传播到中国,先进知识分子认识到,马克思主义更适合中国国情<br>3.帝国主义国家对中国的掠夺和社会主义俄国对中国的援助形成了鲜明对比</p><h3 id="2-为什么说中国共产党的成立是“开天辟地”的大事变"><a href="#2-为什么说中国共产党的成立是“开天辟地”的大事变" class="headerlink" title="2.为什么说中国共产党的成立是“开天辟地”的大事变?"></a>2.为什么说中国共产党的成立是“开天辟地”的大事变?</h3><p>　之所以说中国共产党的成立是开天辟地的大事变，是因为中国共产党的诞生使中国革命的面貌从此焕然一新。<br>　　1.中国共产党的成立使中国革命有了坚强的领导核心，灾难深重的中国人民有了可以依赖的组织者和领导者，中国革命从此不断向前发展，由民主主义革命向社会主义革命推进。<br>　　2.中国共产党的成立，使中国革命有了科学的指导思想。中国共产党以马克思主义为指导思想，把马克思主义和中国革命的具体实践相结合，制定了正确的革命纲领和斗争策略，为中国人民指明了斗争的目标和走向胜利的道路。<br>　　3.中国共产党的成立，使中国革命有了新的革命方法，并沟通了中国革命和世界无产阶级革命之间的联系，为中国革命获得了广泛的国际援助和避免走资本主义提供了客观可能性。<br>　　4.中国革命有了新的奋斗目标。即：实现新民主主义革命的胜利，建设社会主义和共产主义社会。<br>　　中共一大即中国共产党第一次全国代表大会，1921年7月23日在上海召开，标志着中国共产党的正式成立</p><h3 id="3-中国共产党成立后，中国革命呈现了哪些新面貌"><a href="#3-中国共产党成立后，中国革命呈现了哪些新面貌" class="headerlink" title="3.中国共产党成立后，中国革命呈现了哪些新面貌?"></a>3.中国共产党成立后，中国革命呈现了哪些新面貌?</h3><p>中国共产党成立后，中国革自命呈现的新面貌：<br>　　第一，第一次提出了反帝反封建的民主革命纲领，为中国人民指出了明确的斗争目标。<br>　　第二，发动工农群众开展革命斗争，在中国掀起了第一次工人运动高潮，同时，中国共产党也开始从事发动农民的工作，农民的运动蓬勃发展。<br>　　第三，实行国共合作，并在合作中发挥主导作用，掀起大革命高潮，推翻了北洋军阀的统治。<br>原因：<br>　　一、中国共产党使中国革命有了坚强的领导核心，中国人民有了可依赖的组织者和领导者，保证了中国革命的胜利发展。<br>　　二、中国共产党使中国革命有了马列主义科学的指导思想，并与中国实际相结合，为中国人民指明了斗争的目标和走向胜利的道路。<br>　　三、中国共产党使中国革命有了新的革命方法，并沟通了中国革命与世界革命的联系，为中国革命获得国际援助和避免资本主义前途提供了客观可能性。</p><h2 id="FIVE-13-15"><a href="#FIVE-13-15" class="headerlink" title="FIVE   13-15"></a>FIVE   13-15</h2><h3 id="1-以毛泽东为代表的中国共产党人是如何探索和开辟中国革命新道路的"><a href="#1-以毛泽东为代表的中国共产党人是如何探索和开辟中国革命新道路的" class="headerlink" title="1.以毛泽东为代表的中国共产党人是如何探索和开辟中国革命新道路的?"></a>1.以毛泽东为代表的中国共产党人是如何探索和开辟中国革命新道路的?</h3><p>​        （一）开展武装反抗国民党统治的斗争<br>　　1927年8月，中共中央在汉口召开紧急会议（八七会议），彻底清算了大革命后期的陈独秀右倾机会主义错误，确定了开展土地革命和武装反抗国民党反动统治的总方针。<br>　　八七会议以后，举行了南昌起义、湘赣边界秋收起义、广州起义。中国革命由此发展到了一个新阶段。<br>　　（二）走农村包围城市的革命道路<br>　　以农村为重点，到农村去发动农民，进行土地革命，开展武装斗争，建设根据地，这是1927年大革命失败后中国革命发展的客观规律所要求的。农村包围城市、武装夺取政权这条革命新道路的开辟，依靠了党和人民的集体奋斗，凝聚了党和人民的集体智慧。而毛泽东是其中的杰出代表。　　<br>　　（三）毛泽东不仅在实践中首先把革命进攻的方向指向了农村，而且从理论上阐明了武装斗争的极端重要性和农村应当成为党的工作中心的思想。<br>　　1928年，毛泽东写了《中国的红色政权为什么能够存在？》、《井冈山的斗争》等文章，明确指出以农业为主要经济的中国革命，以军事发展暴动，是一种特征；还科学阐明了共产党领导的土地革命、武装斗争与根据地建设这三者之间的辩证统一关系。<br>　　1930年，《星星之火可以燎原》一文中，毛泽东指出：红军、游击队和红色区域的建立和发展，是半殖民地中国在无产阶级领导下的农民斗争的最高形式和半殖民地农民斗争发展的必然结果，并且无疑议的是促进全国革命高潮的最重要因素。<br>　　（四）农村包围城市，武装夺取政权理论，是对1927年革命失败后中国共产党领导的红军和根据地斗争经验的科学概括。它是以毛泽东为代表的中国共产党人同当时党内盛行的把马克思主义教条化、把共产国际和苏联经验神圣化的错误倾向做坚决斗争基础上形成的。<br>　　农村包围城市、武装夺取政权理论的提出，标志着中国化的马克思主义：毛泽东思想的初步形成。<br>　　（五）随着革命新道路的开辟，中国革命开始走向复兴。中国共产党领导的红军和根据地逐步发展起来。红军游击战争实际上已经成为中国革命的主要形式，农村根据地成为积蓄和锻炼革命力量的主要战略阵地。</p><h3 id="2-20世纪20年代后期、30年-代前中期-中国共产党内为什么连续出现“左”倾错误"><a href="#2-20世纪20年代后期、30年-代前中期-中国共产党内为什么连续出现“左”倾错误" class="headerlink" title="2. 20世纪20年代后期、30年 代前中期,中国共产党内为什么连续出现“左”倾错误?"></a>2. 20世纪20年代后期、30年 代前中期,中国共产党内为什么连续出现“左”倾错误?</h3><p>第一，主要原因在于全党的马克思主义理论准备不足，理论素养不高，实践经验也很缺乏，对于中国的历史现状和社会状况、中国革命的特点、中国革命的规律不了解，对于马克思列宁主义的理论和中国的实践没有统一的理解，一句话，不善于把马克思列宁主义与中国实际全面的、正确的结合起来。<br>第二，共产国际对中国共产党内部事务的错误敢于和瞎指挥。<br>第三，八七会议以后党内一直存在着浓厚的“左”倾情绪始终没有得到认真地清理。 第四，半殖民地半封建中国社会的阶级状况，决定了中国共产党的党员中农民和小资产阶级出身的占大多数，使党处在小资产阶级思想的包围之中。党内出现只注重书本知识，不注重实际的教条主义，只注重感性知识而轻视理论的经验主义。影响党的思想、路线和政策。</p><h3 id="3-中国共产党是如何总结历史经验、加强党的思想理论建设的"><a href="#3-中国共产党是如何总结历史经验、加强党的思想理论建设的" class="headerlink" title="3. 中国共产党是如何总结历史经验、加强党的思想理论建设的?"></a>3. 中国共产党是如何总结历史经验、加强党的思想理论建设的?</h3><p>土地革命时期，党内连续发生“左”倾错误，给中国革命带来了极其严重的危害。这些错误的发生，主要是对于马克思列宁主义的理论和中国革命的实践没有统一的理解而产生的。正因为如此，毛泽东强调，为了纠正错误，必须端正思想路线，实行马克思列宁主义与中国实际相结合的原则。<br>以毛泽东为主要代表的中国共产党人历来重视总结经验，加强党的思想理论建设。毛泽东早就提出，要注重调查研究，反对本本主义。红军到达陕北后，毛泽东、中共中央用很大的精力，去总结历史经验，加强党的思想理论建设。<br>1935年12月毛泽东作了《论反对日本帝国主义的策略》的报告，阐明党的抗日民族统一战线政策，批判了大给的关门主义和对于革命的急性病，系统地解决了党的政治路线上的问题。<br>1936年12月毛泽东写了《中国革命战争的战略问题》这部著作，总结土地革命战争中党内在军事问题上的大争论，系统地说明了有关中国革命战争战略方面的诸问题。<br>1937年夏，毛泽东写了《实践论》、《矛盾论》，从马克思主义认识论的高度，总结龙国共产党的历史经验，揭露和批判党内的主观主义尤其是教条主义的错误，深入论证马克思列宁主义基本原理同中国具体实际相结合的原则，科学地阐明了党的思想路线。</p><h2 id="SIX-16-19"><a href="#SIX-16-19" class="headerlink" title="SIX   16-19"></a>SIX   16-19</h2><h3 id="1-为什么说中国的抗日战争是神圣的民族解放战争"><a href="#1-为什么说中国的抗日战争是神圣的民族解放战争" class="headerlink" title="1.为什么说中国的抗日战争是神圣的民族解放战争?"></a>1.为什么说中国的抗日战争是神圣的民族解放战争?</h3><p>第一，中国人民抗日战争的胜利，彻底打败了日本侵略者，捍卫了中国的国家主权和领土完整，使中华民族避免了遭受殖民奴役的厄运。抗日战争的胜利，结束了日本在台湾50年的殖民统治，使台湾回到祖国的怀抱。<br>第二，中国人民抗日战争的胜利，促进了中华民族的觉醒，使中国人民在精神上、组织上的进步达到了前所未有的高度。中国人民通过抗日战争的实践认识到，中国共产党是领导中国民族人民争取民族独立和人民解放的坚强核心。正是在抗日战争的基础上，中国共产党领导人民取得了整个新民主主义革命的胜利。<br>第三，中国人民抗日战争的胜利，促进了中华民族的大团结，弘扬了中华民族的伟大精神。这就是：坚决维护国家和民族利益、誓死不当亡国奴的民族自尊品格；万众一心、共赴国难的民族团结意识；不谓强暴、敢于同敌人血战到底的民族英雄气概；百折不挠、敢于依靠自己的力量战胜侵略者的民族自强信念；开拓创新、善于在危难中开辟发展新道路的民族创造精神。<br>第四，中国人民抗日战争的胜利，对世界各国夺取反法西斯战争胜利、维护世界和平的伟大事业产生了巨大影响。中国人民为最终战胜世界反法西斯势力作出的历史性贡献，在全世界人民面前树立了一个以弱胜强的范例。中国参与发起成立联合国并成为联合国安理会常任理事国，显著提高了中国的国际地位和国际影响。</p><h3 id="2-为什么说中国共产党是中国人民抗日战争的中流砥柱"><a href="#2-为什么说中国共产党是中国人民抗日战争的中流砥柱" class="headerlink" title="2. 为什么说中国共产党是中国人民抗日战争的中流砥柱?"></a>2. 为什么说中国共产党是中国人民抗日战争的中流砥柱?</h3><p>因为没有以毛泽东为主要代表的中国共产党人，积极倡导、促成、维护抗日民族，统一战线，抗日战争就不会胜利。</p><p>中国共产党始终坚持把马克思列宁主义的基本原理与中国的具体实际相结合，创造和发展了毛泽东思想，在抗日战争中发挥了重要的指导作用。 在这场战争里，中国共产党及其领导的人民武装力量，是全民族利益的最坚定的维护者，是取得抗战胜利的决定性力量。</p><p>中国共产党倡导，推动和维护抗日民族统一战线，动员国民军和人民尽可能战争，成为全体力量的杰出组织者和激励者。 </p><p>中国共产党人以最虔诚的爱国主义和不怕流血的模范行动支持拯救国家救国的希望，成为赢得战争胜利的全国先锋。中国共产党在敌后发动和组织以农民为主力的各阶层群众，开展游击战争，使大量侵华日军陷于人民战争的汪洋大海之中。共产党领导的军队在这场战争中付出极大牺牲，为夺取抗日战争胜利也作出了重大的贡献。</p><h3 id="3-怎样评价国民党政府在抗日战争中执行的路线和正面战场的地位与作用"><a href="#3-怎样评价国民党政府在抗日战争中执行的路线和正面战场的地位与作用" class="headerlink" title="3.怎样评价国民党政府在抗日战争中执行的路线和正面战场的地位与作用?"></a>3.怎样评价国民党政府在抗日战争中执行的路线和正面战场的地位与作用?</h3><p>第一，国民党政府执行的是片面抗战路线，即不敢放手发动和武装民众，实行单纯的政府和正规军的抗战；在战略战术上，没有采取积极防御的方针，而是进行单纯的阵地防御战。<br>第二，国民党领导的正面战场，对抗日战争的胜利做出了重要贡献。特别是在抗战初期的战略防御阶段。<br>第三，国民党的正面战场在抗战个阶段中表现不同，其地位和作用也不同。抗战初期的战略防御阶段，国民党政府积极抗战，正面战场在整个抗战中起了重要作用。抗战进入战略相持阶段，其实行片面抗战，制造反共摩擦，在抗战中的地位、作用明显下降。在战略反攻阶段，其虽坚持抗战，但对夺取抗战最后胜利的作用十分有限。</p><h3 id="4-为什么说中国人民抗日战争是弱国战胜强国的范例-其历史意义是什么"><a href="#4-为什么说中国人民抗日战争是弱国战胜强国的范例-其历史意义是什么" class="headerlink" title="4.为什么说中国人民抗日战争是弱国战胜强国的范例?其历史意义是什么?"></a>4.为什么说中国人民抗日战争是弱国战胜强国的范例?其历史意义是什么?</h3><p>（1）从实力对比看，抗日战争使弱国对强国的战争。中国是半殖民地半封建社会，政治、经济、军事、文化等各方面的综合实力都很落后，是弱国。而日本是世界上一等强国，军事、经济实力和政治组织力量都很强大。<br>（2）从战略对比看，抗日战争使大国对小国的战争。中国虽弱，但很大，地域广阔，人口众多，资源丰富，兵源和物资补给充足，能长久坚持抗战。日本虽强，但很小，且是深入中国的广阔领土，使得其人力、军力、财力、物力均感缺乏，经不起长期的战争。<br>(3)从战争性质看，抗日战争是中国抵御日本侵略的正义战争。中国是正义的，进步的，得道多助，会得到广泛的国际援助。而日本是非正义的，野蛮的。失道寡助。<br>(4)从战争结果看，抗日战争取得了胜利。中国经过14年抗战，以3500万人的伤亡和5000多亿美元的损失，战胜了日本帝国主义，取得来抗战的最后胜利，捍卫了中国的国家主权和领土完整，使中华民族避免了遭受殖民奴役的厄运，促进了中华民族的觉醒和复兴。<br>基本经验：<br>（1）全国各族人民的大团结是中国人民战胜一切艰难困苦、实现奋斗目标的力量源泉。没有全国各族人民的大团结，就没有抗日战争的伟大胜利。<br>（2）以爱国主义为核心的伟大民族精神是中国人民团结奋进的精神动力。以爱国主义为核心的中华民族精神是抗日战争得以坚持和胜利的重要思想保证。<br>（3）提高综合国力是中华民族自立于世界民族之林的基本保证。一个国家只有首先自强，才能在世界上自立。<br>（4）中国人民热爱和平，反对侵略战争，同时有决不惧怕战争。<br>（5）只有坚持中国共产党的领导，中华民族才能捍卫自己的生存和发展的权利，才能创造美好的未来。</p><h2 id="SEVEN-20-22"><a href="#SEVEN-20-22" class="headerlink" title="SEVEN 20-22"></a>SEVEN 20-22</h2><h3 id="1-抗战胜利后，国民党政府为什么会陷入全民的包围中并迅速走向崩溃"><a href="#1-抗战胜利后，国民党政府为什么会陷入全民的包围中并迅速走向崩溃" class="headerlink" title="1.抗战胜利后，国民党政府为什么会陷入全民的包围中并迅速走向崩溃?"></a>1.抗战胜利后，国民党政府为什么会陷入全民的包围中并迅速走向崩溃?</h3><p>第一，国民党政府由于它的专制独裁统治和官员们的贪污腐败、大发国难财，抗战后期在大后方便已严重丧失人心。在抗战胜利时曾经对他抱有很大希望的原沦陷区人民，也很快对他感到极端的失望。一个重要原因，就是国民党政府派出的官员到原沦陷区接收时，把接收变成了“劫收”，大发国难财。<br>第二，国民党之所以迅速失去民心，还由于它违背全国人民迫切要求休养生息、和平建国的意愿，执行反人民的内战政策。为了筹措内战经费，国民党政府除了对人民征收苛重的捐税以外，更无限制的发行纸币。导致恶性通货膨胀，工农业生产严重萎缩。<br>这样，国民党当局就将全国各阶层人民之于饥饿和死亡的界线上，因而就迫使全国各阶层人民团结起来，同蒋介石反动政府作你死我活的斗争，除此以外，再无出路。</p><h3 id="2-如何认识民主党派的历史作用-中国共产党领导的多党合作、政治协商的格局是怎样形成的"><a href="#2-如何认识民主党派的历史作用-中国共产党领导的多党合作、政治协商的格局是怎样形成的" class="headerlink" title="2.如何认识民主党派的历史作用?中国共产党领导的多党合作、政治协商的格局是怎样形成的?"></a>2.如何认识民主党派的历史作用?中国共产党领导的多党合作、政治协商的格局是怎样形成的?</h3><p>1.监督执政的作用.是中国民主政治的重要组成部分,在中国共产党的领导下,在全国人民代表大会和全国政治协商会议的框架下讨论国家方针政策,来监督共产党的执政.<br>民主党派现在已经被提升到一个新的高度,民主党派成员已经开始直接管理国家事务,出任部长,不再仅仅担任副职<br>第一，各民主党派虽然政纲不尽相同，但都主张爱国、反对买过，主张民主、反对独裁，在抗战中，对反抗日本帝国主义侵略，特别是文化侵略，多国统区抗日民主运动的发展都起了积极作用。抗战胜利后，民主党派作为“第三方面”，主要与共产党一起，反对国民党的内战独裁政策，为和平民主而奔走呼号。<br>第二，各民主党派成立时，中国共产党就与他们建立了不同程度的合作关系，并在斗争实践中逐步发展了这种合作关系。在共同繁多国民党独裁统治的斗争中，中国共产党不仅鼓励、支持各民主党派的斗争，而且对他们某些不妥的意见进行批评，诚恳地帮助他们进步，这是的中共与民主党派的关系更加融洽，合作方式不断发展完善。<br>第三，国民党坚持一党独裁，迫害民主党派进步人士，使得民主党派人士逐步转到新民主主义革命立场上，特别是1948年1月22日，民主党派和无党派人士发表《对时局的意见》，表示愿意接受中国共产党的领导，拥护建立人民民主的新中国。<br>第四，中国共产党也邀请民主党派“积极参政，共同建设新中国”，1949年9月，各民主党派积极参加了中国人民政治协商会议。这标志着各民主党派正式接受了中国共产党领导和人民共和国，确认了社会主义的正确性。各民主党派也由在野党变成了人民民主专政的参政党，中国共产党领导的多党合作、政治协商的格局基本形成，中国共产党领导的多党合作和政治协商制度在此基础上也基本形成。<br>2.中国共产党也邀请民主党派“积极参政，共同建设新中国”，1949年9月，各民主党派积极参加了中国人民政治协商会议。这标志着各民主党派正式接受了中国共产党领导和人民共和国，确认了社会主义的正确性。各民主党派也由在野党变成了人民民主专政的参政党，中国共产党领导的多党合作、政治协商的格局基本形成，中国共产党领导的多党合作和政治协商制度在此基础上也基本形成。</p><h3 id="3-为什么说“没有共产党就没有新中国”-中国共产党领导中国革命取得胜利的基本经验是什么"><a href="#3-为什么说“没有共产党就没有新中国”-中国共产党领导中国革命取得胜利的基本经验是什么" class="headerlink" title="3.为什么说“没有共产党就没有新中国”?中国共产党领导中国革命取得胜利的基本经验是什么?"></a>3.为什么说“没有共产党就没有新中国”?中国共产党领导中国革命取得胜利的基本经验是什么?</h3><p>第一，中国共产党作为工人阶级的政党，不仅代表着中国工人阶级的利益，而且代表着整个中华民族和全中国人民的利益。<br>第二，中国共产党是马克思主义的科学理论武装起来的，他以中国化的马克思主义即马克思列宁主义基本原理与中国实践相结合的毛泽东思想为一切工作的指针。<br>第三，中国共产党人在革命过程中始终英勇地站在斗争的最前线。以实际行动表明了自己是最有远见，最富于牺牲精神，最坚定，而又最能虚心体察民情并依靠群众的坚强的革命者，从而赢得了广大中国人民的衷心拥护。<br>第四，“没有共产党就没有新中国”。这是中国人民基于自己的切身体验所确认的客观真理。<br>中国革命取得胜利的基本经验（中国共产党在中国革命中战胜敌人的三大法宝）<br>第一，建立广泛的统一战线。<br>第二，坚持革命的武装斗争。<br>第三，加强共产党自身的建设。</p><h2 id="EIGHT-23-25"><a href="#EIGHT-23-25" class="headerlink" title="EIGHT 23-25"></a>EIGHT 23-25</h2><h3 id="1-为什么说新民主主义社会是一-个过渡性的社会"><a href="#1-为什么说新民主主义社会是一-个过渡性的社会" class="headerlink" title="1.为什么说新民主主义社会是一-个过渡性的社会?"></a>1.为什么说新民主主义社会是一-个过渡性的社会?</h3><p>在新民主主义社会中，存在着五种经济成分，即：社会主义性质的国营经济、半社会主义性质的合作社经济、农民和手工业者的个体经济、私人资本主义经济和国家资本主义经济。其中国营经济处于领导地位。<br>①在我国新民主主义社会中，社会主义的因素不论在经济上还是政治上都已经居于领导地位，但非社会主义因素仍有很大的比重。由于社会主义因素的优越性和领导地位，加上当时有利于发展社会主义的国际条件，决定了社会主义因素将不断增长并获得最终胜利。</p><p>②为了促进社会生产力的进一步发展，为了实现国家富强、民族振兴，我国新民主主义社会必须适时地逐步过渡到社会主义社会。</p><p>③我国新民主主义社会是属于社会主义体系的，是逐步过渡到社会主义社会的过渡性质的社会。</p><h3 id="2-怎样理解社会主义制度在中国的确立是历史和人民的选择"><a href="#2-怎样理解社会主义制度在中国的确立是历史和人民的选择" class="headerlink" title="2. 怎样理解社会主义制度在中国的确立是历史和人民的选择?"></a>2. 怎样理解社会主义制度在中国的确立是历史和人民的选择?</h3><p>（1）社会主义性质的国营经济力量相对来说比较强大，它是实现国家工业化的主要基础。而国家的社会主义工业化，是国家独立和富强的当然要素和必要条件。<br>（2）资本主义经济力量弱小，发展困难，不可能成为中国工业起飞的基础。<br>（3）对个体农业进行社会主义改造，是保证工业发展，实现国家工业化的一个必要条件。<br>（4）当时的国际环境也促使中国选择社会主义。<br>人们的选择是十分必要的、完全正确的。<br>通过选择，中国共产党创造性的完成了由新民主主义到社会主义的过渡，实现了中国历史上最伟大、最深刻的社会变革，开始了在社会主义道路上实现中华民族伟大复兴的历史征程。</p><h3 id="3-为什么说完成社会主义改造是中国历史上最伟大和最深刻的社会变革"><a href="#3-为什么说完成社会主义改造是中国历史上最伟大和最深刻的社会变革" class="headerlink" title="3.为什么说完成社会主义改造是中国历史上最伟大和最深刻的社会变革?"></a>3.为什么说完成社会主义改造是中国历史上最伟大和最深刻的社会变革?</h3><p>社会主义改造的基本完成，使中国社会经济结构发生了根本变化，社会主义经济成分已占绝对优势，社会主义公有制已成为我国社会的经济基础。</p><p>伴随着社会经济制度和社会经济结构的根本变化，中国社会的阶级关系也发生了根本的变化。社会主义改造的基本完成和由此带来的社会各方面的变化，表明社会主义基本制度已经在中国的经济领域、政治领域及社会生活其他领域初步确立。</p><p>中国可以在没有实现工业化的情况下进入社会主义，社会主义基本制度的确立正是为了推进中国的工业化、现代化建设；另一方面，由于经济文化还比较落后，中国的社会主义还只能是初级阶段的社会主义，或者叫社会主义初级阶段。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观《教父》有感</title>
      <link href="/2020/06/18/2020/%E8%A7%82%E3%80%8A%E6%95%99%E7%88%B6%E3%80%8B%E6%9C%89%E6%84%9F/"/>
      <url>/2020/06/18/2020/%E8%A7%82%E3%80%8A%E6%95%99%E7%88%B6%E3%80%8B%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>观《教父》有感</strong></p><p>《教父》，一部称之为“男人的圣经”上世纪70年代出版的美国电影，虽说是根据同名小说进行改编，但经导演弗朗西斯·科波拉的精心制作，马龙·白兰度等演员的精湛演技，最终掀起了帮派电影的新潮流，斩获奥斯卡金像奖最佳电影、最佳男主角及最佳改编剧本三大奖项，作为最经典的电影之一，在人们心目中长久不衰。</p><p>本剧以新老教父为主角，老教父维托·柯里昂作为美国最大的黑手党教父之一，开篇参加女儿康妮婚礼的同时，先是帮助好友惩治轮奸女儿的恶徒，后帮助教子约翰尼·冯塔纳获得好莱坞电影角色，拜托军师汤姆·黑根前往洛杉矶找寻制作人，美名给他一个“无法拒绝的条件”。同时，幼子迈克尔·柯里昂，一个不参与家族事业的陆军军官，将未婚妻凯伊·亚当斯介绍给了家人。</p><p>好景不长，毒枭索拉索因教父在政界关系庞大，于是想与教父合作毒品交易，教父深刻了解毒品绝不能碰，便拒绝了索拉索，引起了他的不满。索拉索雇凶暗杀维托，住院奄奄一息。迈克尔想挽救家族现状，便假意求和，与索拉索和麦考斯基和谈，在厕所取得手枪后将其杀死逃去西西里避难，并与另一位姑娘相恋成婚。</p><p>另一边，大哥桑尼趁机杀死了敌对黑手党塔塔基利亚之子，听到妹妹被家暴，冲动的他立马赶去救援，却在途中被扫射致死。在西西里避难的迈克尔也被盯上，妻子意外被炸死在了车内，迈克尔自此醒悟成长，更加黑化，返回了美国，与凯结婚，并继承家业。</p><p>迈克尔回美后成为新一任教父，受老教父指导，成功找出叛徒泰西欧，而老教父却发病身亡。迈克尔为了复仇，将五大黑帮家族首领全部刺杀，并处决了家族叛徒，作为新一任教父的地位稳固。</p><p>本篇橘子预示死亡或流血事件，贯穿了整个教父。第一次橘子出现是老教父维托下车购入橘子，遭到索拉索的报复，被行刺住院奄奄一息。第二次出现是教父同孙子玩耍时，用橘子皮逗孙子，却意外发病身亡。或许因为西西里有种橘子名为血橘，所以它的登场往往象征着流血与牺牲，又也许是因为整部影片基调过暗，橘子能够很好的在其中鲜艳的显示出来，所以选用橘子。但毫无疑问，老教父年轻时痛揍恶霸所获得的橘子，彷佛象征着柯里昂家族崛起的开始，而老教父遭刺杀时打翻的橘子，也彷佛象征着柯里昂家族的衰退。这一切都在不冥之中。</p><p>另一方面，老教父重视家庭，任教父时儿孙美满，家庭和睦，从小失去双亲的他，更重视忠实、情义与亲情，从电影第一幕婚礼，便能看出，老教父非常非常爱自己的家庭，即使有众多事务要处理，也不忘落下女儿康妮的生日，在迈克尔还没来到拍照时，老教父直接拒绝需等到迈克尔来到时才拍照，他是真真实实热切爱着他的家庭的；婚礼中，也能看出，其他人对教父的爱戴与尊敬。杀人卢卡会为了他背说话稿，军师为了他东奔西走。虽然最后发病而亡，却也算是在之前的日子享受了美满和幸福。而新教父迈克尔，虽然自上任以后，一生致力于洗白家族，却始终是孤独的。他曾是不顾家人反对参军，一个处于家族外的陆军军官，却最终成长为能把握好整个家族的柯里昂阁下，也与妻子决裂，与兄弟争斗，最终十分孤独。</p><p>电影之中有着许多对比强烈的地方，在电影开幕，别人寻求教父帮助的办公室，几乎是全黑，而一旁的婚礼，却色彩鲜艳，人物众多，每个人都倾尽全力展现了各个人物的性格特色，而拍照的时候，也是越向中心站，显示地位越高。另一强烈对比便是橘子所代来的，全篇基调较暗，橘子的出现使得非常的显眼，也让人看到那巨大的反差。再一块便是老教父看自己儿子的遗体时，打光直直的打在桑尼上，老教父维托的神情真是演绎的淋漓尽致，欲哭无泪却为了整个家族不能帮与他复仇，将他作为一位父亲，同时作为一个黑手党教父的无奈在表情上演绎的淋漓尽致。</p><p>《教父》作为一部同名畅销小说改编，要将其内容压缩至3小时的电影实属不易,而导演弗朗西斯·科波拉的处理，实在是淋漓尽致，《教父》还有我们深挖的地方，它也将继续作为一代佳作，广为流传于世。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观《Load of War》有感</title>
      <link href="/2019/12/15/2019/%E8%A7%82%E3%80%8ALoad%20of%20War%E3%80%8B%E6%9C%89%E6%84%9F/"/>
      <url>/2019/12/15/2019/%E8%A7%82%E3%80%8ALoad%20of%20War%E3%80%8B%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="观《Load-of-War》有感"><a href="#观《Load-of-War》有感" class="headerlink" title="观《Load of War》有感"></a><strong>观《Load of War》有感</strong></h3><p>“在这世界上一共有伍亿伍千万支军火在流通，那就是说每十二个人就有一支枪，唯一的问题是：我们如何让其他十一个人也有枪？”     </p><p>——引言</p><p>于课程之初，花2小时看完了《Load of War》这部片子，作为课程《战争类影片主题探索》的首部影片，其间大量真实枪械与坦克的使用，也让我们初步了解了何所谓“战争片”。</p><p>本剧以尤里为主角，以军火商的角度，讲述战争的另一面。尤里一家本经营着一家犹太餐厅，当其目睹一个黑帮老大杀死两名黑帮成员后，他决定与弟弟威特里合作，开始贩卖军火。很快，他的第一把枪”uzi“便成功出售，就如他本人所说：”第一次卖枪的感觉，很大程度上就象第一次做爱一样，你根本不知道自己在干嘛，虽然很刺激，但很快就结束了。“每个人都有自己所擅长的地方，或许只是在未做之前还未发现罢了。而尤里的独特天赋，便是贩卖军火。</p><p>就如盖茨比一般，尤里也有着自己的”美国梦“，他的梦想便是女星艾娃。或许热切的爱情都带着几分盲目感，尤里对艾娃的向往化为他的实质行动。他凭借自己贩卖军火所得到的钱包装自己，让艾娃对他动心并组建家庭。在爱情上他是如此幸运，但为了维持这份伪装，便不得不以更多的谎言并出售更多倍的枪支弹药。</p><p>不过对于尤里来说，家庭，或许只是束缚他恶狼本质的枷锁。1991年苏联解体后，在与叔叔一次合作中，叔叔被另一位军火商炸死，与此同时，尤里的对头，国际刑警组织的特务杰克对其的防范再加一分，却苦于没有证据逮捕他。明白了尤里真实身份与职业的艾娃，也带着儿子离尤里而去。而一直支持尤里的弟弟威特里，在反抗独裁者军队时被击毙。自此，尤里彻底变为孤单一人。家人的抛弃让其成为战争之王，成为威特里所一直防范着的恶犬，不代表任何立场，仅仅作为一个”商人“而周游于世界之间。</p><p>剧中明面上一直被赋予”战争之王“称号的安德烈，一直认为尤里才是真正的战争之王。”狗彘食人食而不知检，途有饿殍而不知发，人死则曰，非我也，岁也，无异于刺人而杀之曰：非我也，兵也。“杀人的虽然不是枪是人，但枪又何尝不是最大的帮凶。安德烈的想法也是由此得来的。没有任何立场的尤里，以隔岸观火的中立态度，见证了一个又一个的战争，也在反复之中，似是怀念不再归来的往日一般，在军火生意上，越走越远。</p><p>另一方面，尤里的对头——国际刑警杰克，作为第一线的正义人士，有着自己的职责。他是国家明面上最需要的人，为了更多的人能够活着而奋斗在前面，却也什么也改变不了，他做的事情没有错，秉公执法，但却也很悲哀，就如他自己所说”我本想送你下地狱，原来你已经在地狱。“抓捕军火商抓了几十年，最终却被自己的上级亲自放走了尤里。他是成为百姓孩子们心目中英雄的角色，也是身体力行抵制黑暗的角色，只不过其所信奉的正义是更深层次的邪恶罢了。</p><p>或是反讽，就如“每一个在非洲的派系，喜欢给自己起一些高尚的名字，解放这个，爱国那个，或者共和或民主什么的，也许他们不知道自己是什么，地球唯一喜欢战争的民族，往往最残忍的暴行都出自声称自己为自由战士的人们。“剧中也有着几大矛盾：</p><p>一、军火商的尤里不能有任何立场，否则死的就是他们自己。弟弟便是因良心愧疚站了独裁者的背面，死于尤里身前。</p><p>二、尤里被释放的原因就是他被判刑的原因，不幸的是他是必须存在的恶魔。尤里背后的政府高层，为避免自己的身份暴露，正是需要尤里这种自由工作者，为其去支持那些他不方便支持的军队，将战争进一步爆发。</p><p>三、世界上最大的军火商就是杰克的老板，国际警察信奉的正义不过是更深层次的邪恶。这也是杰克作为国际刑警最悲哀的地方，尽管凭借自己的努力成功逮捕了尤里，最终也只能被世界上最大的军火交易商——美国总统，打压他自己心中的”正义“，而他所信奉的正义，不过是比尤里更深层次的黑暗罢了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Comptine D&#39;un Autre Été</title>
      <link href="/2019/12/14/2019/Comptine%20D&#39;un%20Autre%20%C3%89t%C3%A9/"/>
      <url>/2019/12/14/2019/Comptine%20D&#39;un%20Autre%20%C3%89t%C3%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="Comptine-D’un-Autre-Ete"><a href="#Comptine-D’un-Autre-Ete" class="headerlink" title="Comptine D’un Autre Été"></a><strong>Comptine D’un Autre Été</strong></h3><p>（另一个夏天的童谣）</p><p>​        在2019年12月11日下午19点02分32秒，一只果蝇以每分钟能扇动4800次的频率降落到学校垃圾箱的苹果。与此同时，在b楼3楼某间教室中，老师激昂澎湃畅聊者学期末课程的总结。就在这时，丁香一号公寓11号楼五楼的走廊上，留居寝室的学生正带着自己的水卡前往开水房接水。还是在这个时候，属于键盘上的每一个字符，正由电脑传输入屏幕，写入关于《天使爱美丽》这部电影的观后些许感受及见解。</p><p>​        女主人公艾米丽便诞生在1974年法国的一个夏天。与他人不同的是，艾米丽的母亲阿曼蒂尼头脑有些神经质，父亲拉斐尔除了为女儿检查身体外不与女儿发生身体接触。在一次检查中因艾米丽过于激动与父亲的亲近，导致父亲误判艾米丽患有心脏病而导致她小时候没法与他人相往来。在母亲意外死亡，父亲因此患上自闭症后，艾米丽的童年更加的孤独与寂寞，这也使得她会在不经意间进入自己的幻想世界。</p><p>​        1997年的夏天，艾米丽意外在浴室的墙壁里发现了一只装有儿童玩具的铁盒。为了帮助别人寻回童年的回忆，艾米丽通过自己的努力，多方查找多处碰壁后，最终将铁盒归还给了曾经的男孩，看着他热切怀恋的泪，艾米丽更加坚定自己帮助他人的心。</p><p>​        自此，她积极行动起来，冷酷的杂货店老板、备受欺侮的伙计、忧郁阴沉的公寓管理员，还有对生活失去信心的邻居都被她列入了帮助的名单中。</p><p>​        这里便不得夸耀一番艾米丽如天使一般的心灵，虽然从小与外界相隔绝，无他人来往以提升自己的德智体美劳全面发展，但小艾米丽还是凭借自己纯洁的心，成功孕育了如今这个善良，爱家人，帮助他人的灵魂。“如果注定孤独，那么我愿意去爱全世界”，艾米丽做出这样的想法。她为了让父亲走出自闭症的影响，悄悄偷走小圣诞老人交予朋友带它“环游世界”，并为其拍下照片寄回家中；她为了帮助杂货店备受欺侮的伙计，使用自己的“小聪明”，以换小老板鞋码等方法，捉弄老板为伙计找回公道；她为了过路的老人，搀扶着他一路走过街道，谈到不同人所在做的不同的事，老人也彷佛感受到了如上天赐给的天使的光芒绽放笑容。</p><p>​        或许是那句好人总会有好报，艾米丽也成功遇见了爱情。艾米丽与收集他人拍坏大头照的尼诺相遇了，爱情的种子在她心中萌发。“人生多美丽，恋爱中的男女总是容光焕发，神秘才有吸引力。”或是因此，本部剧在艾米丽与尼诺之间的暧昧与相识累积的颇多文笔，无一不在表现神秘、捉摸不透却又充满甜蜜的France Romance。照相亭的初见，归还相簿给尼诺所留下的箭头，带着面具的大头贴，画面中绚丽明媚的色彩映照着两人之间的爱情萌芽。</p><p>​        两人之间那种不敢用言语吐露感情的羞涩感，那种对自己的不信任，那种无条件的忠诚，那种告别时的凄恻惆怅，那种充满嫉妒的独占欲。虽未正式见面，但两人之间如藕丝般缠绵，如猫般若离若进、若影若现的爱意，无一不显露两人之间的缘与情。有情人终成眷属，两人也在影片末尾骑着单车游过巴黎街头，落下帷幕。</p><p>​        ”没有你，良辰美景可与谁人说？“，尼诺于艾米丽如此，艾米丽于尼诺也是如此，他们寻找到了自己的爱情，收获了彼此的余生。</p><p>​        影片中每个人都有着自己的“怪癖”。就如剧中所说：“生命岂能尽如人意，人人都要有嗜好“。艾米丽喜欢在河边打水漂，将手指伸进装满豆子里的袋子；尼诺喜欢收集照相亭中被别人撕毁的大头贴，拉斐尔喜欢撕掉贴好的整片墙纸……</p><p>​        ”你不必万丈光芒，也不必有什么特殊意义，你只需要做那个小小你，然后去爱，这是那个天使告诉我的事。“，每个人都是独特的自我，不必为了别人善解人意，不必正义挺身而出，甚至不必年轻，你可以安静自由地在角落里绽放花朵，如剧中角色，拥有属于自己的小怪癖，坚持自己心中的小偏执，但却不能懦弱，不能逃避，不能不去面都内心的冲突，才是对生命价值的尊重和珍惜。</p><p>来自卑微小王的结课卑微论文。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级写作句型模板</title>
      <link href="/2019/12/08/2019/%E5%9B%9B%E7%BA%A7%E5%86%99%E4%BD%9C%E5%8F%A5%E5%9E%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/12/08/2019/%E5%9B%9B%E7%BA%A7%E5%86%99%E4%BD%9C%E5%8F%A5%E5%9E%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="四级写作句型模板"><a href="#四级写作句型模板" class="headerlink" title="四级写作句型模板"></a>四级写作句型模板</h1><h3 id="一、开头段常用提出现象句型"><a href="#一、开头段常用提出现象句型" class="headerlink" title="一、开头段常用提出现象句型"></a><strong>一、开头段常用提出现象句型</strong></h3><p><strong>1. Nowadays more and more… are commonly and widely… in everyday life.</strong></p><p>如今，在日常生活中，越来越多……被广泛……。</p><p><strong>2. In recent years… is gaining growing popularity with…</strong> </p><p>近年来，……收到越来越多……的欢迎。</p><p><strong>3. Recent years have seen a boom in…</strong></p><p>近年来，……出现了迅速增长。</p><p><strong>4. Nowadays, there are many…</strong></p><p>如今出现了许多……</p><p><strong>5. Nowadays,… has become a very common matter in …</strong></p><p>如今，……已经成为……的常见现象。</p><p><strong>6. Nowadays, there is a growing tendency in…</strong></p><p>如今，在……方面出现了上升的趋势。</p><p><strong>7. Recently,… has aroused wide concern. /… has been brought into focus.</strong></p><p>最近，……引起了广泛关注/ 收到了人们的关注。</p><p><strong>8. Most of us may have such experience that…</strong></p><p>我们当中许多人可能都有……这种经历。</p><h3 id="二、开头段常用引出他人观点句型"><a href="#二、开头段常用引出他人观点句型" class="headerlink" title="二、开头段常用引出他人观点句型"></a><strong>二、开头段常用引出他人观点句型</strong></h3><p><strong>9. In reaction to the phenomenon of…,some people say…</strong></p><p>针对……现象，有人说……</p><p><strong>10. When asked about… most people say…</strong></p><p>当被问到……，大多数人认为……</p><p><strong>11. When it comes to…, some people think…</strong></p><p>关于……，有人认为……</p><p><strong>12. Now, it is widely believed that…</strong></p><p>现在，许多人认为……</p><h3 id="三、开头-中间段常用引出两种不同观点的句型"><a href="#三、开头-中间段常用引出两种不同观点的句型" class="headerlink" title="三、开头/ 中间段常用引出两种不同观点的句型"></a><strong>三、开头/</strong> <strong>中间段常用引出两种不同观点的句型</strong></h3><p><strong>13. There has sprung up a heated debate as to whether… Some maintain that… However, others believe that…</strong></p><p>关于是否……，人们争论不休。有些人认为……另一些人则认为……</p><p><strong>14. There is a public debate today over… Some people believe that… Others claim that…</strong></p><p>如今社会上出现了关于……的争论。 有些人认为…… 另一些人则声称……</p><p><strong>15. When it comes to/talking about…, quite a few people believe that… but other people think differently.</strong></p><p>当谈及……时，有相当一部分人认为……然而，另一些人则有不同想法。</p><p><strong>16. People’s opinions vary when they talk about… Some maintain that… Others believe that…</strong></p><p>当谈及……时，人们观点不一。有人坚持认为……另有人认为……</p><h3 id="四、开头段常用引出故事-时间句型"><a href="#四、开头段常用引出故事-时间句型" class="headerlink" title="四、开头段常用引出故事/时间句型"></a>四、开头段常用引出故事/时间句型</h3><p><strong>17. At about… o’clock in the… when I…, I saw…</strong></p><p>……点在……，当我正……的时候，我看见……</p><p><strong>18. Once in a street,…</strong></p><p>有一次在街上，……</p><p><strong>19. It was a… morning when a suddenly…</strong></p><p>那是……的早上，有一位……突然……</p><h3 id="五、中间段常用引出优缺点-不足-影响句型"><a href="#五、中间段常用引出优缺点-不足-影响句型" class="headerlink" title="五、中间段常用引出优缺点/ 不足/ 影响句型"></a><strong>五、中间段常用引出优缺点/</strong> <strong>不足/</strong> <strong>影响句型</strong></h3><p><strong>20. …plays an important role in…</strong></p><p>……对……很重要。</p><p><strong>21. The advantages of … lies in many ways.</strong></p><p>……有许多优点/好处。</p><p><strong>22. … as is the case with many issues, has both merits and demerits.</strong></p><p>正如许多事物一样，……也是既有优点又有不足。</p><p><strong>23. … will bring about an unfavorable effects/influence on…</strong></p><p>……会给……造成不好的影响。</p><p><strong>24. … will cause a sweeping change to…</strong></p><p>……会为……带来彻底的改变。</p><p><strong>25. …may give rise to /result in a number of problems.</strong></p><p>……会导致一系列问题。</p><h3 id="六、中间段-结尾段常用引出原因句型"><a href="#六、中间段-结尾段常用引出原因句型" class="headerlink" title="**六、中间段/ ** 结尾段常用引出原因句型"></a>**六、中间段/ ** <strong>结尾段常用引出原因句型</strong></h3><p><strong>26. Why…? Three factors can explain this. First,… Second,… Third,…</strong></p><p><strong>为什么……？</strong> </p><p>有三个因素可以解释。首先,……其次，……第三，……</p><p><strong>27. Three factors weigh heavily for… For one thing,… For another,… A third contributing factor is…</strong></p><p>三个因素对……很大。首先，……其次，……再次，……</p><p><strong>28.The factors that contribute to… include…</strong></p><p>造成……的因素包裹……</p><p><strong>29. The primary /leading reason /cause is that… …can be another reason. A further reason is that…</strong></p><p>主要原因是……。……也可能是另一个原因。第三个原因是……</p><p><strong>30. AS for /Among the factors for…, … counts for the half, the rest depends on…</strong></p><p>就导致……的因素而言，……是一部分原因，另一部分原因是……</p><h3 id="七、中间-结尾段常用引出结局方法句型"><a href="#七、中间-结尾段常用引出结局方法句型" class="headerlink" title="**七、中间/**结尾段常用引出结局方法句型"></a>**七、中间/**结尾段常用引出结局方法句型</h3><p><strong>31. How to…? The key words are as follows. To begin with,… Next,… Finally,…</strong></p><p>如何……？关键措施如下。首先，……其次，……最后，……</p><p><strong>32. The impacts could be minimized if we follow the suggestions as follow. One suggestion is… Another suggestion is… A further suggestion is…</strong></p><p>如果我们采用以下建议，有可能将影响降到最低。建议一是……建议而是……建议三是……</p><p><strong>33. Such… would not… if we knew the following ways to handle… First,… Second,… Third,…（虚拟语气）</strong></p><p>如果我们掌握了以下处理……的方法，如此的……可能不会…… 第一个方法是…… 第二个方法是……第三个方法是……</p><h3 id="八、结尾段常用引出“我”的个人观点句型"><a href="#八、结尾段常用引出“我”的个人观点句型" class="headerlink" title="八、结尾段常用引出“我”的个人观点句型"></a><strong>八、结尾段常用引出“我”的个人观点句型</strong></h3><p><strong>34. As far as I am concerned, I agree with…</strong></p><p>就我个人而言，我支持……</p><p><strong>35.As</strong> <strong>to me, the former /latter opinion is more acceptable.</strong></p><p>对我来说，前/后一种观点更可以接受。</p><p><strong>36. For my part, I am on the side of…</strong></p><p>对我来说，我站在……那边。</p><p><strong>37. As I see it,…</strong></p><p>就我看来,……</p><p><strong>38. From my perspective, I…</strong></p><p>就我而言，我……</p><h3 id="九、图表作文开头段常用引出总体（变化）趋势句型"><a href="#九、图表作文开头段常用引出总体（变化）趋势句型" class="headerlink" title="九、图表作文开头段常用引出总体（变化）趋势句型"></a><strong>九、图表作文开头段常用引出总体（变化）趋势句型</strong></h3><p><strong>39. As can be seen from the line /bar / chart /table that… increased / rose /grew dramatically from…</strong></p><p>从图表可见，自……以来，……出现了极大地增长。</p><p><strong>40. It can be seen /concluded from the chart that… dropped /declined /fell /reduced slightly to…</strong></p><p>依图可见/判断，……小幅下降到了……</p><p><strong>41. The period… to… saw… increase /drop in the number /percentage of…</strong> </p><p>……至……期间，……的数量/比重出现了……的增长/下降。</p><p><strong>42. There is a… fluctuation during… /The number of … fluctuates between… and…</strong></p><p>……期间，出现了……波动。/……至……期间，……数量出现了波动。</p><h3 id="十、书信作文开头段常用句型（最后一句主要在下级给上级写信时用）"><a href="#十、书信作文开头段常用句型（最后一句主要在下级给上级写信时用）" class="headerlink" title="十、书信作文开头段常用句型（最后一句主要在下级给上级写信时用）"></a><strong>十、书信作文开头段常用句型（最后一句主要在下级给上级写信时用）</strong></h3><p><strong>43. With regard to your inquiry about…, I’d like to make some conducive suggestions.</strong></p><p>对于你来信问我关于……，现提供几条建议。</p><p><strong>44. I am writing to express my views concerning…</strong></p><p>我写信时要提出关于……的看法。</p><p><strong>45. I am very sorry to occupy your precious time, but I really need to talk about… /but I am writing to express my views concerning…</strong></p><p>很抱歉占用您的宝贵时间，可是我确实想要谈谈……。/可是我写信时要提出关于……的看法。</p><h3 id="十一、书信作文中间段常用提建议句型"><a href="#十一、书信作文中间段常用提建议句型" class="headerlink" title="十一、书信作文中间段常用提建议句型"></a><strong>十一、书信作文中间段常用提建议句型</strong></h3><p><strong>46. I would like to suggest that… / I would like to make a recommendation that…</strong></p><p>我想建议……</p><p><strong>47. May I suggest that…?</strong></p><p>我可以提一点……建议吗？</p><p><strong>48. If I were you , I would…</strong></p><p>如果我是你，我会……</p><h3 id="十二、书信作文结尾段常用句型"><a href="#十二、书信作文结尾段常用句型" class="headerlink" title="十二、书信作文结尾段常用句型"></a><strong>十二、书信作文结尾段常用句型</strong></h3><p><strong>49.Please take good consideration of my advice.</strong></p><p>请仔细考虑我的建议。</p><p><strong>50. I hope what I mentioned above will…希望我以上所说的会……</strong></p><h3 id="Chapter-One-文章开头句型"><a href="#Chapter-One-文章开头句型" class="headerlink" title="Chapter One 文章开头句型"></a><strong>Chapter One</strong> <strong>文章开头句型</strong></h3><h4 id="1-1-对立法"><a href="#1-1-对立法" class="headerlink" title="1-1 对立法 :"></a><strong>1-1</strong> <strong>对立法 :</strong></h4><p><strong>先引出其他人的不同看法,然后提出自己的看法或者偏向于某一看法,适用于有争议性的主题.</strong> <strong>例如(e.g)</strong> </p><p>[1]. When asked about….., the vast/overwhelming majority of people say that ……. But I think/view a bit differently. </p><p>[2]. When it comes to …. , some people bielive that ……. Others argue/claim that the opposite/reverse is true . There is probably some truth in both arguements/statements , but (I tend to the profer/latter …) </p><p>[3]. Now, it is commonly/generally/widely believed/held/acknowledged that …. They claim/ believe/argue that … But I wonder/doubt whether….. </p><h4 id="1-2-现象法"><a href="#1-2-现象法" class="headerlink" title="1-2 现象法"></a><strong>1-2</strong> <strong>现象法</strong></h4><p><strong>引出要剖析的现象或者问题,</strong> <strong>然后评论 .</strong> </p><p>[1]. Recently the rise in problem of/(phenomenon of) … has cause/aroused public/popular/wide/ worldwide concern. </p><p>[2]. Recently the issue of the problem of/the phenomenon of …has been brought into focus. ( has been brouth to public attention) </p><p>[3].Inflation/Corruption/Social inequality … is yet another of the new and bitter truth we have to learn to face now/constantly. </p><p><strong>—– To be continued !!</strong> </p><h4 id="1-3-观点法"><a href="#1-3-观点法" class="headerlink" title="1-3 观点法"></a><strong>1-3</strong> <strong>观点法</strong></h4><p><strong>开门见山,直接了当地提出自己对要讨论的问题的看法.</strong> </p><p>[1]. Never history has the change of .. been as evident as … Nowhere in the world/China has the issue/idea of .. benn more visible/popular than… </p><p>[2]. Now people in growing/significant numbers are beginnig/coming to realize/accept/(be aware) that… </p><p>[3]. Now there is a growing awareness/recognation ot the necessity to……Now people become increasingly aware/conscious of the importance of …… </p><p>[4]. Perhaps it is time to have a fresh look at the attitude/idea that……. </p><h4 id="1-4-引用法"><a href="#1-4-引用法" class="headerlink" title="1-4 引用法"></a><strong>1-4</strong> <strong>引用法</strong></h4><p><strong>先引出名人名言或者有代表性的看法,来引出文章要展开论述的观点!</strong></p><p>[1]. “Knowledge is power.” such is the remark made by Bacon.This remark has been shared by more and more people . </p><p>“Education is not complete with gradulation.” Such is the opnion of a great American philosopher. Now more and more people share his opnion. </p><p>[2].”………” How often we hear such statements/words like thoses /this . </p><p>In our own days we are used to hearing such traditional complains as this “……”. </p><h4 id="1-5-比较法"><a href="#1-5-比较法" class="headerlink" title="1-5 **比较法 **"></a><strong>1-5</strong> **比较法 **</h4><p><strong>通过对过去,现在两种不同的倾向,观点的比较 ,引出文章要讨论的观点.</strong></p><p>[1]. For years, …had been viewed as … But people are taking a fresh look now. With the growing … , people ……. . </p><p>[2]. People used to think that … (In the past, ….) But people now share this new. </p><h4 id="1-6-故事法"><a href="#1-6-故事法" class="headerlink" title="1-6 故事法"></a><strong>1-6</strong> <strong>故事法</strong></h4><p><strong>先讲一个较短的故事来引发读者的兴趣,引出文章的主题.</strong> </p><p>[1]. Once in (a newspaper) , I read of/learnt …. The phenemenon of … has aroused public concern. </p><p>[2]. I have a friend who … Should he …. ? Such a dilemma we are often confront with in our daily life. </p><p>[3]. Once upon a time , there lived a man who … This story may be (unbelievable) , but it still has a realistic significance now. </p><h4 id="1-8-问题法"><a href="#1-8-问题法" class="headerlink" title="1-8 问题法"></a><strong>1-8</strong> <strong>问题法</strong></h4><p><strong>先用讨论或解答的设问,引出自己观点,适用于有争议性的话题.</strong></p><p>Should/What …… ? Options of … vary greatly , some …, others … </p><p>But in my opinion , …… . </p><h3 id="Chapter-2-文章中间主体内容句型"><a href="#Chapter-2-文章中间主体内容句型" class="headerlink" title="Chapter 2 文章中间主体内容句型"></a><strong>Chapter 2</strong> <strong>文章中间主体内容句型</strong></h3><p><strong>原因结果分析</strong></p><p><strong>3-1-1.</strong> <strong>基本原因 —</strong> <strong>分析某事物时,</strong> <strong>用此句型说明其基本的或者多方面的原因.</strong> </p><p><strong>[1]. Why … ? For one thing.. For another …</strong> </p><p><strong>[2]. The answer to this problem invovles many factors. For one thing… For another…… Still another …</strong> </p><p><strong>[3]. A number of factors , both physical and psychological affect …. /both individual and social contribute to ….</strong> </p><p><strong>3-1-2</strong> <strong>另一原因 ——–&gt;</strong> <strong>在分析了基本原因之后,</strong> <strong>再补充一个次要的或者更重要时用!</strong> </p><p><strong>[1]. Another important factor is ….</strong> </p><p><strong>[2]. … is also responsible for the change/problem.</strong> </p><p><strong>[3]. Certainly , the … is not the sole reason for …..</strong> </p><p><strong>3-1-3</strong> <strong>后果影响 ———</strong> <strong>分析某事物可能造成的后果或者带来的影响 .</strong> </p><p><strong>[1]. It will produce a profound/far-reaching effect/impact on….</strong> </p><p><strong>[2]. In involves some serious consequence for ……..</strong> </p><p><strong>比较对照句型</strong></p><p><strong>3-2-1.</strong> <strong>两者比较 —&gt;</strong> <strong>比较两事物,</strong> <strong>要说出其一超过另一个,</strong> <strong>或肯定一事物的优点,</strong> <strong>也肯定其缺点的时候用 !</strong> </p><p><strong>[1]. The advantages gained from A are much greater than the advantages we gain from B.</strong> </p><p><strong>[2]. Indeed, A carries much weight when compared with B.</strong> </p><p><strong>[3]. There is no doubt that it has its negative effects as well as positive effects.</strong></p><p><strong>3-2-2 .</strong> **两者相同/**<strong>相似 ——&gt;</strong> <strong>比较两事物共同都有或者共同都没有的特点时用!</strong> </p><p><strong>[1]. A and B have several thing in common. They are similar in that…..</strong> </p><p><strong>[2]. A bears some sriking resemblance(s) to B.</strong> </p><p><strong>Chapter Three</strong> <strong>文章结尾形式</strong> </p><p><strong>2-1</strong> <strong>结论性———</strong> **通过对文章前面的讨论 ,**<strong>引出或重申文章的中心思想及观点 .</strong> </p><p><strong>[1]. From what has been discussed above, we may safely draw the conclusion that …..</strong> </p><p><strong>[2]. In summary/In a word , it is more valuable …….</strong> </p><p><strong>2-2</strong> <strong>后果性——</strong> <strong>揭示所讨论的问题若不解决,</strong> <strong>将产生的严重后果.</strong> </p><p><strong>[1]. We must call for an immediate method , because the current phenomenon of … , if allowed to proceed, will surely lead to the heavy cost of …….</strong> </p><p><strong>[2]. Obviously , if we ignore/are blind to the problem , there is every chance that .. will be put in danger.</strong> </p><p><strong>2-3</strong> <strong>号召性 ——–</strong> <strong>呼吁读者行动起来,</strong> <strong>采取行动或提请注意.</strong> </p><p><strong>[1]. It is time that we urged an immediate end to the undesirable tendcy of ……</strong> </p><p><strong>[2]. It is essential thar effective measures should be taken to correct the tendency.</strong> </p><p><strong>2-4</strong> <strong>建议性 ——–</strong> <strong>对所讨论的问题提出建议性的意见,</strong> <strong>包括建议和具体的解决问题的方法.</strong> </p><p><strong>[1]. While it cannot be solved immediately, still there are ways. The most popular is …. Another method is … Still another one is …..</strong> </p><p><strong>[2]. Awareness/Recognition of the problem is the first step toward the situation.</strong> </p><p><strong>2-5</strong> <strong>方向性的结尾方式 —-</strong> <strong>其与建议性的唯一差别就是对问题解决提出总的,</strong> <strong>大体的方向或者指明前景.</strong> </p><p><strong>[1]. Many solutions are being offered here , all of them make some sense, but none is adequate enough. The problem should be recognized in a wide way .</strong> </p><p><strong>[2]. There is no quick method to the issue of .., but .. might be helpful/benefical.</strong></p><p><strong>[3]. The great challenge today is …… There is much difficulty , but ……..</strong> </p><p><strong>2–6</strong> <strong>意义性的结尾方式 ——–&gt;</strong> **文章结尾的时候,**<strong>从更高的更新的角度指出所讨论的问题的重要性以及其深远的意义!</strong> </p><p><strong>[1]. Following these suggestions may not guarantee the success, but the pay off might be worth the effort . It will not only benefit but also benefit …..</strong> </p><p><strong>[2]. In any case, whether it is posotive or negative, one thing is certain that it will undoubtedly ..</strong> </p><h4 id="英语四级作文万能句（一）段首句"><a href="#英语四级作文万能句（一）段首句" class="headerlink" title="英语四级作文万能句（一）段首句"></a><strong>英语四级作文万能句（一）段首句</strong></h4><p><strong>1.</strong> <strong>关于……人们有不同的观点。一些人认为……</strong> </p><p><strong>There are different opinions among people as to ____ .Some people suggest that ____.</strong> </p><p><strong>2.</strong> <strong>俗话说（常言道）……，它是我们前辈的经历，但是，即使在今天，它在许多场合仍然适用。</strong></p><p><strong>There is an old saying______. It”s the experience of our forefathers<strong><strong>，however</strong></strong>，it is correct in many cases even today.</strong> </p><p><strong>3.</strong> <strong>现在，……，它们给我们的日常生活带来了许多危害。首先，……；其次，……。更为糟糕的是……。</strong></p><p><strong>Today, <strong><strong>, which have brought a lot of harms in our daily life. First, ____ Second,</strong></strong>. What makes things worse is that______.</strong> </p><p><strong>4.</strong> <strong>现在，……很普遍，许多人喜欢……，因为……，另外（而且）……。</strong> </p><p><strong>Nowadays<strong><strong>，it is common to ______. Many people like ______ because ______. Besides</strong></strong>，______.</strong> </p><p><strong>5.</strong> <strong>任何事物都是有两面性，……也不例外。它既有有利的一面，也有不利的一面。</strong></p><p><strong>Everything has two sides and ______ is not an exception****，it has both advantages and disadvantages.</strong> </p><p><strong>6.</strong> <strong>关于……人们的观点各不相同，一些人认为（说）……，在他们看来，……</strong></p><p><strong>People’s opinions about ______ vary from person to person. Some people say that _<em><strong><strong>.To them,</strong></strong></em>.</strong> </p><p><strong>7.</strong> <strong>人类正面临着一个严重的问题……，这个问题变得越来越严重。</strong> </p><p><strong>Man is now facing a big problem ______ which is becoming more and more serious.</strong> </p><p><strong>8.</strong> <strong>……已成为人的关注的热门话题，特别是在年青人当中，将引发激烈的辩论。</strong></p><p><strong>______ has become a hot topic among people****，especially among the young and heated debates are right on their way.</strong> </p><p><strong>9.</strong> <strong>……在我们的日常生活中起着越来越重要的作用，它给我们带来了许多好处，但同时也引发一些严重的问题。</strong></p><p><strong>______ has been playing an increasingly important role in our day-to-day life.it has brought us a lot of benefits but has created some serious problems as well.</strong> </p><p><strong>10.</strong> **根据图表/****数字/****统计数字/****表格中的百分比/****图表/****条形图/**<strong>成形图可以看出……。很显然……，但是为什么呢？</strong> </p><p>*<em>According to the figure/number/statistics/percentages in the /chart/bar graph/line/graph</em><em><strong>，it can be seen that______ while. Obviously</strong></em>*，______**<strong>，but why?</strong> </p><h4 id="（二）中间段落句"><a href="#（二）中间段落句" class="headerlink" title="（二）中间段落句"></a><strong>（二）中间段落句</strong></h4><p><strong>1.</strong> <strong>相反，有一些人赞成……，他们相信……，而且，他们认为……。</strong> </p><p><strong>On the contrary<strong><strong>，there are some people in favor of ___.At the same time</strong></strong>，they say____.</strong> </p><p><strong>2.</strong> <strong>但是，我认为这不是解决……的好方法，比如……。最糟糕的是……。</strong> </p><p><strong>But I don”t think it is a very good way to solve <strong><strong>.For example****，</strong></strong>.Worst of all****，___.</strong> </p><p><strong>3.</strong> <strong>……对我们国家的发展和建设是必不可少的，（也是）非常重要的。首先，……。而且……，最重要的是……</strong></p><p><strong><strong><strong><strong>is necessary and important to our country”s development and construction. First****，</strong></strong></strong>.What”s more, <em><strong><strong>.Most important of all,</strong></strong></em>_.</strong> </p><p><strong>4.</strong> <strong>有几个可供我们采纳的方法。首先，我们可以……。</strong> </p><p><strong>There are several measures for us to adopt. First, we can______</strong> </p><p><strong>5.</strong> <strong>面临……，我们应该采取一系列行之有效的方法来……。一方面……，另一方面，</strong></p><p>*<em>Confronted with______<strong><strong>，we should take a series of effective measures to______. For one thing</strong></strong>，______For another</em>*<strong>，______</strong> </p><p><strong>6.</strong> <strong>早就应该拿出行动了。比如说……，另外……。所有这些方法肯定会……。</strong></p><p><strong>It is high time that something was done about it. For example. ____<em>.In addition. <em><strong><strong>.All these measures will certainly</strong></strong></em></em>.</strong> </p><p><strong>7.</strong> <strong>为什么……？第一个原因是……；第二个原因是……；第三个原因是……。总的来说，……的主要原因是由于……</strong></p><p><strong>Why______? The first reason is that ______.The second reason is ______.The third is ______.For all this, the main cause of ______due to ______.</strong> </p><p><strong>8.</strong> <strong>然而，正如任何事物都有好坏两个方面一样，……也有它的不利的一面，象……。</strong></p><p><strong>However, just like everything has both its good and bad sides, ______also has its own disadvantages, such as ______.</strong> </p><p><strong>9.</strong> <strong>尽管如此，我相信……更有利。</strong> </p><p><strong>Nonetheless, I believe that ______is more advantageous.</strong> </p><p><strong>10.</strong> <strong>完全同意……这种观点（陈述），主要理由如下：</strong> </p><p><strong>I fully agree with the statement that ______ because______.</strong> </p><h4 id="（三）结尾句"><a href="#（三）结尾句" class="headerlink" title="（三）结尾句"></a><strong>（三）结尾句</strong></h4><p><strong>1.</strong> <strong>至于我，在某种程度上我同意后面的观点，我认为……</strong> </p><p><strong>As far as I am concerned, I agree with the latter opinion to some extent. I think that ____.</strong> </p><p><strong>2.</strong> <strong>总而言之，整个社会应该密切关注……这个问题。只有这样，我们才能在将来……。</strong></p><p><strong>In a word, the whole society should pay close attention to the problem of ______.Only in this way can ______in the future.</strong> </p><p><strong>3.</strong> <strong>但是，……和……都有它们各自的优势（好处）。例如，……，而……。然而，把这两者相比较，我更倾向于（喜欢）……</strong></p><p><strong>But ______and <strong><strong><strong>have their own advantages. For example, <em><strong><strong>, while</strong></strong></em>. Comparing this with that, however, I prefer to</strong></strong></strong>.</strong> </p><p><strong>4.</strong> <strong>就我个人而言，我相信……，因此，我坚信美好的未来正等着我们。因为……</strong></p><p><strong>Personally, I believe that_____. Consequently, I’m confident that a bright future is awaiting us because______.</strong> </p><p><strong>5.</strong> <strong>随着社会的发展，……。因此，迫切需要……。如果每个人都愿为社会贡献自已的一份力量，这个社会将要变得越来越好。</strong></p><p><strong>With the development of society, ______.So it”s urgent and necessary to ____.If every member is willing to contribute himself to the society, it will be better and better.</strong> </p><p><strong>6.</strong> <strong>至于我（对我来说，就我而言），我认为……更合理。只有这样，我们才能……</strong></p><p><strong>For my part, I think it reasonable to_____. Only in this way can you _____.</strong> </p><p><strong>7.</strong> <strong>对我来说，我认为有必要……。原因如下：第一，……；</strong> <strong>第二，……；最后……但同样重要的是……</strong> </p><p><strong>In my opinion, I think it necessary to____. The reasons are as follows. First _____.Second <strong><strong><strong>. Last but not least,</strong></strong></strong>.</strong> </p><p><strong>8.</strong> <strong>在总体上很难说……是好还是坏，因为它在很大程度上取决于……的形势。然而，就我个人而言，我发现……。</strong></p><p><strong>It is difficult to say whether <em><strong><strong>is good or not in general as it depends very much on the situation of</strong></strong></em><em>. However, from a personal point of view find</em>_____.</strong> </p><p><strong>9.</strong> <strong>综上所述，我们可以清楚地得出结论……</strong> </p><p><strong>From what has been discussed above, we may reasonably arrive at the conclusion that____.</strong> </p><p><strong>10.</strong> <strong>如果我们不采取有效的方法，就可能控制不了这种趋势，就会出现一些意想不到的不良后果，所以，我们应该做的是……</strong></p><p><strong>If we can not take useful means, we may not control this trend, and some undesirable result may come out unexpectedly, so what we should do is_____.</strong> </p><p><strong>linked to</strong> 与…有关</p><p><strong>have unpleasant associations with</strong> 没什么好感</p><p><strong>praise and abuse</strong> 赞扬和批评</p><p><strong>seem to fail to take into account</strong> 似乎忽视了</p><p><strong>is not complete with</strong> 不能随着毕业而结束</p><p><strong>it comes to</strong> 说到</p><p><strong>contributes directly to</strong>有助于</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AUTOCAD2014</title>
      <link href="/2019/11/29/2019/AUTOCAD2014/"/>
      <url>/2019/11/29/2019/AUTOCAD2014/</url>
      
        <content type="html"><![CDATA[<h1 id="AUTOCAD2014"><a href="#AUTOCAD2014" class="headerlink" title="AUTOCAD2014"></a>AUTOCAD2014</h1><p><strong>L直线</strong>；<strong>PL二维多段线，W宽度</strong></p><p><strong>A圆弧</strong></p><p><strong>AL命令行文本框</strong></p><p><strong>C画圆</strong></p><p><strong>CO：copy</strong>，同时拷贝距离相等多个图形：<strong>CO-&gt;陈列</strong></p><p><strong>DIS测量端点距离</strong></p><p><strong>DIV等分点</strong></p><p><strong>M移动</strong></p><p><strong>MI对称</strong></p><p>找到等分点，使其更加明显显示出来–&gt;格式</p><p><strong>ME等距等分</strong></p><p><strong>REC矩形@长,宽</strong></p><p><strong>POL正多边形</strong></p><p><strong>相对坐标@Δx,Δy，@L&lt;α</strong></p><p>L：两点之间的距离（正值)</p><p>α：角度——第一点的x正方向与两点连线的夹角。（顺时针为负值，逆时针为正值）</p><p><strong>矩形选框</strong>：cad的默认选择的加选，若要减选按住shift键减选即可，单个物体多了也可以点一下来减少选区</p><p>从左向右：必须选全部；</p><p>从右到走：选部分即可选全部；</p><p>若要用线不规则选框，使用栏选</p><p><strong>esc：取消选择</strong></p><p><strong>滚轮按住不放可以使用鼠标平移</strong>，<strong>滚轮双击可以将图纸完整显示出来</strong></p><p><strong>CH特性</strong></p><p><strong>RO旋转</strong></p><p><strong>SC缩放</strong></p><p><strong>BR打断</strong>：切断线段</p><p><strong>X分解</strong>：将多段线分开</p><p><strong>J合并</strong>：(join)组合物体</p><p><strong>O偏移</strong>：(offset)</p><p><strong>EX延申</strong> 修剪按住shift选择</p><p><strong>S拉伸</strong></p><p><strong>AR阵列</strong></p><p><strong>H填充命令</strong>、<strong>HE对填充物体进行修改</strong></p><p><strong>CHA倒角</strong>，将纸片折起来</p><p><strong>F圆角命令</strong></p><h4 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h4><p><strong>DLI</strong>, *DIMLINEAR（<strong>直线标注</strong>）<br><strong>DAL</strong>, *DIMALIGNED（<strong>对齐标注</strong>）<br><strong>DRA</strong>, *DIMRADIUS（<strong>半径标注</strong>）<br><strong>DDI</strong>, *DIMDIAMETER（<strong>直径标注</strong>）<br><strong>DAN</strong>, *DIMANGULAR（<strong>角度标注</strong>）<br><strong>DCE</strong>, *DIMCENTER（<strong>中心标注</strong>）<br><strong>DOR</strong>, *DIMORDINATE（<strong>点标注</strong>）<br><strong>TOL</strong>, *TOLERANCE（<strong>标注形位公差</strong>）<br><strong>LE</strong>, *QLEADER（<strong>快速引出标注</strong>）<br><strong>DBA</strong>, *DIMBASELINE（<strong>基线标注</strong>）<br><strong>DCO</strong>, *DIMCONTINUE（<strong>连续标注</strong>）<br><strong>D</strong>, *DIMSTYLE（<strong>标注样式</strong>）<br><strong>DED</strong>, *DIMEDIT（<strong>编辑标注</strong>）<br><strong>DOV</strong>, *DIMOVERRIDE(<strong>替换标注系统变量</strong>)</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="/2019/11/15/2019/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/11/15/2019/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="类型有何不同"><a href="#类型有何不同" class="headerlink" title="类型有何不同"></a>类型有何不同</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">类型名称：<span class="hljs-keyword">int</span>、<span class="hljs-keyword">long</span>、<span class="hljs-keyword">double</span><br>输入输出时的格式化：%d、%ld、％If<br>所表达的数的范围：<span class="hljs-keyword">char</span>&lt;<span class="hljs-keyword">short</span>&lt;<span class="hljs-keyword">int</span>&lt;<span class="hljs-keyword">float</span>&lt;<br><span class="hljs-keyword">double</span><br>·内存中所占据的大小：<span class="hljs-number">1</span>个字节到<span class="hljs-number">16</span>个字节<br>·内存中的表达形式：二进制数（补码）、编码<br></code></pre></td></tr></table></figure><h4 id="sizeof–静态的"><a href="#sizeof–静态的" class="headerlink" title="sizeof–静态的"></a>sizeof–静态的</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//是一个运算符，给出某个类型或变量再内存中所占据的字节数</span><br><span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">sizeof</span>(i)<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a；<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(double)=%td\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(a)=%td\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(a))；<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>；<br>&#125;<br><span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>)=<span class="hljs-number">16</span><br><span class="hljs-keyword">sizeof</span>(a)=<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//char:1字节（8比特）</span><br><span class="hljs-comment">//short:2字节</span><br><span class="hljs-comment">//int:取决于编译器(CPU)，通常的意义是“1个字&quot;</span><br><span class="hljs-comment">//long 取决于编译器℃(U)，通常的意义是“1个字&quot;</span><br><span class="hljs-comment">//longlong 8字节</span><br></code></pre></td></tr></table></figure><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>char是一种整数，也是一种特殊的类型：字符。<br>这是因为:<br>用单引号表示的字符字面量：，’1’,’a’<br>‘’也是一个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>和<span class="hljs-built_in">scanf</span>里用％<span class="hljs-number">0</span>来输入输出字符<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br>intmain()<br>&#123;<br>    Char c；<br>    <span class="hljs-keyword">char</span> d;<br>    c = <span class="hljs-number">1</span>;<br>    d =<span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(c==d)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;相等\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不相等\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c==%d\n&quot;</span>,c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d==%d\n&quot;</span>,d);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不相等</p><p>c=1</p><p>d=65</p><h4 id="字符计算"><a href="#字符计算" class="headerlink" title="字符计算"></a>字符计算</h4><p>一个字符加一个数字得到ASCii码表中那个数之后的字符<br>两个字符的减，得到它们在表中的距离</p><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><p>字母在ASCii表中是顺序排列的<br>大写字母和小写字母是分开排列的，并不在一起<br><strong>‘a’-‘A’可以得到两段之间的距离</strong>，于是<br><strong>a+’a’-‘A’可以把一个大写字母变成小写字母</strong>，而<br><strong>a+’A’-‘a’可以把一个小写字母变成大写字母</strong></p><h4 id="逃逸字符"><a href="#逃逸字符" class="headerlink" title="逃逸字符"></a>逃逸字符</h4><p>用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠“&quot;开头，后面跟上另一个字符，这两个字符合起来，组成了一个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>（<span class="hljs-string">&quot;请分别输入身高的英尺和英寸，</span><br><span class="hljs-string">&quot;</span>如输入\<span class="hljs-string">&quot;57\&quot;表示5英尺7英寸：&quot;</span>）；<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aseprite-快捷键</title>
      <link href="/2019/11/01/2019/aseprite-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/11/01/2019/aseprite-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="aseprite-快捷键"><a href="#aseprite-快捷键" class="headerlink" title="aseprite-快捷键"></a>aseprite-快捷键</h1><h4 id="1-pen-tool"><a href="#1-pen-tool" class="headerlink" title="1.pen tool"></a>1.pen tool</h4><p>[B]、pixel-perfect :避免像素多个累计 (p.s.产生锯齿状的线条、Symmetry Options:对称选项(view-Symmetry Options)</p><p>simple ink(简单墨水)/alpha compsiting(透明度)<br><img src="/images/1.png"></p><h4 id="2-Line-tool"><a href="#2-Line-tool" class="headerlink" title="2.Line tool"></a>2.Line tool</h4><p>直线：[L]、[shift]/[ctrl]</p><p>曲线：[L]+[SHIFT]</p><h4 id="3-Shape-tool"><a href="#3-Shape-tool" class="headerlink" title="3.Shape tool"></a>3.Shape tool</h4><p>[U]、[shift]+[U]椭圆、按住[shift]画正圆</p><h4 id="4-Contour"><a href="#4-Contour" class="headerlink" title="4.Contour"></a>4.Contour</h4><p>[D]、[shift]+[D]多边形工具</p><h4 id="5-Mouse"><a href="#5-Mouse" class="headerlink" title="5. Mouse"></a>5. Mouse</h4><p>左键绘图、右键清除(mask)、中键拖动画布、[block]+左键拖动画布</p><h4 id="6-Eraser"><a href="#6-Eraser" class="headerlink" title="6.Eraser"></a>6.Eraser</h4><p>[E]</p><h4 id="7-Eyedropper"><a href="#7-Eyedropper" class="headerlink" title="7.Eyedropper"></a>7.Eyedropper</h4><p>[Alt]</p><h4 id="8-Paint-Bucket"><a href="#8-Paint-Bucket" class="headerlink" title="8.Paint Bucket"></a>8.Paint Bucket</h4><p>[G]、contiguous(连续):替换所有一样的颜色</p><h4 id="9-Selection"><a href="#9-Selection" class="headerlink" title="9.Selection"></a>9.Selection</h4><p>[M]选择工具 or [W]魔术棒(contiguous)</p><p>取消选定[ctrl]+[D]</p><h4 id="10-layer"><a href="#10-layer" class="headerlink" title="10.layer"></a>10.layer</h4><p>[Tap]、创建图层[shift]+[N]、新建图层[crtl]+[N]</p><p>右键-remove删除图层、右键-duplicate复制图层</p><h4 id="11-Palette-Editor-调色板"><a href="#11-Palette-Editor-调色板" class="headerlink" title="11.Palette Editor(调色板)"></a>11.Palette Editor(调色板)</h4><p>[F4]</p><h4 id="12-Sorting-Palette-分类面板"><a href="#12-Sorting-Palette-分类面板" class="headerlink" title="12.Sorting Palette(分类面板)"></a>12.Sorting Palette(分类面板)</h4><p>箭头<br><img src="/images/2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>太宰治《奔跑吧!梅洛斯》</title>
      <link href="/2019/10/23/2019/%E5%A5%94%E8%B7%91%E5%90%A7!%E6%A2%85%E6%B4%9B%E6%96%AF/"/>
      <url>/2019/10/23/2019/%E5%A5%94%E8%B7%91%E5%90%A7!%E6%A2%85%E6%B4%9B%E6%96%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>人类最高级的浪漫 有两种</strong><br><strong>其中一种 莫过于面对未知也一往无前的勇气</strong><br><strong>另一种 是面对已知的悲剧也一往无前的勇气</strong>  </p><h3 id="太宰治《奔跑吧-梅洛斯》"><a href="#太宰治《奔跑吧-梅洛斯》" class="headerlink" title="太宰治《奔跑吧!梅洛斯》"></a>太宰治《奔跑吧!梅洛斯》</h3><blockquote><p>​    “到日落之前，还有一段时光。有人在等我。他毫不怀疑，坦然等着我。我是可以让人信赖的。一己的生死，无关紧要。说什么以死相酬，空话是没用的。我必须报答别⼈人对我的信赖，眼前只有一件事：奔跑吧，梅洛斯！”</p><p>“我今晚就要死了。我是为死而奔跑，为救出替代我的朋友而奔跑，为打败国王阴毒的奸谋而奔跑。”</p><p>   “是等待的人更痛苦呢，还是让人等待的人更痛苦呢。无论怎样，我已无需等待了，这才是痛苦的事。”</p></blockquote><h4 id="故事简介"><a href="#故事简介" class="headerlink" title="故事简介"></a>故事简介</h4><p>​    梅洛斯杯暴君抓住，要执行死刑，梅洛斯和暴君说，他可以赴死，但是请给他三天时间去完成妹妹的 婚礼，和家⼈人道别。以梅洛斯的朋友作为人质，如果在日落之前梅洛斯没能回来，暴君就处死他的朋友。 暴君不相信人与人之间的信任，断定梅洛斯⼀一定不会回来，答应了与他的约定。</p><p>​    将妹妹托付给姐夫，梅洛斯奔向刑场，欣然赴死。红⽇日尚未落下，梅洛斯倾尽全力奔跑，脑袋⼀一片空白。他忘掉了一切事情，只是以大的努力来奔跑。</p><p>​    他跑的越快，自己的生命结束得越快，但是就算这是后⼀一次奔跑，这是必死的⼀一次奔跑。地平线 上，太阳渐渐消失。当后一丝余晖将消逝之际，梅洛斯若疾风般冲进了刑场。</p><h4 id="相关歌曲"><a href="#相关歌曲" class="headerlink" title="相关歌曲"></a>相关歌曲</h4><h5 id="メロス-Melos"><a href="#メロス-Melos" class="headerlink" title="メロス   Melos"></a><em>メロス</em>   Melos</h5><p>歌手：<a href="https://music.163.com/artist?id=958003">水曜日のカンパネラ</a></p><p>网易云音乐播放地址：<a href="https://music.163.com/#/song?id=480517736">https://music.163.com/#/song?id=480517736</a> </p><p>沈みゆく太陽の10倍も速く          以西沉太阳的10倍速度</p><p>黒い風のように走ってった           在黑色的疾风中奔跑着</p><p>終コーナー回ったところで           在后的拐角处徘徊时</p><p>シラクスの塔楼が見えた               看到了了锡拉库斯的塔楼</p><p>走り出せメロス                               开始奔跑吧 梅洛斯</p><p>勝てるはずがない                           不可能胜利的</p><p>命の他何もない                               除了生命之外 什么都没有</p><p>走り出せメロス。                           开始奔跑吧 梅洛斯</p><p>どうせこれが後                               无论怎样 这是后一次了</p><p>神々も照覧あれ。                           诸神明鉴</p><h4 id="THE-LAST"><a href="#THE-LAST" class="headerlink" title="THE LAST"></a>THE LAST</h4><p>​        写这篇读书笔记(?是因为看了这篇文章，听了这首歌后便去拜读了太宰治的这篇文章，感受颇深，回味无穷。 <a href="https://m.weibo.cn/6515204261/4418239264253155">https://m.weibo.cn/6515204261/4418239264253155</a> </p><p>并且再次想起弹丸3绝望篇的那句话“你面对以希望为名的绝望微笑”。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>adobe软件简单介绍</title>
      <link href="/2019/10/23/2019/adobe%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/10/23/2019/adobe%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>PS （基础操作每个人都该会）<br>AE （做特效必须学，各种意义上的全能轴心王）<br>Ai （做矢量插图和3维模型必须学）<br>blender （学来做玩具和素材修改器）<br>houdini （程序化场景模组搭建）<br>MAYA （电影制作，特效制作的轴心）<br>3D max （室内，建筑设计）<br>Zbrush (模型雕刻)<br>Substance (程序化PBR材质，照片源材质编辑)<br>LightRoom （图片快速修正）<br>Cinema 4D （创意三维动画，MG） </p><p><img src="/images/adobe.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息编码</title>
      <link href="/2019/10/09/2019/%E4%BF%A1%E6%81%AF%E7%BC%96%E7%A0%81/"/>
      <url>/2019/10/09/2019/%E4%BF%A1%E6%81%AF%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="信息编码"><a href="#信息编码" class="headerlink" title="信息编码"></a>信息编码</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​       <strong>信息编码（Information Coding）</strong>是为了方便信息的存储、检索和使用，在进行信息处理时赋予信息元素以代码的过程。即用不同的代码与各种信息中的基本单位组成部分建立一一对应的关系。信息编码必须标准、系统化，设计合理的编码系统是关系信息管理系统生命力的重要因素。</p><h3 id="2-含义"><a href="#2-含义" class="headerlink" title="2.含义"></a>2.含义</h3><p>​        在通信理论中，编码是对原始信息符号按一定的数学规则所进行的变换。使编码的目的是要使信息能够在保证一定质量的条件下尽可能迅速地传输至信宿。</p><p>​        在通信中一般要解决两个问题：一是在不失真或允许一定程度失真的条件下，如何用尽可能少的符号来传递信息，这是信源编码问题；其次是在信道存在干扰的情况下，如何增加信号的抗干扰能力，同时又使信息传输率最大，这是信道编码问题。</p><p>​        信源编码定理（申农第一定理）给出了解决前一个问题的可能性，并同时给出了一种编码方法；有噪信道编码定理（申农第二定理）指出存在着这样的编码，它可使传输的错误概率接近于信道的容量，从而给出了解决后一问题的可能性。</p><p>​        因此，在通信中使用编码手段可以使失真和信道干扰的影响达到最小，同时能以接近信道容量的信息传输率来传送信息。</p><h3 id="3-功能"><a href="#3-功能" class="headerlink" title="3.功能"></a>3.功能</h3><p>(1).<strong>鉴别</strong> 编码是鉴别信息分类对象的唯一标识。</p><p>(2).<strong>分类</strong> 当分类对象按一定属性分类时，对每一类别设计一个编码，这时编码可以作为区分对象类别的标识。这种标识要求结构清晰，毫不含糊。</p><p>(3).<strong>排序</strong> 由于编码所有的符号都具有一定的顺序，因而可以方便地按此顺序进行排序。</p><p>(4)<strong>.专用含义</strong> 由于某种需要，当采用一些专用符号代表特定事物或概念时，编码就提供一定的专用含义，如某些分类对象的技术参数、性能指标等。</p><h3 id="4-目的"><a href="#4-目的" class="headerlink" title="4.目的"></a>4.目的</h3><p> 信息编码的目的在于为计算机中的数据与实际处理的信息之间建立联系，提高信息处理的效率。 </p><h3 id="5-基本原则"><a href="#5-基本原则" class="headerlink" title="5.基本原则"></a>5.基本原则</h3><p>信息编码的基本原则是在逻辑上要满足使用者的要求，又要适合于处理的需要；</p><p>结构易于理解和掌握；</p><p>要有广泛的适用性，易于扩充。</p><h3 id="6-代码类型"><a href="#6-代码类型" class="headerlink" title="6.代码类型"></a>6.代码类型</h3><p>​       一般应有的代码有两类，一类是有意义的代码，即赋予代码一定的实际意义，便于分类处理；一类是无意义的代码，仅仅是赋予信息元素唯一的代号，便于对信息的操作。常用的代码类型有：<br>（1）<strong>顺序码</strong>，即接信息元素的顺序依次编码；<br>（2）<strong>区间码</strong>，即用一代码区间代表某一信息组；<br>（3）<strong>记忆码</strong>，即能帮助联想记忆的代码。</p><p>​        信息的表现形式多种多样，因而编码的方案也非常多。例如：我国制定的包括一、二级汉字和常用符号的图形字符代码（GB 5007-85），日文、韩文等其他文字与符号的“大5码”（BIG 5），英文字符的“ASCII码”（American Standard Code for Information Interchange) 。</p><h3 id="7-系统设计"><a href="#7-系统设计" class="headerlink" title="7.系统设计"></a>7.系统设计</h3><p>(1)、<strong>确定系统目标</strong>：</p><p>​        A.根据系统的总目标确定PDM系统的信息内容，对企业与产品相关的数据与信息进行全面调查；</p><p>​        B.分析各类信息的性质、特征；</p><p>​        C.优化和重组信息分类；</p><p>​        D.统一定义信息名称，提供系统设计数据。</p><p> 主要有以下方面的信息：物料、设计文件（方案、计算书等）、工艺文件（工艺路线、工艺过程卡片等）、产品图纸、更改单等。</p><p> (2)、<strong>数据调查分析</strong>：<br>        a.<u>初步调查</u>：初步调查是对企业的基本情况进行调查，包括企业生产计划、生产类型、产品品种、产量、设备、工艺、生产能力、质量、成本、产品的稳定性、产品的发展趋势、库存、销售和服务情况等。<br>       b.<u>现状调查</u>：根据初步调查所确定的信息范围对企业现行的信息分类、编码情况和产品结构数据等进行深入的调查，收集全部应有单据、报表、台帐明细表、各类文件等。<br>       c.<u>特征分析</u>：对收集到的信息采用特征表的方法进行特征分析，对需要统一名称的或多名称的事物或概念、数据项和数据元统一定义。</p><p>(3)、<strong>确定清单</strong>：初步整理收集来的信息，列出清单或名称表，并尽可能使用文字、数字的代码进行描述。</p><p>(4)、<strong>制定编码规则</strong>：</p><p>​       每个信息均应有独立的代码，信息代码一般是由分类码和识别码组成的复合码。分类码是表示信息类别的代码，识别码是表示信息特征(如结构形状、材料、工艺等)的代码。<br>​       信息分类编码系统的结构一般采用十进分类法系统。十进分类法系统中，层次是以树的结构形式表示，各码位数字的位置依前一位而定，并用0～9数字表示，每个码位表达一个固定的含义。<br>​       为了保证代码正确的输入，对较长的代码和那些关键性的代码，应加校验码，以检查其输入、传输等操作而产生的错误。<br>​       不同类别的信息可以有不同的编码规则，对同一类信息采用等长编码。</p><p>(5)、<strong>建立编码系统</strong>：</p><p>​       选用实际应用中已经成熟的编码系统，尽量采用企业已存在的各种不同内容的信息代码（物料代码、产品代码和工装代码等），予以试套、调整和修改以变为本企业的信息编码系统。<br>(6)、<strong>验证</strong>：</p><p>​       编码系统形成后，应对编码系统进行试套验证、修改和补充，以确保编码系统的可靠性及适用性。</p><p>(7)、<strong>发布实施</strong>：</p><p>​       全部分类系统、编码系统和各种代码应按企业标准</p><p>(8)、<strong>结论</strong><br>       产品信息编码是离散型制造企业实施信息化的基础工作，它是实施PDM的前提，更是实施ERP的必要条件，对一个集团企业，如果其子公司业务相关联，不管是单地点或是多地点公司，都应当采用统一的编码体系。</p><p>​       科学设计一套编码体系是保障PDM/ERP成功的关键，在进行编码体系设计时，应当要有标准化人员、产品设计人员、采购人员、生产管理人员等人的共同参与，充分考虑好各独立子系统的需求，同时，更要考虑好各子系统编码的集成，以免产生新的系统孤岛。</p><h2 id="二-数值信息编码"><a href="#二-数值信息编码" class="headerlink" title="二.数值信息编码"></a>二.数值信息编码</h2><h3 id="1-进制"><a href="#1-进制" class="headerlink" title="1.进制"></a>1.进制</h3><p>​       <strong>进位制</strong>是一种记数方式，亦称<strong>进位计数法</strong>或<strong>位值计数法</strong>。</p><p>​       利用这种记数法，可以使用有限种数字符号来表示所有的数值。一种进位制中可以使用的数字符号的数目称为这种进位制的基数或底数。若一个进位制的基数为n，即可称之为n进位制，简称n进制。</p><p>​       现在最常用的进位制是十进制，这种进位制通常使用10个阿拉伯数字（即0-9）进行记数。</p><h4 id="（1）-常见进位制及其用途"><a href="#（1）-常见进位制及其用途" class="headerlink" title="（1）.常见进位制及其用途"></a>（1）.常见进位制及其用途</h4><table><thead><tr><th><strong>底</strong>/<strong>基数</strong></th><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><a href="https://zh.wikipedia.org/wiki/2">2</a></td><td><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a></td><td>几乎所有的<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F">计算机</a>内部都使用二进位制，分别为“0”和“1”表示关和开。用于大多数<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E6%95%B0%E5%99%A8">电子计数器</a>。</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/6">6</a></td><td><a href="https://zh.wikipedia.org/wiki/%E5%85%AD%E8%BF%9B%E5%88%B6">六进制</a></td><td>6是2和3的乘积，在<a href="https://zh.wikipedia.org/wiki/%E9%AA%B0%E5%AD%90">骰子</a>常用，它表示三个的“对”或两个的“三个群”，在<a href="https://zh.wikipedia.org/wiki/%E9%AA%B0%E5%AD%90">骰子</a>常用。六位数字为“0-5”。</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/8">8</a></td><td><a href="https://zh.wikipedia.org/wiki/%E5%85%AB%E8%BF%9B%E5%88%B6">八进制</a></td><td>偶尔用于计算机领域，2到3次幂。八位数字为“0-7”。</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/10">10</a></td><td><a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E8%BF%9B%E5%88%B6">十进制</a></td><td>世界上最常见的算术运算位进制系统，它是<a href="https://zh.wikipedia.org/wiki/2">2</a>和<a href="https://zh.wikipedia.org/wiki/5">5</a>的<a href="https://zh.wikipedia.org/wiki/%E4%B9%98%E7%A7%AF">乘积</a>，用于大多数机械计数器。其十位数字为 “0-9”。</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/12">12</a></td><td><a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E4%BA%8C%E8%BF%9B%E5%88%B6">十二进制</a></td><td>因为有多个约数如2，<a href="https://zh.wikipedia.org/wiki/3">3</a>，<a href="https://zh.wikipedia.org/wiki/4">4</a>和<a href="https://zh.wikipedia.org/wiki/6">6</a>的易于整除性，它传统上用以表示数量和总数，如一打即为十二个单位。十二位数字为“0-9”，接着是“A”和“B”。</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/16">16</a></td><td><a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6">十六进制</a></td><td>经常用于计算机领域，2到4次<a href="https://zh.wikipedia.org/wiki/%E5%86%AA">幂</a>。十六位数字为“0-9”，接着是“A-F”。</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/20">20</a></td><td><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8D%81%E8%BF%9B%E5%88%B6">二十进制</a></td><td>因为有多个约数如2，<a href="https://zh.wikipedia.org/wiki/4">4</a>，<a href="https://zh.wikipedia.org/wiki/5">5</a>和<a href="https://zh.wikipedia.org/wiki/10">10</a>的易于整除性，在几种传统文化中的数字系统，仍然被用于计数。二十位数字为“0-9”，接着是“A-J”。</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/60">60</a></td><td><a href="https://zh.wikipedia.org/wiki/%E5%85%AD%E5%8D%81%E9%80%B2%E5%88%B6">六十进制</a></td><td>起源于古代苏美尔并传给巴比伦人。六十成为3,4和5的乘积。今天用作现代<a href="https://zh.wikipedia.org/wiki/%E5%9C%93%E5%BD%A2">圆形</a><a href="https://zh.wikipedia.org/wiki/%E5%9D%90%E6%A8%99%E7%B3%BB">坐标系</a>（度，分，秒）和<a href="https://zh.wikipedia.org/wiki/%E6%99%82%E9%96%93">时间</a><a href="https://zh.wikipedia.org/wiki/%E6%B8%AC%E9%87%8F">测量</a>（小时，分钟和秒）的基础。</td></tr></tbody></table><h4 id="（2）各进制介绍"><a href="#（2）各进制介绍" class="headerlink" title="（2）各进制介绍"></a>（2）各进制介绍</h4><h5 id><a href="#" class="headerlink" title></a></h5><h5 id="A-十进制"><a href="#A-十进制" class="headerlink" title="A.十进制"></a>A.十进制</h5><p>​       人类天然选择了十进制。</p><p>​       由于人类解剖学的特点，双手共有十根手指，故在人类自发采用的进位制中，十进制是使用最为普遍的一种。成语“屈指可数”某种意义上来说描述了一个简单计数的场景，而原始人类在需要计数的时候，首先想到的就是利用天然的算筹——手指来进行计数。</p><p>​       十进制编码几乎就是数值本身。</p><p>​       数值本身是一个数学上的抽象概念。经过长期的演化、融合、选择、淘汰，系统简便、功能全面的十进制计数法成为人类文化中主流的计数方法，经过基础教育的训练，大多数的人从小就掌握了十进制计数方法。盘中放了十个苹果，通过数苹果我们抽象出来“十”这一数值，它在我们的脑海中就以“10”这一十进制编码的形式存放和显示，而不是其它的形式。从这一角度来说，十进制编码几乎就是数值本身。</p><p>​       十进制的基数为10，数码由0-9组成，计数规律逢十进一。</p><h5 id="B-二进制"><a href="#B-二进制" class="headerlink" title="B.二进制"></a>B.二进制</h5><p>​       二进制有两个特点：它由两个数码0，1组成，二进制数运算规律是逢二进一。</p><p>​       为区别于其它进制，二进制数的书写通常在数的右下方注上基数2，或加后面加B表示，其中B是英文二进制Binary的首字母。</p><p>​       <strong>二进制具有以下优点：</strong></p><p>​       1） 二进制数中只有两个数码0和1，可用具有两个不同稳定状态的元器件来表示一位数码。例如，电路中某一通路的电流的有无，某一节点电压的高低，晶体管的导通和截止等。</p><p>​       2） 二进制数运算简单，大大简化了计算中运算部件的结构。</p><p>​       二进制数的加法和乘法基本运算法则各有四条，如下：</p><p>0+0=0，0+1=1，1+0=1，1+1=10</p><p>0×0=0，0×1=0，1×0=0，1×1=1</p><p>​       3）二进制天然兼容逻辑运算。</p><p>​       但是，二进制计数在日常使用上有个不便之处，就是位数往往很长，读写不便，如：把十进制的100000D写成二进制就是11000011010100000B，所以计算机领域我们实际采用的是十六进制。</p><p>​       二进制数转换为十六进制数时，长度缩减为原先的约四分之一，把十进制的100000写成八进制就是303240。十六进制的一个数位可代表二进制的四个数位。这样，十进制的100000写成十六进制就是186A0。</p><h5 id="C-四进制"><a href="#C-四进制" class="headerlink" title="C.四进制"></a>C.四进制</h5><p>​       四进制是以4为基数的进位制，以 0、1、2 和 3 四个数字表示任何实数。 　</p><p>​       四进制与所有固定基数的计数系统有着很多共同的属性，比如以标准的形式表示任何实数的能力（近乎独特），以及表示有理数与<a href="https://baike.baidu.com/item/%E6%97%A0%E7%90%86%E6%95%B0">无理数</a>的特性。</p><p>​       有关属性的讨论可参考十进制和二进制，下面是十进制0至15与四进制与二进制的互换。</p><h5 id="D-八进制"><a href="#D-八进制" class="headerlink" title="D.八进制"></a>D.八进制</h5><p>​       由于二进制数据的基数R较小，所以二进制数据的书写和阅读不方便，为此，在小型机中引入了八进制。八进制的基数R=8=2^3，有数码0、1、2、3、4、5、6、7，并且每个数码正好对应三位二进制数，所以八进制能很好地反映二进制。</p><p>​       八进制用下标8或数据后面加O表示 例如：二进制数据 （ 11 101 010 . 010 110 100 ）2 对应八进制数据 (352.264)8或352.264O。</p><h5 id="E-十六进制"><a href="#E-十六进制" class="headerlink" title="E.十六进制"></a>E.十六进制</h5><p>​       由于二进制数在使用中<a href="https://baike.baidu.com/item/%E4%BD%8D%E6%95%B0">位数</a>太长，不容易记忆，所以又提出了十六进制数。</p><p>​       十六进制数有两个基本特点：它由十六个数码：数字0～9加上字母A-F组成（它们分别表示<a href="https://baike.baidu.com/item/%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0">十进制数</a>10～15），十六进制数运算规律是逢十六进一，即基数R=16=2^4，通常在表示时用尾部标志H或下标16以示区别，在c语言中用添加前缀0x以表示十六进制数。</p><p>​       例如：十六进制数4AC8可写成（4AC8）16，或写成4AC8H。</p><h4 id="3-位权概念"><a href="#3-位权概念" class="headerlink" title="(3) 位权概念"></a>(3) 位权概念</h4><p>​       对于形式化的进制表示，我们可以从0开始，对数字的各个数位进行编号，即个位起往左依次为编号0，1，2，……；对称的，从小数点后的数位则是-1，-2，……</p><p>​       进行进制转换时，我们不妨设源进制（转换前所用进制）的基为R1，目标进制（转换后所用进制）的基为R2，原数值的表示按数位为AnA(n-1）……A2A1A0.A-1A-2……，R1在R2中的表示为R，则有（AnA(n-1）……A2A1A0.A-1A-2……）R1=(An<em>R^n+A(n-1)<em>R^(n-1)+……+A2</em>R^2+A1</em>R^1+A0<em>R^0+A-1</em>R^(-1)+A-2*R^(-2))R2</p><p>​       （由于此处不可选择字体，说明如下：An，A2，A-1等符号中，n，2，-1等均应改为下标，而上标的幂次均用^作为前缀）</p><p>举例：</p><p>​       一个十进制数110，其中百位上的1表示1个10^2，既100，十位的1表示1个10^1，即10，个位的0表示0个10^0，即0。</p><p>​       一个二进制数110，其中高位的1表示1个2^2，即4，低位的1表示1个2^1，即2，最低位的0表示0个2^0，即0。</p><p>​       一个十六进制数110，其中高位的1表示1个16^2，即256，低位的1表示1个16^1，即16，最低位的0表示0个16^0，即0。</p><p>​       可见，在数制中，各位数字所表示值的大小不仅与该数字本身的大小有关，还与该数字所在的位置有关，我们称这关系为数的位权。</p><p>​       十进制数的位权是以10为底的幂，二进制数的位权是以2为底的幂，十六进制数的位权是以16为底的幂。数位由高向低，以降幂的方式排列。</p><h4 id="4-进数转换"><a href="#4-进数转换" class="headerlink" title="(4)进数转换"></a>(4)进数转换</h4><p><strong>1.二进制数、十六进制数转换为<a href="https://baike.baidu.com/item/%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0">十进制数</a>（按权求和）</strong></p><p>​       二进制数、十六进制数转换为十进制数的规律是相同的。把二进制数（或十六进制数）按位权形式展开<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%A1%B9%E5%BC%8F">多项式</a>和的形式，求其最后的和，就是其对应的十进制数——简称“按权求和”.</p><p>例如：把（1001.01)2 二进制计算。</p><p>解：（1001.01）2</p><p>=8<em>1+4</em>0+2<em>0+1</em>1+0*(1/2)+1*(1/4)</p><p>=8+0+0+1+0+0.25</p><p>=9.25</p><p>把（38A.11)16转换为十进制数</p><p>解：（38A.11)16</p><p>=3×16的2次方+8×16的1次方+10×16的0次方+1×16的-1次方+1×16的-2次方</p><p>=768+128+10+0.0625+0.0039</p><p>=906.0664</p><p><strong>2.<a href="https://baike.baidu.com/item/%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0">十进制数</a>转换为二进制数，十六进制数（除2/16取余法）</strong></p><p>​       <a href="https://baike.baidu.com/item/%E6%95%B4%E6%95%B0">整数</a>转换.一个十进制整数转换为二进制整数通常采用除二取余法，即用2连续除十进制数，直到商为0，<a href="https://baike.baidu.com/item/%E9%80%86%E5%BA%8F">逆序</a>排列余数即可得到――简称除二取余法．</p><p>例：将25转换为二进制数</p><p>解：25÷2=12 余数1</p><p>12÷2=6 余数0</p><p>6÷2=3 余数0</p><p>3÷2=1 <a href="https://baike.baidu.com/item/%E4%BD%99%E6%95%B0">余数</a>1</p><p>1÷2=0 余数1</p><p>所以25=(11001)2</p><p>同理，把<a href="https://baike.baidu.com/item/%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0">十进制数</a>转换为十六进制数时，将基数2转换成16就可以了.</p><p>例：将25转换为十六进制数</p><p>解：25÷16=1 余数9</p><p>1÷16=0 余数1</p><p>所以25=(19)16</p><p><strong>3.二进制数与十六进制数之间的转换</strong></p><p>​       由于4位二进制数恰好有16个组合状态，即1位十六进制数与4位二进制数是一一对应的.所以，十六进制数与二进制数的转换是十分简单的.</p><p>​       (1）十六进制数转换成二进制数，只要将每一位十六进制数用对应的4位二进制数替代即可――简称位分四位.</p><p>例：将（4AF8B)16转换为二进制数.</p><p>解： 4 A F 8 B</p><p>0100 1010 1111 1000 1011</p><p>所以（4AF8B)16=(1001010111110001011)2</p><p>​       (2）二进制数转换为十六进制数，分别向左，向右每四位一组，依次写出每组4位二进制数所对应的十六进制数――简称四位合一位.</p><p>例：将二进制数（000111010110)2转换为十六进制数.</p><p>解： 0001 1101 0110</p><p>1 D 6</p><p>所以（111010110)2=（1D6）16</p><p>转换时注意最后一组不足4位时必须加0补齐4位</p><p><strong>数制转换的一般化</strong></p><p><strong>1）R进制转换成十进制</strong></p><p>任意R进制数据按权展开、相加即可得<a href="https://baike.baidu.com/item/%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0">十进制数</a>据。例如：N = 1101.0101B = 1<em>2^3+1</em>2^2+0<em>2^1+1</em>2^0+0<em>2^-1+1</em>2^-2+0<em>2^-3+1</em>2^-4 = 8+4+0+1+0+0.25+0+0.0625 = 13.3125</p><p>N = 5A.8H = 5<em>16^1+A</em>16^0+8*16^-1 = 80+10+0.5 = 90.5</p><p><strong>2）十进制转换R 进制</strong></p><p>十进制数转换成R 进制数，须将<a href="https://baike.baidu.com/item/%E6%95%B4%E6%95%B0%E9%83%A8%E5%88%86">整数部分</a>和<a href="https://baike.baidu.com/item/%E5%B0%8F%E6%95%B0">小数</a>部分分别转换.</p><p><strong>1.整数转换———除R 取余法</strong> 规则：</p><p>​       （1）用R 去除给出的十进制数的整数部分，取其余数作为转换后的R 进制数据的整数部分最低位数字； </p><p>​       （2）再用R去除所得的商，取其余数作为转换后的R 进制数据的高一位数字； </p><p>​       （3）重复执行（2）操作，一直到商为0结束。例如：115 转换成 Binary数据和Hexadecimal数据  所以 115 = 1110011 B = 73 H</p><p><strong>2．<a href="https://baike.baidu.com/item/%E5%B0%8F%E6%95%B0">小数</a>转换—————乘R 取整法</strong> 规则：</p><p>​       （1）用R 去乘给出的<a href="https://baike.baidu.com/item/%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0">十进制数</a>的小数部分，取乘积的<a href="https://baike.baidu.com/item/%E6%95%B4%E6%95%B0%E9%83%A8%E5%88%86">整数部分</a>作为转换后R 进制小数点后第一位数字； </p><p>​       （2）再用R 去乘上一步乘积的小数部分，然后取新乘积的整数部分作为转换后R 进制小数的低一位数字； </p><p>​       （3）重复（2）操作，一直到乘积为0，或已得到要求精度<a href="https://baike.baidu.com/item/%E6%95%B0%E4%BD%8D">数位</a>为止。</p><p><strong>3.小数转换——整数退位法：</strong>举例：0.321d转成二进制，由于321不是5的倍数，用取余法、取整法可能要算很久，这时候我们可以采用整数退位法。原理如下：</p><p>n为转成的二进制数的小数位数</p><p>(x)10=(y)2</p><p>(x)10<em>2^n=(y)2</em>2^n</p><p>D=(x)10*2^n：计算10进制数，取整</p><p>D→T转成2进制数</p><p>(y)2=T/2^n=T*2^(-n)，T退位，位数不足前端补零</p><p>举例:</p><p>0.321转成二进制数，保留7位</p><p>0.321*2^7=41.088,取整数41</p><p>41=32+8+1即100000+1000+1=101001</p><p>退位，因只有6位而要求保留7位，所以是0.0101001</p><p>用在线转换工具校验，正确</p><p><strong>and、or、xor运算</strong></p><p>所有进制的and（和）、or（或）、xor（异或）运算都要转化为二进制进行运算，然后对齐位数，进行运算，具体的运算方法和普通的and、or、xor相同，如：1and1=1，1and0=0，0and0=0，1or1=1，1or0=1，0or0=0，1xor1=0，1xor0=1，0xor0=0。就是一般的二进制运算。</p><p>如：35（H）and5（O）=110101（B）and101（B）=101（B）=5（O）</p><h2 id="三-ASCII"><a href="#三-ASCII" class="headerlink" title="三. ASCII"></a>三. ASCII</h2><p><strong>ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）</strong>是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。</p><p>它是最通用的信息交换标准，并等同于国际标准ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符。</p><h3 id="1-产生原因"><a href="#1-产生原因" class="headerlink" title="(1) 产生原因"></a>(1) 产生原因</h3><p>​      在计算机中，所有的数据在存储和运算时都要使用二进制数表示（因为计算机用高电平和低电平分别表示1和0），例如，像a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常用的符号（例如*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码），而大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了ASCII编码，统一规定了上述常用符号用哪些二进制数来表示 [2]  。<br>​      美国标准信息交换代码是由美国国家标准学会(American National Standard Institute , ANSI )制定的，是一种标准的单字节字符编码方案，用于基于文本的数据。它最初是美国国家标准，供不同计算机在相互通信时用作共同遵守的西文字符编码标准，后来它被国际标准化组织（International Organization for Standardization, ISO）定为国际标准，称为ISO 646标准。适用于所有拉丁文字字母 。</p><h3 id="2-表达方式"><a href="#2-表达方式" class="headerlink" title="(2) 表达方式"></a>(2) 表达方式</h3><p>​      ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符 [1]  。</p><p>其中：<br>      <strong>0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符）</strong>，如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响 [1]  。<br>      32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。<br>      65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。<br>同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位。</p><p>​      所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。</p><p>​      奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1 [1]  。<br>​      后128个称为扩展ASCII码。许多基于x86的系统都支持使用扩展（或“高”）ASCII。扩展ASCII 码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号 [1]  。</p><h3 id="3-标准表"><a href="#3-标准表" class="headerlink" title="(3)标准表"></a>(3)标准表</h3><p>ASCII码表具体如下所示:</p><table><thead><tr><th>Bin(二进制)</th><th>Oct(八进制)</th><th>Dec(十进制)</th><th>Hex(十六进制)</th><th>缩写/字符</th><th>解释</th></tr></thead><tbody><tr><td>0000 0000</td><td>00</td><td>0</td><td>0x00</td><td>NUL(null)</td><td>空字符</td></tr><tr><td>0000 0001</td><td>01</td><td>1</td><td>0x01</td><td>SOH(start of headline)</td><td>标题开始</td></tr><tr><td>0000 0010</td><td>02</td><td>2</td><td>0x02</td><td>STX (start of text)</td><td>正文开始</td></tr><tr><td>0000 0011</td><td>03</td><td>3</td><td>0x03</td><td>ETX (end of text)</td><td>正文结束</td></tr><tr><td>0000 0100</td><td>04</td><td>4</td><td>0x04</td><td>EOT (end of transmission)</td><td>传输结束</td></tr><tr><td>0000 0101</td><td>05</td><td>5</td><td>0x05</td><td>ENQ (enquiry)</td><td>请求</td></tr><tr><td>0000 0110</td><td>06</td><td>6</td><td>0x06</td><td>ACK (acknowledge)</td><td>收到通知</td></tr><tr><td>0000 0111</td><td>07</td><td>7</td><td>0x07</td><td>BEL (bell)</td><td>响铃</td></tr><tr><td>0000 1000</td><td>010</td><td>8</td><td>0x08</td><td>BS (backspace)</td><td>退格</td></tr><tr><td>0000 1001</td><td>011</td><td>9</td><td>0x09</td><td>HT (horizontal tab)</td><td>水平制表符</td></tr><tr><td>0000 1010</td><td>012</td><td>10</td><td>0x0A</td><td>LF (NL line feed, new line)</td><td>换行键</td></tr><tr><td>0000 1011</td><td>013</td><td>11</td><td>0x0B</td><td>VT (vertical tab)</td><td>垂直制表符</td></tr><tr><td>0000 1100</td><td>014</td><td>12</td><td>0x0C</td><td>FF (NP form feed, new page)</td><td>换页键</td></tr><tr><td>0000 1101</td><td>015</td><td>13</td><td>0x0D</td><td>CR (carriage return)</td><td>回车键</td></tr><tr><td>0000 1110</td><td>016</td><td>14</td><td>0x0E</td><td>SO (shift out)</td><td>不用切换</td></tr><tr><td>0000 1111</td><td>017</td><td>15</td><td>0x0F</td><td>SI (shift in)</td><td>启用切换</td></tr><tr><td>0001 0000</td><td>020</td><td>16</td><td>0x10</td><td>DLE (data link escape)</td><td>数据链路转义</td></tr><tr><td>0001 0001</td><td>021</td><td>17</td><td>0x11</td><td>DC1 (device control 1)</td><td>设备控制1</td></tr><tr><td>0001 0010</td><td>022</td><td>18</td><td>0x12</td><td>DC2 (device control 2)</td><td>设备控制2</td></tr><tr><td>0001 0011</td><td>023</td><td>19</td><td>0x13</td><td>DC3 (device control 3)</td><td>设备控制3</td></tr><tr><td>0001 0100</td><td>024</td><td>20</td><td>0x14</td><td>DC4 (device control 4)</td><td>设备控制4</td></tr><tr><td>0001 0101</td><td>025</td><td>21</td><td>0x15</td><td>NAK (negative acknowledge)</td><td>拒绝接收</td></tr><tr><td>0001 0110</td><td>026</td><td>22</td><td>0x16</td><td>SYN (synchronous idle)</td><td>同步空闲</td></tr><tr><td>0001 0111</td><td>027</td><td>23</td><td>0x17</td><td>ETB (end of trans. block)</td><td>结束传输块</td></tr><tr><td>0001 1000</td><td>030</td><td>24</td><td>0x18</td><td>CAN (cancel)</td><td>取消</td></tr><tr><td>0001 1001</td><td>031</td><td>25</td><td>0x19</td><td>EM (end of medium)</td><td>媒介结束</td></tr><tr><td>0001 1010</td><td>032</td><td>26</td><td>0x1A</td><td>SUB (substitute)</td><td>代替</td></tr><tr><td>0001 1011</td><td>033</td><td>27</td><td>0x1B</td><td>ESC (escape)</td><td>换码(溢出)</td></tr><tr><td>0001 1100</td><td>034</td><td>28</td><td>0x1C</td><td>FS (file separator)</td><td>文件分隔符</td></tr><tr><td>0001 1101</td><td>035</td><td>29</td><td>0x1D</td><td>GS (group separator)</td><td>分组符</td></tr><tr><td>0001 1110</td><td>036</td><td>30</td><td>0x1E</td><td>RS (record separator)</td><td>记录分隔符</td></tr><tr><td>0001 1111</td><td>037</td><td>31</td><td>0x1F</td><td>US (unit separator)</td><td>单元分隔符</td></tr><tr><td>0010 0000</td><td>040</td><td>32</td><td>0x20</td><td>(space)</td><td>空格</td></tr><tr><td>0010 0001</td><td>041</td><td>33</td><td>0x21</td><td>!</td><td>叹号</td></tr><tr><td>0010 0010</td><td>042</td><td>34</td><td>0x22</td><td>“</td><td>双引号</td></tr><tr><td>0010 0011</td><td>043</td><td>35</td><td>0x23</td><td>#</td><td>井号</td></tr><tr><td>0010 0100</td><td>044</td><td>36</td><td>0x24</td><td>$</td><td>美元符</td></tr><tr><td>0010 0101</td><td>045</td><td>37</td><td>0x25</td><td>%</td><td>百分号</td></tr><tr><td>0010 0110</td><td>046</td><td>38</td><td>0x26</td><td>&amp;</td><td>和号</td></tr><tr><td>0010 0111</td><td>047</td><td>39</td><td>0x27</td><td>‘</td><td>闭单引号</td></tr><tr><td>0010 1000</td><td>050</td><td>40</td><td>0x28</td><td>(</td><td>开括号</td></tr><tr><td>0010 1001</td><td>051</td><td>41</td><td>0x29</td><td>)</td><td>闭括号</td></tr><tr><td>0010 1010</td><td>052</td><td>42</td><td>0x2A</td><td>*</td><td>星号</td></tr><tr><td>0010 1011</td><td>053</td><td>43</td><td>0x2B</td><td>+</td><td>加号</td></tr><tr><td>0010 1100</td><td>054</td><td>44</td><td>0x2C</td><td>,</td><td>逗号</td></tr><tr><td>0010 1101</td><td>055</td><td>45</td><td>0x2D</td><td>-</td><td>减号/破折号</td></tr><tr><td>0010 1110</td><td>056</td><td>46</td><td>0x2E</td><td>.</td><td>句号</td></tr><tr><td>0010 1111</td><td>057</td><td>47</td><td>0x2F</td><td>/</td><td>斜杠</td></tr><tr><td>0011 0000</td><td>060</td><td>48</td><td>0x30</td><td>0</td><td>字符0</td></tr><tr><td>0011 0001</td><td>061</td><td>49</td><td>0x31</td><td>1</td><td>字符1</td></tr><tr><td>0011 0010</td><td>062</td><td>50</td><td>0x32</td><td>2</td><td>字符2</td></tr><tr><td>0011 0011</td><td>063</td><td>51</td><td>0x33</td><td>3</td><td>字符3</td></tr><tr><td>0011 0100</td><td>064</td><td>52</td><td>0x34</td><td>4</td><td>字符4</td></tr><tr><td>0011 0101</td><td>065</td><td>53</td><td>0x35</td><td>5</td><td>字符5</td></tr><tr><td>0011 0110</td><td>066</td><td>54</td><td>0x36</td><td>6</td><td>字符6</td></tr><tr><td>0011 0111</td><td>067</td><td>55</td><td>0x37</td><td>7</td><td>字符7</td></tr><tr><td>0011 1000</td><td>070</td><td>56</td><td>0x38</td><td>8</td><td>字符8</td></tr><tr><td>0011 1001</td><td>071</td><td>57</td><td>0x39</td><td>9</td><td>字符9</td></tr><tr><td>0011 1010</td><td>072</td><td>58</td><td>0x3A</td><td>:</td><td>冒号</td></tr><tr><td>0011 1011</td><td>073</td><td>59</td><td>0x3B</td><td>;</td><td>分号</td></tr><tr><td>0011 1100</td><td>074</td><td>60</td><td>0x3C</td><td>&lt;</td><td>小于</td></tr><tr><td>0011 1101</td><td>075</td><td>61</td><td>0x3D</td><td>=</td><td>等号</td></tr><tr><td>0011 1110</td><td>076</td><td>62</td><td>0x3E</td><td>&gt;</td><td>大于</td></tr><tr><td>0011 1111</td><td>077</td><td>63</td><td>0x3F</td><td>?</td><td>问号</td></tr><tr><td>0100 0000</td><td>0100</td><td>64</td><td>0x40</td><td>@</td><td>电子邮件符号</td></tr><tr><td>0100 0001</td><td>0101</td><td>65</td><td>0x41</td><td>A</td><td>大写字母A</td></tr><tr><td>0100 0010</td><td>0102</td><td>66</td><td>0x42</td><td>B</td><td>大写字母B</td></tr><tr><td>0100 0011</td><td>0103</td><td>67</td><td>0x43</td><td>C</td><td>大写字母C</td></tr><tr><td>0100 0100</td><td>0104</td><td>68</td><td>0x44</td><td>D</td><td>大写字母D</td></tr><tr><td>0100 0101</td><td>0105</td><td>69</td><td>0x45</td><td>E</td><td>大写字母E</td></tr><tr><td>0100 0110</td><td>0106</td><td>70</td><td>0x46</td><td>F</td><td>大写字母F</td></tr><tr><td>0100 0111</td><td>0107</td><td>71</td><td>0x47</td><td>G</td><td>大写字母G</td></tr><tr><td>0100 1000</td><td>0110</td><td>72</td><td>0x48</td><td>H</td><td>大写字母H</td></tr><tr><td>0100 1001</td><td>0111</td><td>73</td><td>0x49</td><td>I</td><td>大写字母I</td></tr><tr><td>01001010</td><td>0112</td><td>74</td><td>0x4A</td><td>J</td><td>大写字母J</td></tr><tr><td>0100 1011</td><td>0113</td><td>75</td><td>0x4B</td><td>K</td><td>大写字母K</td></tr><tr><td>0100 1100</td><td>0114</td><td>76</td><td>0x4C</td><td>L</td><td>大写字母L</td></tr><tr><td>0100 1101</td><td>0115</td><td>77</td><td>0x4D</td><td>M</td><td>大写字母M</td></tr><tr><td>0100 1110</td><td>0116</td><td>78</td><td>0x4E</td><td>N</td><td>大写字母N</td></tr><tr><td>0100 1111</td><td>0117</td><td>79</td><td>0x4F</td><td>O</td><td>大写字母O</td></tr><tr><td>0101 0000</td><td>0120</td><td>80</td><td>0x50</td><td>P</td><td>大写字母P</td></tr><tr><td>0101 0001</td><td>0121</td><td>81</td><td>0x51</td><td>Q</td><td>大写字母Q</td></tr><tr><td>0101 0010</td><td>0122</td><td>82</td><td>0x52</td><td>R</td><td>大写字母R</td></tr><tr><td>0101 0011</td><td>0123</td><td>83</td><td>0x53</td><td>S</td><td>大写字母S</td></tr><tr><td>0101 0100</td><td>0124</td><td>84</td><td>0x54</td><td>T</td><td>大写字母T</td></tr><tr><td>0101 0101</td><td>0125</td><td>85</td><td>0x55</td><td>U</td><td>大写字母U</td></tr><tr><td>0101 0110</td><td>0126</td><td>86</td><td>0x56</td><td>V</td><td>大写字母V</td></tr><tr><td>0101 0111</td><td>0127</td><td>87</td><td>0x57</td><td>W</td><td>大写字母W</td></tr><tr><td>0101 1000</td><td>0130</td><td>88</td><td>0x58</td><td>X</td><td>大写字母X</td></tr><tr><td>0101 1001</td><td>0131</td><td>89</td><td>0x59</td><td>Y</td><td>大写字母Y</td></tr><tr><td>0101 1010</td><td>0132</td><td>90</td><td>0x5A</td><td>Z</td><td>大写字母Z</td></tr><tr><td>0101 1011</td><td>0133</td><td>91</td><td>0x5B</td><td>[</td><td>开方括号</td></tr><tr><td>0101 1100</td><td>0134</td><td>92</td><td>0x5C</td><td>\</td><td>反斜杠</td></tr><tr><td>0101 1101</td><td>0135</td><td>93</td><td>0x5D</td><td>]</td><td>闭方括号</td></tr><tr><td>0101 1110</td><td>0136</td><td>94</td><td>0x5E</td><td>^</td><td>脱字符</td></tr><tr><td>0101 1111</td><td>0137</td><td>95</td><td>0x5F</td><td>_</td><td>下划线</td></tr><tr><td>0110 0000</td><td>0140</td><td>96</td><td>0x60</td><td>`</td><td>开单引号</td></tr><tr><td>0110 0001</td><td>0141</td><td>97</td><td>0x61</td><td>a</td><td>小写字母a</td></tr><tr><td>0110 0010</td><td>0142</td><td>98</td><td>0x62</td><td>b</td><td>小写字母b</td></tr><tr><td>0110 0011</td><td>0143</td><td>99</td><td>0x63</td><td>c</td><td>小写字母c</td></tr><tr><td>0110 0100</td><td>0144</td><td>100</td><td>0x64</td><td>d</td><td>小写字母d</td></tr><tr><td>0110 0101</td><td>0145</td><td>101</td><td>0x65</td><td>e</td><td>小写字母e</td></tr><tr><td>0110 0110</td><td>0146</td><td>102</td><td>0x66</td><td>f</td><td>小写字母f</td></tr><tr><td>0110 0111</td><td>0147</td><td>103</td><td>0x67</td><td>g</td><td>小写字母g</td></tr><tr><td>0110 1000</td><td>0150</td><td>104</td><td>0x68</td><td>h</td><td>小写字母h</td></tr><tr><td>0110 1001</td><td>0151</td><td>105</td><td>0x69</td><td>i</td><td>小写字母i</td></tr><tr><td>0110 1010</td><td>0152</td><td>106</td><td>0x6A</td><td>j</td><td>小写字母j</td></tr><tr><td>0110 1011</td><td>0153</td><td>107</td><td>0x6B</td><td>k</td><td>小写字母k</td></tr><tr><td>0110 1100</td><td>0154</td><td>108</td><td>0x6C</td><td>l</td><td>小写字母l</td></tr><tr><td>0110 1101</td><td>0155</td><td>109</td><td>0x6D</td><td>m</td><td>小写字母m</td></tr><tr><td>0110 1110</td><td>0156</td><td>110</td><td>0x6E</td><td>n</td><td>小写字母n</td></tr><tr><td>0110 1111</td><td>0157</td><td>111</td><td>0x6F</td><td>o</td><td>小写字母o</td></tr><tr><td>0111 0000</td><td>0160</td><td>112</td><td>0x70</td><td>p</td><td>小写字母p</td></tr><tr><td>0111 0001</td><td>0161</td><td>113</td><td>0x71</td><td>q</td><td>小写字母q</td></tr><tr><td>0111 0010</td><td>0162</td><td>114</td><td>0x72</td><td>r</td><td>小写字母r</td></tr><tr><td>0111 0011</td><td>0163</td><td>115</td><td>0x73</td><td>s</td><td>小写字母s</td></tr><tr><td>0111 0100</td><td>0164</td><td>116</td><td>0x74</td><td>t</td><td>小写字母t</td></tr><tr><td>0111 0101</td><td>0165</td><td>117</td><td>0x75</td><td>u</td><td>小写字母u</td></tr><tr><td>0111 0110</td><td>0166</td><td>118</td><td>0x76</td><td>v</td><td>小写字母v</td></tr><tr><td>0111 0111</td><td>0167</td><td>119</td><td>0x77</td><td>w</td><td>小写字母w</td></tr><tr><td>0111 1000</td><td>0170</td><td>120</td><td>0x78</td><td>x</td><td>小写字母x</td></tr><tr><td>0111 1001</td><td>0171</td><td>121</td><td>0x79</td><td>y</td><td>小写字母y</td></tr><tr><td>0111 1010</td><td>0172</td><td>122</td><td>0x7A</td><td>z</td><td>小写字母z</td></tr><tr><td>0111 1011</td><td>0173</td><td>123</td><td>0x7B</td><td>{</td><td>开花括号</td></tr><tr><td>0111 1100</td><td>0174</td><td>124</td><td>0x7C</td><td>|</td><td>垂线</td></tr><tr><td>0111 1101</td><td>0175</td><td>125</td><td>0x7D</td><td>}</td><td>闭花括号</td></tr><tr><td>0111 1110</td><td>0176</td><td>126</td><td>0x7E</td><td>~</td><td>波浪号</td></tr><tr><td>0111 1111</td><td>0177</td><td>127</td><td>0x7F</td><td>DEL (delete)</td><td>删除</td></tr></tbody></table><h3 id="4-大小规则"><a href="#4-大小规则" class="headerlink" title="(4)大小规则"></a>(4)大小规则</h3><p>常见ASCII码的大小规则：0<del>9&lt;A</del>Z&lt;a~z。</p><p>​      1）数字比字母要小。如 “7”&lt;“F”；</p><p>​      2）数字0比数字9要小，并按0到9顺序递增。如 “3”&lt;“8” ；</p><p>​      3）字母A比字母Z要小，并按A到Z顺序递增。如“A”&lt;“Z” ；</p><p>​      4）同个字母的大写字母比小写字母要小32。如“A”&lt;“a” 。</p><p>几个常见字母的ASCII码大小： “A”为65；“a”为97；“0”为 48。</p><h3 id="5-问题"><a href="#5-问题" class="headerlink" title="(5)问题"></a>(5)问题</h3><p>​      在英语中，用128个符号编码便可以表示所有，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。</p><p>​      于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号 。<br>​      但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。<br>​      至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</p><h3 id="6-扩展"><a href="#6-扩展" class="headerlink" title="(6)扩展"></a>(6)扩展</h3><ol><li>1981年IBM PC ROM256个字符的字符集，即IBM扩展字符集 [5]  。</li><li>1985年11Windows字符集被称作“ANSI字符集”，遵循了ANSI草案和ISO标准（ANSI/ISO8859-1-1987，简“Latin 1” [5]  。</li><li>为了解决中国、日本和韩国的象形文字符和ASCII的某种兼容性，出现了双字节字符集（DBCS：double-byte character set）。DBCS从 第256 代码开始，就像ASCII一样，最初的128个代码是ASCII。然而，较高的128个代码中的某些总是跟随着第二个字节。这两个字节一起（称作首字节和跟随字节）定义一个字符，通常是一个复杂的象形文字 [6]  。</li></ol><h3 id="7-汉字编码"><a href="#7-汉字编码" class="headerlink" title="(7)汉字编码"></a>(7)汉字编码</h3><p>​      目前的文字编码标准主要有 ASCII、<a href="https://baike.baidu.com/item/GB2312/483170">GB2312</a>、<a href="https://baike.baidu.com/item/GBK/481954">GBK</a>、<a href="https://baike.baidu.com/item/Unicode/750500">Unicode</a>等。ASCII 编码是最简单的西文编码方案。GB2312、GBK、GB18030 是汉字字符编码方案的国家标准。ISO/IEC 10646 和 Unicode 都是全球字符编码的国际标准 [4] 。下面对与汉字相关的编码方案GB2312，GBK与GB18030做简要的分析。</p><h4 id="GB2312-80-标准"><a href="#GB2312-80-标准" class="headerlink" title="GB2312-80 标准"></a>GB2312-80 标准</h4><p>​      GB2312-80 是 1980 年制定的中国汉字编码国家标准。共收录 7445 个字符，其中汉字 6763 个。GB2312 兼容标准 ASCII码，采用扩展 ASCII 码的编码空间进行编码，一个汉字占用两个字节，每个字节的最高位为 1。具体办法是：收集了 7445 个字符组成 94*94 的方阵，每一行称为一个“区”，每一列称为一个“位”，区号位号的范围均为 01-94，区号和位号组成的代码称为“区位码”。</p><p>​      区位输入法就是通过输入区位码实现汉字输入的。将区号和位号分别加上 20H，得到的 4 位<a href="https://baike.baidu.com/item/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/4162457">十六进制</a>整数称为<a href="https://baike.baidu.com/item/%E5%9B%BD%E6%A0%87%E7%A0%81/9886729">国标码</a>，编码范围为 0x2121～0x7E7E。为了兼容标准 ASCII 码，给国标码的每个字节加 80H，形成的编码称为<a href="https://baike.baidu.com/item/%E6%9C%BA%E5%86%85%E7%A0%81/8481225">机内码</a>，简称内码，是汉字在机器中实际的存储代码GB2312-80 标准的内码范围是 0xA1A1～0xFEFE。</p><h4 id="GBK-编码标准"><a href="#GBK-编码标准" class="headerlink" title="GBK 编码标准"></a>GBK 编码标准</h4><p>​      《汉字内码扩展规范》(<a href="https://baike.baidu.com/item/GBK/481954">GBK</a>) 于1995年制定，兼容GB2312、GB13000-1、BIG5 编码中的所有汉字，使用双字节编码，编码空间为 0x8140～0xFEFE，共有 23940 个码位，其中 GBK1 区和 GBK2 区也是 GB2312 的编码范围。收录了 21003 个汉字。<a href="https://baike.baidu.com/item/GBK/481954">GBK</a>向下与 GB 2312 编码兼容，向上支持 ISO 10646.1<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86/4495981">国际标准</a>，是前者向后者过渡过程中的一个承上启下的产物。</p><p>​      ISO 10646 是<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87/779832">国际标准化组织</a>ISO 公布的一个编码标准，即 Universal Multilpe-Octet Coded Character Set（简称UCS），大陆译为《通用多八位编码字符集》，台湾译为《广用多八位元编码字元集》，它与 Unicode 组织的<a href="https://baike.baidu.com/item/Unicode/750500">Unicode</a>编码完全兼容。</p><p>​      ISO 10646.1 是该标准的第一部分《体系结构与基本多文种平面》。我国 1993 年以 GB 13000.1 国家标准的形式予以认可（即 GB 13000.1 等同于 ISO 10646.1） [7] 。</p><h4 id="GB18030编码标准"><a href="#GB18030编码标准" class="headerlink" title="GB18030编码标准"></a>GB18030编码标准</h4><p>​      目前的文字编码标准主要有 ASCII、GB2312、GBK、Unicode等。ASCII 编码是最简单的西文编码方案。GB2312、GBK、GB18030 是汉字字符编码方案的国家标准。</p><p>​      ISO/IEC 10646 和 Unicode 都是全球字符编码的国际标准 [4]  。下面对与汉字相关的编码方案GB2312，GBK与GB18030做简要的分析。</p><h4 id="GB2312-80-标准-1"><a href="#GB2312-80-标准-1" class="headerlink" title="GB2312-80 标准"></a>GB2312-80 标准</h4><p>​      GB2312-80 是 1980 年制定的中国汉字编码国家标准。共收录 7445 个字符，其中汉字 6763 个。GB2312 兼容标准 ASCII码，采用扩展 ASCII 码的编码空间进行编码，一个汉字占用两个字节，每个字节的最高位为 1。</p><p>​      具体办法是：收集了 7445 个字符组成 94*94 的方阵，每一行称为一个“区”，每一列称为一个“位”，区号位号的范围均为 01-94，区号和位号组成的代码称为“区位码”。区位输入法就是通过输入区位码实现汉字输入的。</p><p>​      将区号和位号分别加上 20H，得到的 4 位十六进制整数称为国标码，编码范围为 0x2121～0x7E7E。为了兼容标准 ASCII 码，给国标码的每个字节加 80H，形成的编码称为机内码，简称内码，是汉字在机器中实际的存储代码GB2312-80 标准的内码范围是 0xA1A1～0xFEFE [7]  。</p><h4 id="GBK-编码标准-1"><a href="#GBK-编码标准-1" class="headerlink" title="GBK 编码标准"></a>GBK 编码标准</h4><p>​      《汉字内码扩展规范》(GBK) 于1995年制定，兼容GB2312、GB13000-1、BIG5 编码中的所有汉字，使用双字节编码，编码空间为 0x8140～0xFEFE，共有 23940 个码位，其中 GBK1 区和 GBK2 区也是 GB2312 的编码范围。收录了 21003 个汉字。</p><p>​      GBK向下与 GB 2312 编码兼容，向上支持 ISO 10646.1国际标准，是前者向后者过渡过程中的一个承上启下的产物。ISO 10646 是国际标准化组织ISO 公布的一个编码标准，即 Universal Multilpe-Octet Coded Character Set（简称UCS），大陆译为《通用多八位编码字符集》，台湾译为《广用多八位元编码字元集》，它与 Unicode 组织的Unicode编码完全兼容。</p><p>​      ISO 10646.1 是该标准的第一部分《体系结构与基本多文种平面》。我国 1993 年以 GB 13000.1 国家标准的形式予以认可（即 GB 13000.1 等同于 ISO 10646.1） [7]  。</p><h4 id="GB18030编码标准-1"><a href="#GB18030编码标准-1" class="headerlink" title="GB18030编码标准"></a><strong>GB18030编码标准</strong></h4><p>​      国家标准GB18030-2000《信息交换用汉字编码字符集基本集的补充》是我国继GB2312-1980和GB13000-1993之后最重要的汉字编码标准，是我国计算机系统必须遵循的基础性标准之一。</p><p>​      GB18030-2000编码标准是由信息产业部和国家质量技术监督局在2000年 3月17日联合发布的，并且将作为一项国家标准在2001年的1月正式强制执行。</p><p>​      GB18030-2005《信息技术中文编码字符集》是我国制订的以汉字为主并包含多种我国少数民族文字（如藏、蒙古、傣、彝、朝鲜、维吾尔文等）的超大型中文编码字符集强制性标准，其中收入汉字70000余个 。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
