

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="编译原理笔记+部分课后题">
  <meta name="author" content="prinscarce">
  <meta name="keywords" content="">
  
  <title>编译原理笔记 - prinscarce</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"prinscarce.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>serendipity</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/bangumi/">
                <i class="iconfont icon-bilibili"></i>
                bangumi
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="编译原理笔记">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      prinscarce
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-06-14 22:36" pubdate>
        2022年6月14日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      78
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">编译原理笔记</h1>
            
            <div class="markdown-body">
              <h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><h2 id="老师给的重点"><a href="#老师给的重点" class="headerlink" title="老师给的重点"></a>老师给的重点</h2><h3 id="第一章-概念"><a href="#第一章-概念" class="headerlink" title="第一章 概念"></a>第一章 概念</h3><h3 id="第二章："><a href="#第二章：" class="headerlink" title="第二章："></a>第二章：</h3><ol>
<li>文字-&gt;正规式</li>
<li>词法分析器 由源程序输入，输出为记号</li>
<li>正规式的等价证明</li>
<li>:star:正规式-&gt;NFA-&gt;DFA-&gt;最小化</li>
</ol>
<h3 id="第三章："><a href="#第三章：" class="headerlink" title="第三章："></a>第三章：</h3><ol>
<li>上下文无关文法</li>
<li>自动机：下推自动机</li>
<li>自上而下分析构造预测分析表</li>
<li>为什么要消除左递归：避免死循环</li>
<li>自下而上：句柄</li>
<li>如何证明一个文法是二义文法(二义性??)：有两棵语法树</li>
<li>SLR1分析表</li>
</ol>
<h3 id="第四章："><a href="#第四章：" class="headerlink" title="第四章："></a>第四章：</h3><ol>
<li>语义规则的两种表达 综合分析</li>
<li>变量声明</li>
<li>参数传递</li>
<li>常用中间代码</li>
<li>三元式、四元式</li>
<li>注释语法树</li>
<li>语义-&gt;中间代码</li>
<li>声明语句的翻译</li>
<li>短路计算</li>
</ol>
<h2 id="CH1"><a href="#CH1" class="headerlink" title="CH1"></a>CH1</h2><p><strong>词法规则</strong>：单词符号的形成规则</p>
<p><strong>语法规则</strong>：语法单位的形成规则</p>
<h3 id="编译程序的五个阶段"><a href="#编译程序的五个阶段" class="headerlink" title="编译程序的五个阶段"></a><strong>编译程序的五个阶段</strong></h3><ul>
<li>词法分析：输入源程序，对其字符串进行扫描和分解，识别一个个单词（符号）</li>
<li>语法分析：根据语言的语法规则，将单词符号串分解成各类语法单位</li>
<li>语义分析与中间代码生成：对上面识别出的各类语法范畴分析其含义，并进行初步翻译（产生中间代码）</li>
<li>代码优化：对前段产生的中间代码进行加工变换，以求在最后阶段能产生更为高效的目标代码</li>
<li>目标代码生成：把中间代码变换成特定机器上的低级语言代码</li>
</ul>
<p><strong>编译程序的基本结构</strong>：</p>
<ul>
<li>表格管理：登记源程序中的各类信息的编译中各阶段的进展状况</li>
<li>出错处理：处理错误</li>
</ul>
<p><strong>编译的遍数</strong>：对源程序/其中间结果从头到尾扫描一次，并做有关的加工处理，生成新的中间结果或目标程序。</p>
<p>​    因素：源语言、设计要求、硬件设备</p>
<h4 id="课后填空："><a href="#课后填空：" class="headerlink" title="课后填空："></a>课后填空：</h4><ol>
<li>编译方式与解释方式的根本区别在于<code>是否生成目标代码</code> </li>
<li>从功能上说，程序语言的语句大体可分为 <code>执行性语句</code>  和 <code>说明性语句</code> 两大类。</li>
<li>扫描器的任务是从 <code>源程序</code> 识别出一个个 <code>单词符号</code> 。</li>
</ol>
<h4 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h4><ul>
<li><strong>编译程序</strong>：编译程序是指一种能够把某一种语言程序（源语言程序）转换成另一种语言程序（目标语言程序）的程序。</li>
<li><strong>语义</strong>：一种语言的单词符号和语法单位的意义。</li>
<li><strong>语法</strong>：任何语言程序都可以看成是一定字符集（称为字母表）上的一字符串（有限序列）。并且一个程序语言只使用一个有限字符集作为字母表。所谓一个语言的语法是指这样的一组规则，用它可以形成和产生一个合式的程序。</li>
<li><strong>遍</strong>：同上</li>
</ul>
<h4 id="简答题："><a href="#简答题：" class="headerlink" title="简答题："></a>简答题：</h4><ol>
<li><p><strong>编译程序在逻辑上由哪几部分组成</strong>？</p>
<p>词法分析，语法分析，语义分析，中间代码生成，中间代码优化和目标代码生成</p>
</li>
<li><p><strong>何谓编译的前端和后端</strong>？</p>
<p>前端主要由与源语言有关但与目标机无关的那部分组成。这些部分通常包括词法分析、语法分析、语义分析与中间代码产生，有的代码优化工作也可包括在前端。</p>
<p> 后端包括编译程序中与目标机有关的那些部分，如与目标机有关的代码优化和目标代码生成等。通常，后端不依赖于源语言而仅仅依赖于中间语言。</p>
</li>
<li><p><strong>画出编译程序的总体结构图，简述各部分的主要功能</strong>。</p>
</li>
</ol>
<p><img src="/images/compiler/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload></p>
<ol start="4">
<li><p><strong>试分析编译程序是否分遍应考虑的因素及多遍扫描编译程序的优缺点.</strong></p>
<p>决定趟程的因素：</p>
<ul>
<li>计算机存贮容量大小</li>
<li>编译程序功能强弱</li>
<li>源语言繁简</li>
<li>目标程序优化程度</li>
<li>设计和实现编译程序时使用工具的先进程度 </li>
<li>参加人员多少和素质</li>
</ul>
<p> 多遍扫描编译程序优点：</p>
<ul>
<li><p>加工充分</p>
</li>
<li><p>出错处理细致</p>
</li>
<li><p>目标程序质量高</p>
</li>
</ul>
<p>缺点：编译时间长，开销大。</p>
</li>
</ol>
<h2 id="CH2"><a href="#CH2" class="headerlink" title="CH2"></a>CH2</h2><p><strong>程序语言的记号</strong>：</p>
<ul>
<li>关键字：程序中有固定含义</li>
<li>标识符：变量名</li>
<li>字面量：直接写出的数据</li>
<li>运算符：op</li>
<li>分界符：标点符号</li>
</ul>
<p><strong>词法分析器的任务</strong>：</p>
<ul>
<li>识别各个单词符号，将其转换为内部编码形式</li>
<li>删除无用的空白符、回车及无用的非实质性字符</li>
<li>删除注释</li>
<li>进行词法检查，报告错误</li>
</ul>
<p><strong>工作方式</strong>：</p>
<ul>
<li>独立工作：单独进行一遍扫描，以源程序作为输入，以记号流作为输出</li>
<li>其作为子程序执行：当语法分析器需要记号时就调用词法分析器，得到一个识别出的记号</li>
<li>并行工作：提高编译效率，相当于“生产/消费”</li>
</ul>
<p><strong>工作过程</strong>：将预处理的源代码（去除注释、无用的空白符、跳格等）读入到输入缓冲区，然后读入固定长度的字符到扫描缓冲区，最后对扫描缓冲区进行符号识别</p>
<p><strong>语言</strong>：有限字母表Σ上有限长度的字符串的集合</p>
<p>字符串集合的运算：合并、连接、方幂、Kleene闭包（自反闭包）、正闭包</p>
<p><strong>正规式</strong>：按照一组定义规则，由较简单的正规式构成，每个正规式r表示一个语言L(r)</p>
<p>正规式等价：若正规式P和Q表示同一正规集，则称P和Q等价的，记为P=Q</p>
<p><img src="/images/compiler/%E6%AD%A3%E8%A7%84%E5%BC%8F%E4%BB%A3%E6%95%B0%E6%80%A7%E8%B4%A8.jpg" srcset="/img/loading.gif" lazyload></p>
<p>NFA、DFA</p>
<h3 id="Thompson算法"><a href="#Thompson算法" class="headerlink" title="Thompson算法"></a><strong>Thompson算法</strong></h3><p><img src="/images/compiler/%E8%AF%86%E5%88%ABNFA1.jpg" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/compiler/%E8%AF%86%E5%88%ABNFA2.jpg" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/compiler/%E8%AF%86%E5%88%ABNFA3.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="star-DFA最小化（子集法）"><a href="#star-DFA最小化（子集法）" class="headerlink" title=":star:DFA最小化（子集法）"></a>:star:<strong>DFA最小化</strong>（子集法）</h3><ol>
<li><strong>初始划分：终态与非终态；</strong></li>
<li><strong>利用可区分的概念，反复分裂划分中的组Gi，直到不可再分裂；</strong></li>
<li><strong>由最终划分构造D’，关键是选代表和修改状态转移；</strong></li>
<li><strong>消除可能的死状态和不可达状态。</strong></li>
</ol>
<p><code>lex</code>：词法分析器生成器；由定义、识别规则、辅助函数三部分组成</p>
<p><code>yacc</code>：语法分析器生成器</p>
<h4 id="课后填空：-1"><a href="#课后填空：-1" class="headerlink" title="课后填空："></a>课后填空：</h4><ol>
<li><p>词法分析器的任务是从源程序中识别出一个个 <code>单词</code> </p>
</li>
<li><p>表示源程序中信息单元的字符序列叫做  <code>记号</code>   </p>
</li>
<li><p>有限字母表<strong>S</strong>上有限长度的字符串的集合叫做   <code>语言 </code></p>
</li>
<li><p>确定有限自动机 DFA 是 <code>NFA</code> 的一个特例</p>
</li>
<li><p>LEX源程序的三个组成部分 <code>定义部分</code> 、<code> 识别规则部分</code> 和<code> 辅助函数部分</code>。</p>
</li>
</ol>
<h4 id="名词解释：-1"><a href="#名词解释：-1" class="headerlink" title="名词解释："></a>名词解释：</h4><p><strong>正规式</strong>：（又称正规表达式）是按照一组定义规则，由较简单的正规式构成的，每个正规式<em>r</em>表示一个语言<em>L</em>(<em>r</em>)。定义规则告诉我们<em>L</em>(<em>r</em>)是怎样以各种方式从<em>r</em>的子正规式所表示的语言组合而成的。</p>
<p><strong>非确定型有限自动机（NFA）</strong>是一个五元组：</p>
<p><img src="/images/compiler/clip_image002.gif" srcset="/img/loading.gif" lazyload></p>
<p>​    其中：</p>
<p> （1）S是一个有限的状态（State）集合；</p>
<p> （2）å（输入符号字母表）是一个输入符号的集合；</p>
<p> （3）move一个状态转换函数，move <img src="/images/compiler/clip_image004.gif" srcset="/img/loading.gif" lazyload>表示当前状态<img src="/images/compiler/clip_image006.gif" srcset="/img/loading.gif" lazyload>下若遇到输入字符ch，则转移到状态<img src="/images/compiler/clip_image008.gif" srcset="/img/loading.gif" lazyload>；</p>
<p> （4）状态<img src="/images/compiler/clip_image010.gif" srcset="/img/loading.gif" lazyload>是唯一的开始状态；</p>
<p> （5）状态集合F是终态集（接受状态集合）,并且F Í S<em>。</em></p>
<h4 id="简答题：-1"><a href="#简答题：-1" class="headerlink" title="简答题："></a>简答题：</h4><ol>
<li><p><strong>简要说明词法分析器的功能</strong>.</p>
<p>词法分析器的功能为依次扫描字符串形式的源程序中的各个字符，逐个识别出其中的单词，并将其转换为内部编码形式的单词符号串作为输出。</p>
</li>
<li><p><strong>简要叙述从正规式构造词法分析器的一般方法和过程</strong></p>
<p>从正规式构造词法分析器的一般方法和过程如下：</p>
<ol>
<li>用正规式对模式进行描述</li>
<li>为每一个正规式构造NFA</li>
<li>将构造出的NFA转换成等价的DFA，这一过程也被成为确定化</li>
<li>把DFA化为最简形式，这一过程也被成为最小化</li>
<li>从简化后的DFA构造词法分析器</li>
</ol>
</li>
</ol>
<h2 id="CH3"><a href="#CH3" class="headerlink" title="CH3"></a>CH3</h2><p><strong>0、1、2、3 型文法与自动机</strong>:</p>
<p> 若文法 G=（N,T,P,S）的每个产生式α→β中，均有 α∈（N∪T)*，且至少含有一个非终结符，β∈（N∪T)*，则称G 为0 型文法。对 0 型文法施加以下第 i 条限制，即可得到 i 型文法。</p>
<ol>
<li>G 的任何产生式α→β（S→ε除外）均满足|α|≤|β|（|x|表示x 中文法符号的个数）</li>
<li>G 的任何产生式 A→β，其中 A∈N，β∈（N∪T)* </li>
<li>G 的任何产生式 A→α或者 A→aB（或者 A→Ba），其中A,B∈N，a∈T0 型文法→图灵机、1 型文法→线性界限自动机、2 型文法→下推自动机、3 型文法→有限自动机</li>
</ol>
<p><img src="/images/compiler/image-20220615195407770.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>CFG 的定义、构成:</strong></p>
<p>上下文无关文法 CFG 是一个四元组 G=（N,T,P,S）</p>
<ul>
<li> N：非终结符有限集合 </li>
<li> T：终结符有限集合 </li>
<li> P：产生式有限集合 </li>
<li> S：是非终结符，被称为文法的开始符号</li>
</ul>
<p><strong>文法的二义性</strong>：原因：缺少文法符号优先级，结合性的规定</p>
<h3 id="自上而下递归"><a href="#自上而下递归" class="headerlink" title="自上而下递归"></a><strong>自上而下递归</strong></h3><p>​    从左到右扫描输入序列，自上而下建立它的语法树</p>
<p>​    ①公共左因子 避免回溯 ②左递归 避免陷入死循环。需要先消除左递归，再提取左因子。</p>
<h4 id="消除文法的左递归："><a href="#消除文法的左递归：" class="headerlink" title="消除文法的左递归："></a><strong>消除文法的左递归</strong>：</h4><p>​    改写为 <strong>A-&gt;βA’ ,  A’-&gt;αA’|ε</strong></p>
<h4 id="消除回溯提取的左因子："><a href="#消除回溯提取的左因子：" class="headerlink" title="消除回溯提取的左因子："></a><strong>消除回溯提取的左因子：</strong></h4><p><img src="/images/compiler/image-20220614101355077.png" srcset="/img/loading.gif" lazyload></p>
<p>​    </p>
<p><strong>递归下降分析法</strong></p>
<h3 id="预测分析表"><a href="#预测分析表" class="headerlink" title="预测分析表"></a><strong>预测分析表</strong></h3><ol>
<li><p>首先构造<strong>FIRST</strong>集合与<strong>FOLLOW</strong>集合</p>
</li>
<li><p>然后根据两个集合构造预测分析表</p>
<p><code>将FIRST(α)加入到预测分析表中，若FIRST集含有ε，再将FOLLOW(α)加入表中(推出ε)</code></p>
</li>
</ol>
<p><strong>下推自动机：</strong></p>
<p>下推自动机 M 是如下的一个七元组 ( Q, Σ, Γ, δ, q0, Z0, F ) ，其中：</p>
<ul>
<li> Q 是一个有穷状态集合；</li>
<li> Σ 是一个字母表，称为输入字母表。</li>
<li> Γ 是一个字母表，称为栈字母表。</li>
<li> q0 属于 Q ，是初始状态。</li>
<li> Z0 属于 Γ ，是一个特殊的栈符号，称为栈起始符号。</li>
<li> F 包含于 Q ，是终结状态集合。</li>
<li> δ : Q×(Σ∪{ε})×Γ -&gt; Q×Γ* 是 M 的动作函数。</li>
</ul>
<h3 id="star-FIRST"><a href="#star-FIRST" class="headerlink" title=":star:FIRST"></a>:star:<strong>FIRST</strong></h3><p><strong>从α开始可以推导出的所有开头终结符</strong></p>
<ol>
<li>若X∈T，则FIRST(X)={X}；</li>
<li><strong>若X是非终结符且有X→ε，则加入ε到FIRST(X)；</strong></li>
<li>若X是非终结符且有X→Y1Y2…Yk，并设Y0=ε，Yk+1=ε。那么对所有j(0≤j≤k)，若a∈FIRST(Yj+1)且ε∈FIRST(Yj),则加入a到FIRST(X)。</li>
</ol>
<h3 id="star-FOLLOW"><a href="#star-FOLLOW" class="headerlink" title=":star:FOLLOW"></a>:star:<strong>FOLLOW</strong></h3><p> <strong>从开始符号可以推导出的所有紧跟A之后的终结符</strong></p>
<ol>
<li><p>加入&#35;到FOLLOW(S)，其中S是开始符号，&#35;是输入结束标记。</p>
</li>
<li><p>若有产生式A→αBβ，则除ε外，FIRST(β)的全体加入到FOLLOW(B)。</p>
<p><code>Normal: follow(B)+=first(β)-&#123;ε&#125;</code></p>
</li>
<li><p>若有产生式A→αB或A→αBβ而ε∈FIRST(β)，则FOLLOW(A)的全体加入到FOLLOW(B)。</p>
<p><code>若β为ε或β-&gt;ε，则follow(B)+=follow(A)</code></p>
<p>2、3可能同时满足</p>
</li>
</ol>
<blockquote>
<p>自下而上计算FIRST、自上而下计算FOLLOW</p>
</blockquote>
<blockquote>
<p>exp: </p>
</blockquote>
<blockquote>
<p>L →E;L|ε<br>E →TE’<br>E’→+TE’|-TE’|ε<br>T →FT’<br>T’→*FT’|/FT’|mod FT’|ε<br>F →(E)|id|num </p>
</blockquote>
<blockquote>
<p>FIRST(F)  =    {(  id  num}<br>FIRST(T’) =    {*  /  mod  ε}<br>FIRST(T)  = FIRST(F) =    {(  id  num}<br>FIRST(E’) =    {+  -  ε}<br>FIRST(E)  = FIRST(T) = FIRST(F) = {(  id  num}<br>FIRST(L)  = {ε}∪FIRST(E) = {ε (  id  num} </p>
</blockquote>
<blockquote>
<p>FOLLOW(L)  = {&#35;}<br>FOLL0W(E)  = {) ;}<br>FOLLOW(E’) = {) ;}<br>FOLLOW(T)  = {+  -  ; )}<br>FOLLOW(T’) = {+  -  ; )}<br>FOLLOW(F)  = {+  -  *  /  mod  ) ;}</p>
</blockquote>
<p><img src="/images/compiler/image-20220614161131104.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="star-LL-1-文法"><a href="#star-LL-1-文法" class="headerlink" title=":star:LL(1)文法"></a>:star:<strong>LL(1)文法</strong></h3><ul>
<li><p><strong>L</strong>(从左往右输入，每次读入一个非终结符进行推导)，<strong>L</strong>(产生式使用最左推导)，<strong>1</strong>表示每次每一步只需要向前看一个符号就能确定下一步的语法分析动作。</p>
</li>
<li><p>判断方法1：预测分析表中不含多重定义的条目</p>
</li>
<li><p>判断方法2：任何两个产生式 A-&gt;α|β满足</p>
<ul>
<li>对任何终结符a，α和β不能同时推导出以a开始的串；</li>
<li>α和β最多有一个可以推导出ε</li>
<li>若β=*&gt;ε,则α不能导出以FOLLOW(A)中终结符开始的任何串。</li>
</ul>
</li>
<li><p><strong>将文法改写为等价的LL(1)文法</strong>：消除左递归、左因子</p>
</li>
</ul>
<blockquote>
<p>exp:</p>
<p>E→E+T|T</p>
<p>T→T*F|F  </p>
<p>F→(E)|-F|id</p>
</blockquote>
<blockquote>
<p>E →TE’ </p>
<p>E’→+TE’|ε </p>
<p>T →FT’ </p>
<p>T’→*FT’|ε </p>
<p>F →(E) |-F|id </p>
</blockquote>
<p>**自下而上语法分析： ** <strong>识别可归约串</strong></p>
<p>​    从句子ω开始，从左到右扫描ω，反复用产生式的左部替换产生式的右部、，最终得到文法的开始符号，或者发现一个错误。 </p>
<p><strong>句柄</strong>：</p>
<p>​    设αβδ是文法 G 的一个句型，若存在 S⇒*αAδ，A⇒+β，则称β是句型αβδ相对于A的<strong>短语</strong>。特别的，若有 A→β，则称β是句型αβδ相对于产生式 A→β的<strong>直接短语</strong>。一个句型的最左直接短语被称为<strong>句柄</strong>。</p>
<p><strong>活前缀</strong>：是指<strong>规范句型</strong>的一个前缀，这种前缀不含<strong>句柄</strong>之后的任何符号。即，对于规范句型αβδ，β为句柄，如果αβ=u1u2…ur，则符号串u1u2…ui(1≤i≤r)是αβδ的活前缀。(δ必为终结符串)</p>
<p><strong>ε-闭包-closure(I)</strong><br>设I是的状态集的一个子集，定义I的**ε-闭包-closure(I)**为:<br>  i) 若s∈I，则s-closure(I)；<br>  ii) 若s∈I，则从s出发经过任意条ε 弧而能到达的任何状态s’都属于-closure(I)<br>-closure(I)=I{s’|从某个s∈I出发经过任意条ε 弧能到达s’}</p>
<p>**GO(I，X): **状态转换函数；所有从I经文法符号X能到达的项目全体</p>
<h3 id="star-SLR-1"><a href="#star-SLR-1" class="headerlink" title=":star:SLR(1)"></a>:star:<strong>SLR(1)</strong></h3><p>当一个项目集中同时存在：</p>
<ol>
<li><p>A→β1.β2和B→β1.：既可移进又可归约，移进/归约冲突</p>
</li>
<li><p>A→α.和B→α.：均可指导下一步分析，归约/归约冲突</p>
</li>
</ol>
<p>解决方法：简单向前看一个终结符a：</p>
<ol>
<li><p>移进/归约冲突：若FIRST(β2)∩FOLLOW(B)=Φ，冲突可解决</p>
</li>
<li><p>归约/归约冲突：若FOLLOW(A)∩FOLLOW(B)=Φ，冲突可解决</p>
</li>
</ol>
<p>若冲突可以解决，则称文法为SLR(1)文法，构造的分析表为SLR(1)分析表。</p>
<p><strong>判断SLR(1)</strong>: 考察上述两种冲突，写出FIRST/FOLLOW集，若冲突可以解决则是SLR(1)</p>
<p><strong>项目集规范族的构造：</strong></p>
<ol>
<li>进行扩广文法</li>
<li>若X-&gt;α.Aβ，A为非终结符，则需要加上所有的A-&gt;.γ</li>
</ol>
<p><img src="/images/compiler/image-20220614165607682.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>SLR分析表的构造：</strong></p>
<p><img src="/images/compiler/image-20220614203451785.png" srcset="/img/loading.gif" lazyload></p>
<p>exp：</p>
<p><img src="/images/compiler/image-20220614203331639.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/compiler/image-20220614203402677.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="课后填空：-2"><a href="#课后填空：-2" class="headerlink" title="课后填空："></a>课后填空：</h4><ol>
<li><p>一个上下文无关文法所含四个组成部分是 <code>一组终结符号</code>、<code>一组非终结符号</code>、<code>一个开始符号</code>和<code>一组产生式</code> 。</p>
</li>
<li><p>设G是一个给定的文法，S是文法的开始符号，如果S*⇒x（其中x∈（N∪T)*），则称x是文法的一个 <code>句型</code>  。</p>
</li>
<li><p>设G是一个给定的文法，S是文法的开始符号，如果S*⇒x(其中x∈T*),则称x是文法的一个 <code>句子 </code>。</p>
</li>
<li><p>在语法分析中，最常见的两种方法一定是 <code>自上而下分析法</code>，另一是 <code>自下而上分析法</code>。</p>
</li>
<li><p>在自上而下的语法分析中，应先消除文法的<code>间接</code> 递归，再消除文法的 <code>直接</code> 递归。 </p>
<blockquote>
<p>先消除左递归</p>
</blockquote>
</li>
<li><p>规范归约是指在移进过程中，当发现栈顶呈现<code>句柄</code>时，就用相应产生式的 <code>左部</code> 符号进行替换。 </p>
</li>
<li><p>自下而上的语法分析方法的基本思想是：从给定的终极符串开始，根据文法的规则一步一步的向上进行 <code>扫描(?)</code> ，试图 <code>归约</code> 到文法的 <code>开始符号</code> 。</p>
</li>
<li><p>在LR（0）分析法的名称中，L的含义是 <code>自左向右的扫描输入串</code> ，R的含义是 <code>最左归约/最右推导的逆过程</code> ，0 的含义是 <code>在确定分析器的每一步动作时向前看0个终结符 </code>。</p>
</li>
</ol>
<blockquote>
<p>LL(1)分析法是自上而下的分析法。LR(0), LR(1), SLR(1), LALR(1)是自下而上的分析法。</p>
<p>最右推导：规范推导/最左规约的逆过程</p>
<p>最左规约：规范规约/最右推导的逆过程</p>
</blockquote>
<h4 id="名词解释：-2"><a href="#名词解释：-2" class="headerlink" title="名词解释："></a>名词解释：</h4><p><strong>上下文无关文法：</strong></p>
<p>是一个四元组（N,T, P, S），其中：</p>
<ol>
<li><p>T是一个非空有限集合，其元素称为终结符。在我们谈论程序设计语言的文法时，记号是终结符的同义词。</p>
</li>
<li><p>N是一个非空有限集合，其元素称为非终结符，并有T∩N = f。非终结符定义终结符串的集合，它们用来帮助定义由文法决定的语言。</p>
</li>
<li><p>S是非终结符，称为开始符号，它定义的终结符串集就是文法定义的语言。</p>
</li>
<li><p>P是产生式的有限集合，每个产生式的形式是A -&gt; a（有时用::=代替箭头），其中A∈N，被称为该产生式左部，a∈(T∪N )*，被称为该产生式的右部。开始符号至少出现在某个产生式的左部。产生式指出了终结符和非终结符组成串的方式。</p>
</li>
</ol>
<p><strong>句柄</strong>：一个句型的最左直接短语</p>
<p><strong>活前缀</strong>：对于文法G[S]，若有S*⇒αβ，β∈T* 则称α为规范前缀，也称为活前缀。</p>
<h2 id="CH4"><a href="#CH4" class="headerlink" title="CH4"></a>CH4</h2><p><strong>语义分析的作用：</strong></p>
<ul>
<li>检查语言结构的语义是否正确</li>
<li>执行所规定的语义动作</li>
</ul>
<p><strong>属性：</strong>综合和继承</p>
<ul>
<li><p><strong>综合</strong>属性用于“<strong>自下而上</strong>”传递信息</p>
</li>
<li><p><strong>继承</strong>属性用于“<strong>自上而下</strong>”传递信息</p>
</li>
<li><p>E.val（值）  </p>
<p> E.type（类型）</p>
<p> E.code（代码序列）</p>
<p> E.place（存储空间）</p>
</li>
</ul>
<p><strong>语义规则两种表示方式：</strong></p>
<ul>
<li>用抽象的属性和运算符号表示的语义规则称为语法制导定义</li>
<li>用具体属性和运算表示的语义规则称为翻译方案</li>
</ul>
<p>语法制导定义仅考虑“做什么”，用抽象的属性表示文法符号所代表的语义</p>
<p>翻译方案不但需要考虑“做什么”，还需要考虑“如何做”。两者类似于算法和程序</p>
<p><strong>后缀式</strong>：后序遍历</p>
<p>三地址码： x : = y op z (x, y, z为名字、常数或编译时产生的临时变量)</p>
<p><img src="/images/compiler/PTRH0C%60V%60X%60I%25HF%5D9BV7.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="三元式"><a href="#三元式" class="headerlink" title="三元式"></a><strong>三元式</strong></h3><ul>
<li> (i) (op, arg1, arg2) 表示的计算是 (i) := arg1 op arg2</li>
<li>编号的含义：代表三元式；代表其存放的结果</li>
</ul>
<p><strong>三元式的语法制导翻译</strong>：</p>
<ul>
<li>属性 .code：三元式代码，指示标识符的存储单元或三元式表中的序号；</li>
<li>属性 .name：标识符的名字；</li>
<li>函数 trip( op，arg1，arg2 )：生成一个三元式，返回三元式的序号；</li>
<li>函数 entry(id.name)：返回标识符在符号表中的位置或存储位置。</li>
</ul>
<p>产生式 语义规则</p>
<blockquote>
<p>(1) A→id:=E {A.code:=trip(:=，entry(id.name)，E.code)}</p>
<p>(2) E→E1+E2 {E.code:=trip(+，E1.code，E2.code)}</p>
<p>(3) E→E1*E2 {E.code:=trip(*，E1.code，E2.code)}</p>
<p>(4) E→(E1) {E.code:=E1.code}</p>
<p>(5) E→-E1 {E.code:=trip(@，E1.code， )}</p>
<p>(6) E→id {E.code:=entry(id.name)}</p>
</blockquote>
<p>x:=a-b*c <strong>注释语法树</strong>:<br><img src="/images/compiler/image-20220615103820125.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="四元式"><a href="#四元式" class="headerlink" title="四元式"></a><strong>四元式</strong></h3><ul>
<li>(op, arg1, arg2, result)    op为运算符，其余为指针</li>
</ul>
<p><strong>四元式特点</strong>：</p>
<ol>
<li><strong>四元式与三元式的唯一区别：将由序号所表示的运算结果改为由临时变量来表示。</strong></li>
<li>此改进使得四元式的运算结果与其位置无关，为代码优化提供了极大方便：可以删除或移动四元式而不影响运算结果。</li>
</ol>
<p><strong>四元式的语法制导翻译：</strong></p>
<ul>
<li><p>属性.code：表示存放运算结果的变量；</p>
</li>
<li><p>函数newtemp：返回一个新的临时变量，如T1，…等；</p>
</li>
<li><p>过程emit( op，arg1，arg2, result)：生成一个四元式，若为一元运算，则arg2可空。</p>
</li>
</ul>
<p><strong>产生式与语义规则</strong>：</p>
<blockquote>
<p>(1)A→id:=E {A.code:=newtemp; emit(:=, entry(id.name), E.code,</p>
<p> A.code)}</p>
<p>(2)E→E1+E2 {E.code:=newtemp; emit(+, E1.code, E2.code, E.code)}</p>
<p>(3)E→E1*E2 {E.code:=newtemp; emit(*, E1.code, E2.code, E.code)}</p>
<p>(4)E→(E1) {E.code:=E1.code}</p>
<p>(5)E→-E1 {E.code:=newtemp; emit(@, E1.code, , E.code)}</p>
<p>(6)E→id {E.code:=entry(id.name)}</p>
</blockquote>
<p>赋值句x:=(a+b)*(a+b)的树的中间代码表示：</p>
<p><img src="/images/compiler/image-20220615143337487.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>变量声明的语法制导翻译：</strong></p>
<ul>
<li><p>全程量offset：记录当前符号存储的偏移量，初值设为0</p>
</li>
<li><p>属性.type和.width：变量的类型和所占据的存储空间</p>
</li>
<li><p>过程enter(name, type, offset)：为type类型的变量name建立符号表条目，并为其分配存储空间(位置)offset</p>
</li>
</ul>
<blockquote>
<p>(1)D→D;D</p>
<p>(2)D→id:T                             {enter(id.name, T.type, offset);   offset:=offset+T.width;}</p>
<p>(3)T→int                               {T.type:=integer; T.width:=4;}</p>
<p>(4)T→real                             {T.type:=real; T.width:=8;}</p>
<p>(5)T→array [num] of T1    {T.type:=array(num.val, T1.type);    T.width:=num.val*T1.width;}</p>
<p>(6)T→^T1                              {T.type:=pointer(T1.type); T.width:=4;} </p>
</blockquote>
<p><img src="/images/compiler/W24FWJ1@Z$3V4UJ6WFL%5D0WQ.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><strong>参数传递</strong></h3><ul>
<li><p>值调用（call by value）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ---------- 值调用参数传递的演示程序</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> temp;  <br>        temp=x;  x=y;  y=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;before:  a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;   b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    <span class="hljs-built_in">swap</span>(a, b);<br>    cout&lt;&lt;<span class="hljs-string">&quot;after:   a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;   b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>引用调用（call by reference） 实参必须是左值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ---------- 引用调用参数传递的演示程序</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> temp;  <br>        temp=x;  x=y;  y=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;before:  a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;   b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>    <span class="hljs-built_in">swap</span>(a, b);<br>    cout&lt;&lt;<span class="hljs-string">&quot;after:   a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;   b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>复写－恢复（copy-in/copy-out）实参必须是左值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//  --------- 引用调用的副作用的程序实例</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-keyword">int</span> a=<span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_one</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span></span>&#123; a=x+<span class="hljs-number">1</span>;  x=x+<span class="hljs-number">1</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   cout&lt;&lt;<span class="hljs-string">&quot;before:  a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    <span class="hljs-built_in">add_one</span>(a);<br>    cout&lt;&lt;<span class="hljs-string">&quot;after:   a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">// ----------引用调用模拟复写-恢复参数传递的演示程序</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-keyword">int</span> a=<span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_one</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> local_x=x;  a=local_x+<span class="hljs-number">1</span>; local_x++; x=local_x;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   cout&lt;&lt;<span class="hljs-string">&quot;before:  a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>    <span class="hljs-built_in">add_one</span>(a);<br>    cout&lt;&lt;<span class="hljs-string">&quot;after:   a=&quot;</span>&lt;&lt;a&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>换名调用（call by name）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ---------- 换名调用副作用的演示程序</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-keyword">int</span> temp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> swap(x, y) temp=x;  x=y;  y=temp;	<span class="hljs-comment">// 宏定义</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span>			<span class="hljs-comment">// 引用调用</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">int</span> temp;  temp=x;  x=y;  y=temp; &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, b[]</span>=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    cout&lt;&lt;<span class="hljs-string">&quot;before:  a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;  b=&quot;</span>&lt;&lt;b[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>    <span class="hljs-built_in">swap</span>(a, b[a]);<br>    cout&lt;&lt;<span class="hljs-string">&quot;after:   a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;  b=&quot;</span>&lt;&lt;b[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;b[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//折中方法：内联函数</span><br><span class="hljs-comment">//----------- 宏定义</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> macro_swap(x, y) temp=x;  x=y;  y=temp; </span><br><br><span class="hljs-comment">//----------- 内联函数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inline_swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> temp; temp=x;  x=y;  y=temp;&#125;<br><br><span class="hljs-comment">//----------- 引用调用</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">procedure_swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> temp; temp=x;  x=y;  y=temp;&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a><strong>布尔表达式</strong></h3><blockquote>
<p>E→ E or E | E and E | not E | (E) | id relop id | id | true | false</p>
</blockquote>
<h4 id="短路计算"><a href="#短路计算" class="headerlink" title="短路计算"></a>短路计算</h4><p>短路计算以if-then-else的方式解释布尔表达式，控制逻辑如下</p>
<pre><code> A or B ： if A then true else B
 
 A and B： if A then B else false 
 
 not A  ： if A then false else true
</code></pre>
<p>布尔表达式A or B and not C采用短路计算，等价于下述解释：</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pascal"><span class="hljs-keyword">if</span> A  <br>	<span class="hljs-keyword">then</span> true<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>   B<br>		<span class="hljs-keyword">then</span> <span class="hljs-keyword">if</span> C <span class="hljs-keyword">then</span> false <span class="hljs-keyword">else</span> true<br>		<span class="hljs-keyword">else</span> false<br></code></pre></td></tr></table></figure>

<p>对于语句：</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pascal"><span class="hljs-keyword">while</span> ptr&lt;&gt;<span class="hljs-keyword">nil</span> <span class="hljs-keyword">and</span> ptr^.data=x <span class="hljs-keyword">do</span> ...<br></code></pre></td></tr></table></figure>

<p>短路计算可以回避对ptr^.data=x的判断，从而避免程序运行时错误。</p>
<p>语义规则：</p>
<blockquote>
<p>(1)E→E1 or E2     {E1.true:= E.true; E1.false:=newlabel;</p>
<pre><code>                             E2.true:= E.true; E2.false:=E.false;  
   
                             E.code := E1.code||emit(E1.false &#39;:&#39;)||E2.code;&#125;
</code></pre>
<p>(2) |E1 and E2     {E1.false:= E.false; E1.true:=newlabel;</p>
<pre><code>                              E2.false:= E.false; E2.true:=E.true; 
   
                              E.code := E1.code||emit(E1.true&#39;:&#39;)||E2.code;&#125;
</code></pre>
<p>(3) |not E1    {E1.false:=E.true;  E1.true:=E.false;}</p>
<p>(4) |(E1)     {E1.false:=E.false; E1.true:=E.true;} </p>
<p>(5) |id1 relop id2      { E.code := emit(‘if’id1.place relop.op  id2.place’goto’E.true) || emit(‘goto’ E.false);}</p>
<p>(6) |id     { E.code := emit(‘if’ id.place ‘goto’ E.true)</p>
<p>​                 || emit(‘goto’ E.false);}</p>
<p>(7) |true     {E.code := emit(‘goto’ E.true);}</p>
<p>(8) |false     {E.code := emit(‘goto’ E.false);}</p>
</blockquote>
<p>再考虑布尔表达式a&lt;b or c&lt;d and e&lt;f的短路计算：</p>
<p><img src="/images/compiler/image-20220615145315394.png" srcset="/img/loading.gif" lazyload></p>
<p>三地址码序列: </p>
<p><img src="/images/compiler/image-20220615145339282.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/compiler/image-20220615145414892.png" srcset="/img/loading.gif" lazyload></p>
<p>p.s. 不能执行</p>
<h3 id="课后填空"><a href="#课后填空" class="headerlink" title="课后填空"></a>课后填空</h3><ol>
<li><p>所谓属性文法是  <code>在上下文无关文法的基础上为每个文法符号（终结符或非终结符）配备若干相关的“值” </code>。</p>
</li>
<li><p>语义规则的描述方法有  <code>语法制导翻译</code> 和  <code>翻译方案</code>  。</p>
</li>
<li><p>综合属性是用于 <code>自下而上</code>  传递信息，继承属性是用于 <code>自上而下</code> 传递信息。</p>
</li>
<li><p>终结符只有 <code>综合</code> 属性，它由词法分析器提供。</p>
</li>
<li><p>在使用高级语言编程时,首先可通过编译程序发现源程序 的 <code>词法</code> 错误和部分 <code>语法</code>  错误。</p>
</li>
<li><p>语法制导翻译既可以用来产生 <code>中间</code> 代码，也可用来产生 <code>目标</code> 指令，甚至可用来对<code>输入串</code>进行 解释执行 。</p>
</li>
<li><p>在语法树中，一个结点的综合属性的值由其  <code>子结点</code>  的属性值确定，而继承属性则由该结点的  <code>父结点、兄弟结点  </code>的某些属性确定</p>
</li>
</ol>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ol>
<li><p>三元式:</p>
<p>用op、arg1、arg2这三个域，并用临时变量值的语句位置来引用临时变量，这样的三地址码的记录方式。</p>
</li>
<li><p>语义规则</p>
<p>对于文法的每个产生都配备了一组属性的计算规则，称为语义规则</p>
</li>
<li><p>翻译方案</p>
<p>用具体属性和运算表示的语义规则称为翻译方案。</p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/25/2022/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">网络应用程序设计实验报告</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/29/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/exp4/">
                        <span class="hidden-mobile">利用MOM消息队列技术实现一个分布式随机信号分析系统</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"jsonPath":"/null"},"log":false});</script></body>
</html>
