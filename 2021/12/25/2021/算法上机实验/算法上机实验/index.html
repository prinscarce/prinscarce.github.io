

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="算法分析与设计 上机实验">
  <meta name="author" content="prinscarce">
  <meta name="keywords" content="">
  
  <title>算法上机实验 - prinscarce</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"prinscarce.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":80,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>serendipity</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/bangumis/">
                <i class="iconfont icon-bilibili-fill"></i>
                bangumi
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="算法上机实验">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      prinscarce
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-25 22:36" pubdate>
        2021年12月25日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      98
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法上机实验</h1>
            
            <div class="markdown-body">
              <h1 id="算法分析与设计"><a href="#算法分析与设计" class="headerlink" title="算法分析与设计"></a>算法分析与设计</h1><h2 id="渗透问题（Percolation）"><a href="#渗透问题（Percolation）" class="headerlink" title="渗透问题（Percolation）"></a>渗透问题（Percolation）</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>使用合并-查找（union-find）数据结构，编写程序通过蒙特卡罗模拟（Monte Carlo simulation）来估计渗透阈值的值。</p>
<h3 id="二、题目描述"><a href="#二、题目描述" class="headerlink" title="二、题目描述"></a>二、题目描述</h3><p><strong>模型。</strong> 我们使用N×N网格点来模型一个渗透系统。 每个格点或是open格点或是blocked格点。 一个full site是一个open格点，它可以通过一连串的邻近（左，右，上，下）open格点连通到顶行的一个open格点。如果在底行中有一个full site格点，则称系统是渗透的。（对于绝缘/金属材料的例子，open格点对应于金属材料，渗透系统有一条从顶行到底行的金属路径，且full sites格点导电。对于多孔物质示例，open格点对应于空格，水可能流过，从而渗透系统使水充满open格点，自顶向下流动。）</p>
<p><img src="/images/algs4/image-20211225134840912.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>问题。</strong> 在一个著名的科学问题中，研究人员对以下问题感兴趣：如果将格点以空置概率p独立地设置为open格点（因此以概率1-p被设置为blocked格点），系统渗透的概率是多少？ 当p = 0时，系统不会渗出; 当p=1时，系统渗透。 下图显示了20×20随机网格（左）和100×100随机网格（右）的格点空置概率p与渗滤概率。</p>
<p><img src="/images/algs4/image-20211225134910165.png" srcset="/img/loading.gif" lazyload><br><img src="images/algs4/image-20211225134919354.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>当N足够大时，存在阈值p</strong><em>，使得当p &lt;p* ，随机N N网格几乎不会渗透，并且当p&gt; p</em>时，随机N N网格几乎总是渗透。 尚未得出用于确定渗滤阈值p<em>的数学解。<strong>你的任务是编写一个计算机程序来估计p</strong></em>。</p>
<h3 id="三、解决方法"><a href="#三、解决方法" class="headerlink" title="三、解决方法"></a>三、解决方法</h3><p><strong>Percolation数据类型。</strong>模型化一个Percolation系统，创建含有以下API的数据类型Percolation。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Percolation</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Percolation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span>           <span class="hljs-comment">// create N-by-N grid, with all sites blocked</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span>         <span class="hljs-comment">// open site (row i, column j) if it is not already</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span>    <span class="hljs-comment">// is site (row i, column j) open?</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span>     <span class="hljs-comment">// is site (row i, column j) full?</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">percolates</span><span class="hljs-params">()</span>          <span class="hljs-comment">// does the system percolate?</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-comment">// test client, optional</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>约定行i列j下标在1和N之间，其中(1, 1)为左上格点位置：如果open(), isOpen(), or isFull()不在这个规定的范围，则抛出IndexOutOfBoundsException例外。如果N ≤ 0，构造函数应该抛出IllegalArgumentException例外。构造函数应该与N2成正比。所有方法应该为常量时间加上常量次调用合并-查找方法union(), find(), connected(), and count()。</p>
<p><strong>蒙特卡洛模拟（Monte Carlo simulation）</strong>. 要估计渗透阈值，考虑以下计算实验：</p>
<ul>
<li>初始化所有格点为blocked。</li>
<li>重复以下操作直到系统渗出：<ul>
<li>在所有blocked的格点之间随机均匀选择一个格点 (row i, column j)。</li>
<li>设置这个格点(row i, column j)为open格点。</li>
</ul>
</li>
<li>open格点的比例提供了系统渗透时渗透阈值的一个估计。</li>
</ul>
<p>例如，如果在20×20的网格中，根据以下快照的<em>open</em>格点数，那么对渗滤阈值的估计是204/400 = 0.51，因为当第204个格点被<em>open</em>时系统渗透。</p>
<p><img src="/images/algs4/image-20211225135642643.png" srcset="/img/loading.gif" lazyload></p>
<p>通过重复该计算实验<em>T</em>次并对结果求平均值，我们获得了更准确的渗滤阈值估计。 令<em>xt</em>是第<em>t</em>次计算实验中<em>open</em>格点所占比例。 样本均值<em>m</em>提供渗滤阈值的一个估计值； 样本标准差<em>s</em>测量阈值的灵敏性。<br>$$<br>\mu=\frac { x_1+x_2+\ldots+x_T } { T }, \sigma^2=\frac { { (x_1-\mu) } ^2+ { (x_2-\mu) } ^2 + \ldots+ { (x_T-\mu) } ^2 } { T-1 }<br>$$<br>假设<em>T</em>足够大（例如至少30），以下为渗滤阈值提供95％置信区间：<br>$$<br>\left[\mu-\frac { 1.96\sigma } {\sqrt T},\ \mu+\frac { 1.96\sigma } { \sqrt T }\right]<br>$$<br>我们创建<strong>数据类型PercolationStats来执行一系列计算实验</strong>，包含以下API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PercolationStats</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PercolationStats</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> T)</span>    <span class="hljs-comment">// perform T independent computational experiments on an N-by-N grid</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">mean</span><span class="hljs-params">()</span>                <span class="hljs-comment">// sample mean of percolation threshold</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">stddev</span><span class="hljs-params">()</span>               <span class="hljs-comment">// sample standard deviation of percolation threshold</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">confidenceLo</span><span class="hljs-params">()</span>         <span class="hljs-comment">// returns lower bound of the 95% confidence interval</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">confidenceHi</span><span class="hljs-params">()</span>         <span class="hljs-comment">// returns upper bound of the 95% confidence interval</span></span><br><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>    <span class="hljs-comment">// test client, described below</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>在N ≤ 0或T ≤ 0时，构造函数应该抛出java.lang.IllegalArgumentException例外。</p>
<p>此外，还包括一个main( )方法，它取两个命令行参数N和T，在N×N网格上进行T次独立的计算实验（上面讨论），并打印出均值μ、标准差σ和95％ 渗透阈值的置信区间。 使用标准库中的标准随机数生成随机数； 使用标准统计库来计算样本均值和标准差。</p>
<h3 id="四、算法及解释"><a href="#四、算法及解释" class="headerlink" title="四、算法及解释"></a>四、算法及解释</h3><p>使用<strong>quick-find</strong>算法实现Percolation数据类型。进行实验表明当<em>N</em>加倍时对运行时间的影响；<strong>使用近似表示法</strong>，给出在计算机上的总时间，它是<strong>输入N和T的函数表达式</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickFindUF</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;						<span class="hljs-comment">//number of components</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] id;						<span class="hljs-comment">//id[i] = component identifier of i</span><br>    <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QuickFindUF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span>				<span class="hljs-comment">//初始化</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span>						<span class="hljs-comment">//返回连通分量的个数</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span> <span class="hljs-comment">//若p，q在同一分量中则返回true</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span>					<span class="hljs-comment">//返回根节点</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span>			<span class="hljs-comment">//Union p and q </span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>使用<strong>weighted quick-union</strong>算法实现Percolation数据类型。进行实验表明当N加倍时对运行时间的影响；使用近似表示法，给出在计算机上的总时间，它是<strong>输入N和T的函数表达式</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeightedQuickUnionUF</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;						<span class="hljs-comment">//number of components</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] id;						<span class="hljs-comment">//id[i] = component identifier of i</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] sz;						<span class="hljs-comment">//权值大小</span><br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeightedQuickUnionUF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span>		<span class="hljs-comment">//初始化</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span>						<span class="hljs-comment">//返回连通分量的个数</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span> <span class="hljs-comment">//若p，q在同一分量中则返回true</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span>					<span class="hljs-comment">//返回根节点</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> q)</span>			<span class="hljs-comment">//Union p and q </span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>构造Percolate_problem类</strong>，使其能够实现存储渗透的点阵，并能够判断最后其点阵是否渗透。以下简单说明各函数功能以及实现要点。</p>
<ol>
<li><p>初始化时构造一个虚拟的顶部以及底部，以便判断是否渗透。因为有这俩顶点，所以进行初始化时QF和WQU都为<strong>N*N+2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)	QF = <span class="hljs-keyword">new</span> QuickFindUF(N*N+<span class="hljs-number">2</span>);<br><span class="hljs-keyword">else</span>	WQU = <span class="hljs-keyword">new</span> WeightedQuickUnionUF(N*N+<span class="hljs-number">2</span>);<br><br>virtualTop = perRowColumnSize * perRowColumnSize;<br>virtualBottom = virtualTop + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li>
<li><p>构建一个TransIndex函数，以便在查询节点位置中更简洁更易理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">TransIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> column)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> (row - <span class="hljs-number">1</span>) * perRowColumnSize + column - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>输入t，以区分目前open的节点正在使用quickfind或是WeightedQuickUnion算法。open新节点时需连接上下左右，此时需小心是否溢出边界，是否直接为首行或者尾行（直接与虚顶和虚底进行连接）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//QuickFindUF</span><br><span class="hljs-keyword">int</span> loc = TransIndex(row,column);<br><span class="hljs-keyword">if</span>(sites[loc])  <span class="hljs-keyword">return</span>;<br>sites[loc] = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">int</span> neighbor;	    <br><span class="hljs-comment">//若在首排或者尾排</span><br>   <span class="hljs-keyword">if</span>(row == <span class="hljs-number">1</span>)  QF.union(loc, virtualTop);<br>   <span class="hljs-keyword">if</span>(row == perRowColumnSize)  QF.union(loc, virtualBottom);<br>   <br><span class="hljs-comment">//连接上下左右</span><br>   <span class="hljs-keyword">if</span>(row&gt;<span class="hljs-number">1</span>) &#123;<br>    neighbor = TransIndex(row-<span class="hljs-number">1</span>,column);<br>    <span class="hljs-keyword">if</span>(sites[neighbor]) QF.union(loc, neighbor);<br>&#125;<br>   <span class="hljs-keyword">if</span>(row&lt;perRowColumnSize) &#123;<br>    neighbor = TransIndex(row+<span class="hljs-number">1</span>,column);<br>    <span class="hljs-keyword">if</span>(sites[neighbor]) QF.union(loc, neighbor);<br>   &#125;<br>   <span class="hljs-keyword">if</span>(column&gt;<span class="hljs-number">1</span>) &#123;<br>    neighbor = TransIndex(row,column-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(sites[neighbor]) QF.union(loc, neighbor);<br>   &#125;<br>   <span class="hljs-keyword">if</span>(column&lt;perRowColumnSize) &#123;<br>    neighbor = TransIndex(row,column+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(sites[neighbor]) QF.union(loc, neighbor);<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>通过判断顶部和底部是否连接来判断该模型是否渗透</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPercolated</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(t == <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> QF.isConnected(virtualTop, virtualBottom);	<br>	<span class="hljs-keyword">else</span>   <span class="hljs-keyword">return</span> WQU.isConnected(virtualTop, virtualBottom);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用变量以及函数的简单介绍：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Percolate_problem</span> </span><br><span class="hljs-class"></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] sites;		<span class="hljs-comment">//渗透点阵</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> perRowColumnSize;	<span class="hljs-comment">//每行数量</span><br>	<span class="hljs-keyword">private</span> WeightedQuickUnionUF WQU;<br>	<span class="hljs-keyword">private</span> QuickFindUF QF;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> virtualTop;			<span class="hljs-comment">//虚拟顶部和尾部</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> virtualBottom;<br>    <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Percolate_problem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> i)</span> 	<span class="hljs-comment">//初始化</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">TransIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> column)</span><span class="hljs-comment">//找到row，col对应索引</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> column)</span><span class="hljs-comment">//是否已经open</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> column, <span class="hljs-keyword">int</span> t)</span>；<span class="hljs-comment">//open节点</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPercolated</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span>；	<span class="hljs-comment">//是否渗透</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>构造PercolateStatistics类</strong>：使其能得到随机的open节点，计算均值、标准差、置信区间以及输出结果。</p>
<ol>
<li><p>PercolateStatistics函数进行初始化：输入N*N的矩阵，T次循环，t来进行选择使用的算法</p>
</li>
<li><p>再不断循环t次中，每单次实验，不断得到随机数并open节点，直到渗透为止。以及open过的节点可以直接跳过不占用更多的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//single_test</span><br>Percolate_problem percolation = <span class="hljs-keyword">new</span> Percolate_problem(N, t);<br><span class="hljs-keyword">int</span> openCount = <span class="hljs-number">0</span>;	<span class="hljs-comment">//Opened节点数</span><br><span class="hljs-keyword">while</span>(!percolation.isPercolated(t)) &#123;<br>	<span class="hljs-comment">//生成随机open点</span><br>	<span class="hljs-keyword">int</span> row = (<span class="hljs-keyword">int</span>)(Math.random() * n) + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">int</span> col = (<span class="hljs-keyword">int</span>)(Math.random() * n) + <span class="hljs-number">1</span>;<br>	<br>	<span class="hljs-comment">//若已经open过了跳过</span><br>	<span class="hljs-keyword">if</span>(percolation.isOpen(row, col)) &#123;<br>		<span class="hljs-keyword">continue</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		percolation.open(row, col, t);<br>		openCount++;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>通过prob数组记录每次实验所得到的比值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//记录每次得到的比例</span><br>prob[i] = (<span class="hljs-keyword">double</span>)openCount / (n * n);	<br>Mean = mean(prob);<br>Stddev = stddev(prob);<br>Confidence_Low = confidenceLow(prob);<br>Confidence_High = confidenceHigh(prob);<br></code></pre></td></tr></table></figure>

<p>4.输出测试结果</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PercolateStatistics</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> prob[];<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> Mean;	<span class="hljs-comment">//均值</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> Stddev;	<span class="hljs-comment">//标准差</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> Confidence_Low;	<span class="hljs-comment">//置信区间_low</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> Confidence_High;	<span class="hljs-comment">//置信区间_high</span><br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PercolateStatistics</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N,<span class="hljs-keyword">int</span> T,<span class="hljs-keyword">int</span> t)</span> <span class="hljs-comment">//初始化</span></span><br><span class="hljs-function">	</span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getMean</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSteddev</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getConfidenceLow</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getConfidenceHigh</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">confidenceHigh</span><span class="hljs-params">(<span class="hljs-keyword">double</span> prob[])</span>	<span class="hljs-comment">//计算置信区间_high</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">confidenceLow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> prob[])</span>	<span class="hljs-comment">//计算置信区间_low</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">mean</span><span class="hljs-params">(<span class="hljs-keyword">double</span> prob[])</span>			<span class="hljs-comment">//计算均值</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">stddev</span><span class="hljs-params">(<span class="hljs-keyword">double</span> prob[])</span>			<span class="hljs-comment">//计算标准差</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> 		<span class="hljs-comment">//输出结果</span></span><br><span class="hljs-function">		</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h3><p><strong>测试数据：</strong></p>
<p><strong>N = 10， Times = 100；</strong></p>
<p><img src="/images/algs4/image-20211224135818426.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>N = 20， Times = 100；</strong></p>
<p><img src="/images/algs4/image-20211224140433628.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>N = 40， Times = 100；</strong></p>
<p><img src="/images/algs4/image-20211224141036095.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>N = 80， Times = 100；</strong></p>
<p><img src="/images/algs4/image-20211224141117706.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>N = 100， Times = 100；</strong></p>
<p><img src="/images/algs4/image-20211224140022141.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>N = 160， Times = 100；</strong></p>
<p><img src="/images/algs4/image-20211224141231709.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>N = 200，Times = 100；</strong></p>
<p><img src="/images/algs4/image-20211224135619797.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/algs4/image-20211224135632977.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>特殊情况：N = 2， Times = 100000；</strong></p>
<p><img src="/images/algs4/image-20211224140957414.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="六、分析与总结"><a href="#六、分析与总结" class="headerlink" title="六、分析与总结"></a>六、分析与总结</h3><p><strong>分析：</strong></p>
<p><strong>T=100，时间单位都为ms</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">N=10</th>
<th align="center">N=20</th>
<th align="center">N=40</th>
<th align="center">N=80</th>
<th align="center">N=160</th>
<th align="center">N=100</th>
<th align="center">N=200</th>
</tr>
</thead>
<tbody><tr>
<td align="center">quick-find用时</td>
<td align="center">25</td>
<td align="center">160</td>
<td align="center">368</td>
<td align="center">3334</td>
<td align="center">47267</td>
<td align="center">7675</td>
<td align="center">137033</td>
</tr>
<tr>
<td align="center">weighted  quick-union用时</td>
<td align="center">34</td>
<td align="center">63</td>
<td align="center">108</td>
<td align="center">333</td>
<td align="center">957</td>
<td align="center">431</td>
<td align="center">1531</td>
</tr>
<tr>
<td align="center">QF的p*</td>
<td align="center">0.6055</td>
<td align="center">0.5872</td>
<td align="center">0.5956</td>
<td align="center">0.5903</td>
<td align="center">0.5937</td>
<td align="center">0.5921</td>
<td align="center">0.5929</td>
</tr>
<tr>
<td align="center">WQU的p*</td>
<td align="center">0.5846</td>
<td align="center">0.5929</td>
<td align="center">0.5877</td>
<td align="center">0.5923</td>
<td align="center">0.5917</td>
<td align="center">0.5915</td>
<td align="center">0.592</td>
</tr>
</tbody></table>
<blockquote>
<p>CPU: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz   1.80 GHz with 8GB RAM</p>
<p>OS: Windows 10 64位</p>
</blockquote>
<p><img src="/images/algs4/image-20211226142031488.png" srcset="/img/loading.gif" lazyload></p>
<p>通过总结可以明显看出，在N极小的时候，两种算法的区别并不大，甚至当N=10，T=100时QF略快一筹。考虑其算法，此结果应该时由于WQU算法有额外数组的生成所导致的。</p>
<p>当N逐渐增大时，WQU加权的优化便明显体现出来了。在N=80时便已经有10倍的差距，在N=200时甚至达到了近90倍的差距。</p>
<p>最后根据两种方法求得的阈值进行加权平均，解得题目对应的阈值 p*=0.5925</p>
<p><strong>总结</strong></p>
<p>实际进行实验时，在逐渐加大N值时也明显感受到QF变得非常的缓慢，WQU的结果很快便出来了，QF却一直没出现，一度以为应用程序是否停止响应了。WQU这个优化虽然看上去不大，仅仅加了一个数组和一点实现，但最终呈现出来的速度差距竟然如此之大，使用正确的数据结构以及更快的算法才能得到更好的程序，受益匪浅。</p>
<hr>
<h2 id="几种排序算法的实验性能比较"><a href="#几种排序算法的实验性能比较" class="headerlink" title="几种排序算法的实验性能比较"></a>几种排序算法的实验性能比较</h2><h3 id="一、实验目的-1"><a href="#一、实验目的-1" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>通过对多种排序算法的实现，针对不同输入规模的数据进行实验，比 较各种排序算法的时间性能。</p>
<h3 id="二、题目描述-1"><a href="#二、题目描述-1" class="headerlink" title="二、题目描述"></a>二、题目描述</h3><p>实现插入排序（Insertion Sort，IS），自顶向下归并排序（Top-down Mergesort，TDM），自底向上归并排序（Bottom-up Mergesort，BUM），随机快速排序（Random Quicksort，RQ），Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）。</p>
<h3 id="三、解决方法-1"><a href="#三、解决方法-1" class="headerlink" title="三、解决方法"></a>三、解决方法</h3><p>在你的计算机上针对<strong>不同输入规模数据</strong>进行实验，对比上述排序算法的时间性能。要求对于每次输入运行10次，记录每次时间，取平均值。</p>
<h3 id="四、算法及解释-1"><a href="#四、算法及解释-1" class="headerlink" title="四、算法及解释"></a>四、算法及解释</h3><ol>
<li><p>插入排序 Insertion_Sort </p>
<p>不断插入一个数，并保持其已插入的数有序。也因为是直接插入，所以可以保持其稳定性，并且为原地排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>    <span class="hljs-keyword">int</span> key = arr[j];<br>    <span class="hljs-keyword">int</span> i = j<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[i] &gt; key) &#123;<br>        arr[i+<span class="hljs-number">1</span>] = arr[i];<br>        i--;<br>    &#125;<br>    arr[i+<span class="hljs-number">1</span>] = key;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>自顶向下归并排序 Top-down Mergesort<br>自定向下的归并排序是逐渐递归的过程，因为使用了辅助数组，所以不是原地排序，但因为处理时对一分为二两个数组merge时的操作，所以保持了稳定性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cutSortArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> array[],<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span>&#123;<br>	<span class="hljs-comment">//分割数组，一分为2，二分为四，，，</span><br>	<span class="hljs-keyword">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">if</span> (low &lt; high)&#123;<br>		<span class="hljs-built_in">cutSortArray</span>(array, low, mid);<br>		<span class="hljs-built_in">cutSortArray</span>(array, mid + <span class="hljs-number">1</span>, high);<br>		<span class="hljs-built_in">merge</span>(array, low, mid, high);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p> 自底向上归并排序 Bottom-up Mergesort</p>
</li>
</ol>
<p>   自底向上归并排序是一个迭代的过程，通过不断增加size的的大小来进行排序。其他与上同理，是稳定的排序方法。</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BottomUp_Mergesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> array[], <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>    <span class="hljs-comment">// merge_length 由 1 开始逐步倍增</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> merge_length = <span class="hljs-number">1</span>; merge_length &lt; length; merge_length &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// start 为两个归并串开始的索引，一次增加两倍的 merge_length</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>; start &lt; length; start += merge_length &lt;&lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> first = start, first_tail = start + merge_length &lt; length ? start + merge_length : length;<br>            <span class="hljs-keyword">int</span> second = first_tail, second_tail = second + merge_length &lt; length ? second + merge_length : length;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 归并操作,两个序列均未取完，则先取小的</span><br>            <span class="hljs-keyword">while</span> (first &lt; first_tail &amp;&amp; second &lt; second_tail) &#123;<br>                tmp[i++] = array[first] &lt; array[second] ? array[first++] : array[second++];<br>            &#125;<br>            <span class="hljs-comment">// 存在一个序列已经取完，则将另一序列剩下的元素取尽</span><br>            <span class="hljs-keyword">while</span> (first &lt; first_tail) tmp[i++] = array[first++];<br>            <span class="hljs-keyword">while</span> (second &lt; second_tail) tmp[i++] = array[second++];<br>            <span class="hljs-comment">// 回填</span><br>            <span class="hljs-keyword">while</span> (--second_tail &gt;= start) array[second_tail] = tmp[--i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><p>随机快速排序 Random Quicksort</p>
<p>随机快排是在快排的基础上，为了避免完全逆序等特殊情况，首先将其打乱再进行排序的算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">RandomPivotPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> pvt, n, temp;<br>	n = <span class="hljs-built_in">rand</span>();<br>	pvt = low + n%(high-low+<span class="hljs-number">1</span>);<br>	<span class="hljs-built_in">swap</span>(a[high], a[pvt]);<br> <br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Partition</span>(a, low, high);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Random_Quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> pindex;<br>	<span class="hljs-keyword">if</span>(low &lt; high)<br>	&#123;<br>		pindex = <span class="hljs-built_in">RandomPivotPartition</span>(a, low, high);<br>		<span class="hljs-built_in">Random_Quicksort</span>(a, low, pindex<span class="hljs-number">-1</span>);<br>		<span class="hljs-built_in">Random_Quicksort</span>(a, pindex+<span class="hljs-number">1</span>, high);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Dijkstra 3-路划分快速排序 Quicksort with Dijkstra 3-way Partition</p>
<p>QD3P将数组分为三个部分，分别是&lt;v, =v, &gt;v的三项，然后从v作为分割轴开始左边自增，右边交换中进行自减</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span>&amp; i, <span class="hljs-keyword">int</span>&amp; j)</span></span><br><span class="hljs-function"></span>&#123;<br>    i = l - <span class="hljs-number">1</span>, j = r;<br>    <span class="hljs-keyword">int</span> p = l - <span class="hljs-number">1</span>, q = r;<br>    <span class="hljs-keyword">int</span> v = a[r];<br> <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">//首先找到大于等于v的值</span><br>        <span class="hljs-keyword">while</span> (a[++i] &lt; v)<br>            ;<br><br>        <span class="hljs-keyword">while</span> (v &lt; a[--j])<br>            <span class="hljs-keyword">if</span> (j == l)	<span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">if</span> (i &gt;= j)	<span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>        <span class="hljs-keyword">if</span> (a[i] == v) &#123;<br>            p++;<br>            <span class="hljs-built_in">swap</span>(a[p], a[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a[j] == v) &#123;<br>            q--;<br>            <span class="hljs-built_in">swap</span>(a[j], a[q]);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-built_in">swap</span>(a[i], a[r]);<br>    j = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt; p; k++, j--)<br>        <span class="hljs-built_in">swap</span>(a[k], a[j]);<br> <br>    i = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = r - <span class="hljs-number">1</span>; k &gt; q; k--, i++)<br>        <span class="hljs-built_in">swap</span>(a[i], a[k]);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QD_3Partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (r &lt;= l)	<span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-built_in">partition</span>(a, l, r, i, j);<br> <br>    <span class="hljs-built_in">QD_3Partition</span>(a, l, j);<br>    <span class="hljs-built_in">QD_3Partition</span>(a, i, r);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="五、实验结果-1"><a href="#五、实验结果-1" class="headerlink" title="五、实验结果"></a>五、实验结果</h3><p><strong>随机数列</strong></p>
<p><strong>Insertion_Sort</strong></p>
<p> N = 1000</p>
<p><img src="/images/algs4/image-20211225231812865.png" srcset="/img/loading.gif" lazyload></p>
<p>N = 10000</p>
<p><img src="/images/algs4/image-20211225231708477.png" srcset="/img/loading.gif" lazyload></p>
<p>N = 100000</p>
<p><img src="/images/algs4/image-20211225232313832.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>TopDown_Mergesort</strong></p>
<p>N = 1000</p>
<p><img src="/images/algs4/image-20211225232446880.png" srcset="/img/loading.gif" lazyload></p>
<p>N = 10000</p>
<p><img src="/images/algs4/image-20211225232528472.png" srcset="/img/loading.gif" lazyload></p>
<p>N = 100000</p>
<p><img src="/images/algs4/image-20211225232545226.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>BottomUp_Mergesort：</strong></p>
<p>N = 1000</p>
<p><img src="/images/algs4/image-20211225232922040.png" srcset="/img/loading.gif" lazyload></p>
<p>N = 10000</p>
<p><img src="/images/algs4/image-20211225233006554.png" srcset="/img/loading.gif" lazyload></p>
<p>N = 100000</p>
<p><img src="/images/algs4/image-20211225233036114.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>Random Quicksort</strong></p>
<p>N = 1000</p>
<p><img src="/images/algs4/image-20211225233209613.png" srcset="/img/loading.gif" lazyload></p>
<p>N = 10000</p>
<p><img src="/images/algs4/image-20211225233239226.png" srcset="/img/loading.gif" lazyload></p>
<p>N = 100000</p>
<p><img src="/images/algs4/image-20211225233413539.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>QD_3Partition</strong></p>
<p>N = 1000</p>
<p><img src="/images/algs4/image-20211225233549999.png" srcset="/img/loading.gif" lazyload></p>
<p>N = 10000</p>
<p><img src="/images/algs4/image-20211225233615498.png" srcset="/img/loading.gif" lazyload></p>
<p>N = 100000</p>
<p><img src="/images/algs4/image-20211225233641684.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>使用vector+sort</strong></p>
<p>N = 100000</p>
<p><img src="/images/algs4/image-20211226132801236.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>升序数列</strong></p>
<p><strong>Insertion_Sort</strong></p>
<p>N = 100000</p>
<p><img src="/images/algs4/image-20211226134407209.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>TopDown_Mergesort</strong></p>
<p>N = 100000</p>
<p><img src="/images/algs4/image-20211226134520903.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>BottomUp_Mergesort：</strong></p>
<p>N = 100000</p>
<p><img src="/images/algs4/image-20211226134707777.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>Random Quicksort</strong></p>
<p>N = 100000</p>
<p><img src="/images/algs4/image-20211226134830259.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>使用vector+sort</strong></p>
<p>N = 100000</p>
<p><img src="/images/algs4/image-20211226135256393.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="六、分析与总结-1"><a href="#六、分析与总结-1" class="headerlink" title="六、分析与总结"></a>六、分析与总结</h3><p><strong>随机数列</strong></p>
<p>N = 100000，Comparison of running time of sorting algorithms (in Micro Seconds)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Run2</th>
<th align="center">Run3</th>
<th align="center">Run4</th>
<th align="center">Run5</th>
<th align="center">Run6</th>
<th align="center">Run1</th>
<th>Run7</th>
<th align="center">Run8</th>
<th align="center">Run9</th>
<th align="center">Run10</th>
<th align="center">Average</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IS</td>
<td align="center">22.176</td>
<td align="center">23.255</td>
<td align="center">23.2</td>
<td align="center">22.964</td>
<td align="center">22.174</td>
<td align="center">22.376</td>
<td>24.074</td>
<td align="center">25.045</td>
<td align="center">24.479</td>
<td align="center">22.741</td>
<td align="center">23.2484</td>
</tr>
<tr>
<td align="center">TDM</td>
<td align="center">0.096</td>
<td align="center">0.103</td>
<td align="center">0.097</td>
<td align="center">0.098</td>
<td align="center">0.102</td>
<td align="center">0.117</td>
<td>0.095</td>
<td align="center">0.095</td>
<td align="center">0.0109</td>
<td align="center">0.107</td>
<td align="center">0.1019</td>
</tr>
<tr>
<td align="center">BUM</td>
<td align="center">0.06</td>
<td align="center">0.063</td>
<td align="center">0.061</td>
<td align="center">0.063</td>
<td align="center">0.066</td>
<td align="center">0.061</td>
<td>0.063</td>
<td align="center">0.066</td>
<td align="center">0.059</td>
<td align="center">0.06</td>
<td align="center">0.0622</td>
</tr>
<tr>
<td align="center">RQ</td>
<td align="center">0.087</td>
<td align="center">0.084</td>
<td align="center">0.074</td>
<td align="center">0.072</td>
<td align="center">0.07</td>
<td align="center">0.071</td>
<td>0.069</td>
<td align="center">0.071</td>
<td align="center">0.076</td>
<td align="center">0.078</td>
<td align="center">0.0752</td>
</tr>
<tr>
<td align="center">QD3P</td>
<td align="center">0.053</td>
<td align="center">0.061</td>
<td align="center">0.052</td>
<td align="center">0.057</td>
<td align="center">0.058</td>
<td align="center">0.054</td>
<td>0.055</td>
<td align="center">0.055</td>
<td align="center">0.058</td>
<td align="center">0.057</td>
<td align="center">0.056</td>
</tr>
<tr>
<td align="center">sort</td>
<td align="center">0.028</td>
<td align="center">0.028</td>
<td align="center">0.028</td>
<td align="center">0.027</td>
<td align="center">0.027</td>
<td align="center">0.034</td>
<td>0.028</td>
<td align="center">0.027</td>
<td align="center">0.028</td>
<td align="center">0.028</td>
<td align="center">0.0283</td>
</tr>
</tbody></table>
<blockquote>
<p>CPU: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz   1.80 GHz with 8GB RAM</p>
<p>OS: Windows 10 64位</p>
</blockquote>
<p><strong>升序数列</strong></p>
<p>N = 100000，Comparison of running time of sorting algorithms (in Micro Seconds)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Run1</th>
<th align="center">Run2</th>
<th align="center">Run3</th>
<th align="center">Run4</th>
<th align="center">Run5</th>
<th align="center">Run6</th>
<th align="center">Run7</th>
<th align="center">Run8</th>
<th align="center">Run9</th>
<th align="center">Run10</th>
<th align="center">Average</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IS</td>
<td align="center">0</td>
<td align="center">0.001</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0.001</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0.001</td>
<td align="center">0</td>
<td align="center">0.0003</td>
</tr>
<tr>
<td align="center">TDM</td>
<td align="center">0.018</td>
<td align="center">0.016</td>
<td align="center">0.016</td>
<td align="center">0.016</td>
<td align="center">0.015</td>
<td align="center">0.017</td>
<td align="center">0.015</td>
<td align="center">0.016</td>
<td align="center">0.015</td>
<td align="center">0.015</td>
<td align="center">0.0159</td>
</tr>
<tr>
<td align="center">BUM</td>
<td align="center">0.009</td>
<td align="center">0.01</td>
<td align="center">0.008</td>
<td align="center">0.01</td>
<td align="center">0.007</td>
<td align="center">0.011</td>
<td align="center">0.011</td>
<td align="center">0.009</td>
<td align="center">0.01</td>
<td align="center">0.009</td>
<td align="center">0.0094</td>
</tr>
<tr>
<td align="center">RQ</td>
<td align="center">0.016</td>
<td align="center">0.013</td>
<td align="center">0.014</td>
<td align="center">0.013</td>
<td align="center">0.013</td>
<td align="center">0.013</td>
<td align="center">0.013</td>
<td align="center">0.014</td>
<td align="center">0.013</td>
<td align="center">0.016</td>
<td align="center">0.0138</td>
</tr>
<tr>
<td align="center">sort</td>
<td align="center">0.017</td>
<td align="center">0.016</td>
<td align="center">0.017</td>
<td align="center">0.017</td>
<td align="center">0.017</td>
<td align="center">0.017</td>
<td align="center">0.016</td>
<td align="center">0.017</td>
<td align="center">0.017</td>
<td align="center">0.017</td>
<td align="center">0.0168</td>
</tr>
</tbody></table>
<blockquote>
<p>CPU: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz   1.80 GHz with 8GB RAM</p>
<p>OS: Windows 10 64位</p>
</blockquote>
<p>排序算法是唯一实验中使用c++的一次实验，因为一直很好奇在大规模数据的处理中，数组和vector对于数据的影响到底有多大，所以五种排序算法我首先都使用了数组的形式来完成，虽然预想之内，纯数组的实现会比vector和Java快很多，但没想到会快这么多…初次进行测试的时候甚至怀疑了代码的正确性，尝试打印数组查看后发现成功完成排序操作。</p>
<p>而由于没有算上vector和数组初始化的时间，仅通过直接调用algorithm库中的函数，通过查询<a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/algorithm/sort/">sort</a>在c++官网上的定义，发现其不具备稳定性，并且大约为N*log2(N)次元素的比较。为何使用vector会比数组快，得出本次结果应该是因为在测试时我没有将初始化数组和初始化vector的时间加入一起计算，仅计算了算法本身的运行时间，按理论来说，vector+sort会比使用数组直接进行排序慢很多。</p>
<p>回答以下问题：</p>
<ol>
<li>Which sort worked best on data in constant or increasing order (i.e., already sorted data)? Why do you think this sort worked best?</li>
</ol>
<p>插入排序在正向有序时表现最好，此时无需插入数据，算法复杂度为O(n)</p>
<ol start="2">
<li>Did the same sort do well on the case of mostly sorted data? Why or why not?</li>
</ol>
<p>插入排序在正向基本有序时表现仍然很好，因为算法中基本无需向有序序列中插入，只在尾部添加</p>
<ol start="3">
<li>In general, did the ordering of the incoming data affect the performance of the sorting algorithms? Please answer this question by referencing specific data from your table to support your answer.</li>
</ol>
<p>数据的次序对归并排序影响很小，对IS、RQ和QD3P影响很大</p>
<ul>
<li><p>正向有序时，IS复杂度为O(n)，RQ和QD3P复杂度为O(n^2)</p>
</li>
<li><p>反向有序时，IS复杂度为O(n)，RQ和QD3P复杂度都为O(n^2)</p>
</li>
</ul>
<p>归并排序始终维持O(nlogn)</p>
<ol start="4">
<li>Which sort did best on the shorter (i.e., <em>n</em> = 1,000) data sets? Did the same one do better on the longer (i.e., <em>n</em> = 10,000) data sets? Why or why not? Please use specific data from your table to support your answer.</li>
</ol>
<p>在随机数据中QD3P表现最好，因为QD3P判断和交换次数少，也解决了快速排序在大量重复数据时表现不好的问题</p>
<ol start="5">
<li>In general, which sort did better? Give a hypothesis as to why the difference in performance exists.</li>
</ol>
<p>QD3P表现的最好，插入排序比较和交换过多，没有充分利用数据间已存在的大小关系，归并排序无视已有的大小关系，所以时间复杂度稳定，快速排序由于有随机化的步骤，所以消耗更多时间</p>
<ol start="6">
<li>Are there results in your table that seem to be inconsistent? (e.g., If I get run times for a sort that look like this {1.3, 1.5, 1.6, 7.0, 1.2, 1.6, 1.4, 1.8, 2.0, 1.5] the 7.0 entry is not consistent with the rest). Why do you think this happened?</li>
</ol>
<p>​    在运行程序时如果同时让CPU占用率始终保持100%则由于操作系统调度可能导致程序分到的时间片过少，需要使用更长的实际时间才能完成排序</p>
<hr>
<h2 id="地图路由（Map-Routing）"><a href="#地图路由（Map-Routing）" class="headerlink" title="地图路由（Map Routing）"></a>地图路由（Map Routing）</h2><h3 id="一、实验目的-2"><a href="#一、实验目的-2" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>实现经典的Dijkstra最短路径算法，并对其进行优化。 这种算法广泛应用于地理信息系统（GIS），包括MapQuest和基于GPS的汽车导航系统。</p>
<h3 id="二、题目描述-2"><a href="#二、题目描述-2" class="headerlink" title="二、题目描述"></a>二、题目描述</h3><p><strong>地图。</strong> 本次实验对象是图maps或graphs，其中顶点为平面上的点，这些点由权值为欧氏距离的边相连成图。 可将顶点视为城市，将边视为相连的道路。 为了在文件中表示地图，我们列出了顶点数和边数，然后列出顶点（索引后跟其x和y坐标），然后列出边（顶点对），最后列出源点和汇点。 例如，如下左图信息表示右图：</p>
<p><img src="/images/algs4/image-20211225151732144.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>Dijkstra算法</strong>。 Dijkstra算法是最短路径问题的经典解决方案。 它在教科书第21章中有描述。 基本思路不难理解。 对于图中的每个顶点，我们维护从源点到该顶点的最短已知的路径长度，并且将这些长度保持在优先队列（<em>priority queue</em>, <em>PQ</em>）中。 初始时，我们把所有的顶点放在这个队列中，并设置高优先级，然后将源点的优先级设为<strong>0.0</strong>。 算法通过从<em>PQ</em>中<strong>取出最低优先级的顶点</strong>，然后检查可从该顶点经由一条边可达的所有顶点，以<strong>查看这条边是否提供了从源点到那个顶点较之之前已知的最短路径的更短路径。</strong> 如果是这样，它会降低优先级来反映这种新的信息。</p>
<p>这里给出了Dijkstra算法计算从0到5的最短路径0-1-2-5的详细过程。</p>
<p>process 0 (0.0)</p>
<p>​    lower 3 to 3841.9</p>
<p>​    lower 1 to 1897.4</p>
<p>process 1 (1897.4)</p>
<p>​    lower 4 to 3776.2</p>
<p>​    lower 2 to 2537.7</p>
<p>process 2 (2537.7)</p>
<p>​    lower 5 to 6274.0</p>
<p>process 4 (3776.2)</p>
<p>process 3 (3841.9)</p>
<p>process 5 (6274.0)</p>
<p>该方法计算最短路径的长度。 为了记录路径，我们还<strong>保持每个顶点的源点到该顶点最短路径上的前驱</strong>。 文件Euclidean Graph.java，Point.java，IndexPQ.java，IntIterator.java和Dijkstra.java提供了针对map的Dijkstra算法的基本框架实现，你应该以此作为起点。 客户端程序ShortestPath.java求解一个单源点最短路径问题，并使用图形绘制了结果。 客户端程序Paths.java求解了许多最短路径问题，并将最短路径打印到标准输出。 客户端程序Distances.java求解了许多最短路径问题，仅将距离打印到标准输出。</p>
<h3 id="三、解决方法-2"><a href="#三、解决方法-2" class="headerlink" title="三、解决方法"></a>三、解决方法</h3><p><strong>目标。 优化Dijkstra算法，使其可以处理给定图的数千条最短路径查询。</strong> 一旦你读取图（并可选地预处理），你的程序应该在亚线性时间内解决最短路径问题。 一种方法是预先计算出所有顶点对的最短路径；然而，你无法承受存储所有这些信息所需的二次空间。 你的目标是减少每次最短路径计算所涉及的工作量，而不会占用过多的空间。 建议你选择下面的一些潜在想法来实现， 或者你可以开发和实现自己的想法。</p>
<p><strong>想法1</strong>. <strong>Dijkstra算法的朴素实现检查图中的所有V个顶点。</strong> 减少检查的顶点数量的一种策略是一旦发现目的地的最短路径就停止搜索。 通过这种方法，可以使每个最短路径查询的运行时间与<em>E</em>‘ log <em>V</em>‘成比例，其中<em>E</em>‘和<em>V</em>‘是Dijkstra算法检查的边和顶点数。 然而，这需要一些小心，因为只是重新初始化所有距离为∞就需要与<em>V</em>成正比的时间。由于你在不断执行查询，因而只需重新初始化在先前查询中改变的那些值来大大加速查询。</p>
<p><strong>想法*2</strong>. <strong>你可以利用问题的欧式几何来进一步减少搜索时间</strong>，这在算法书的第21.5节描述过。对于一般图，Dijkstra通过将d[w]更新为d[v] + 从v到w的距离来松弛边v-w。 对于地图，则将d[w]更新为d[v] + 从v到w的距离 + 从w到d的欧式距离 - 从v到d的欧式距离。 这种方法称之为A*算法。这种启发式方法会有性能上的影响，但不会影响正确性。</p>
<p><strong>想法3</strong>. <strong>使用更快的优先队列。</strong> 在提供的优先队列中有一些优化空间。 你也可以考虑使用Sedgewick程序20.10中的多路堆。</p>
<p><strong>测试</strong>。 美国大陆文件<a href="ftp://ftp.cs.princeton.edu/pub/cs226/map/usa.txt"><code>usa.txt</code></a>包含87,575个交叉口和121,961条道路。 图形非常稀疏 - 平均的度为2.8。 你的主要目标应该是快速回答这个网络上的顶点对的最短路径查询。 你的算法可能会有不同执行时间，这取决于两个顶点是否在附近或相距较远。 我们提供测试这两种情况的输入文件。 你可以假设所有的<em>x</em>和<em>y</em>坐标都是0到10,000之间的整数。</p>
<h3 id="四、算法及解释-2"><a href="#四、算法及解释-2" class="headerlink" title="四、算法及解释"></a>四、算法及解释</h3><p>IndexPQ基本参考使用了algs4所提供的 IndexPQ.java，这里不再进行过多的阐述。</p>
<p><strong>构造Dijkstra类，并在其中进行三个想法的优化。</strong></p>
<ol>
<li>Dijkstra算法无法支持负权值的边，所以需对边的权值进行判断，若&lt;0，抛出异常    </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Edge e : G.edges()) &#123;<br>	<span class="hljs-keyword">if</span> (e.weight() &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;edge &quot;</span> + e + <span class="hljs-string">&quot; has negative weight&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>初始化时将distTo[]数组全部设为无穷大（初始时最短路径都为∞）。并将源点的优先级设为 0.0</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; G.V(); v++) &#123;<br>	distTo[v] = Double.POSITIVE_INFINITY;	<span class="hljs-comment">//初始化为无穷大</span><br>&#125;<br>distTo[s] = <span class="hljs-number">0.0</span>;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>不断取得pq中的点，并对其邻接边进行松弛。</li>
</ol>
<p><code>优化 1：</code><strong>一旦发现目的地的最短路径就停止搜索。</strong>当遍历pq时，一旦发现了汇点，立即停止搜索。就不需要将所有点到源点的最短路径都求出来，以此来进行优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>	<span class="hljs-keyword">int</span> v = pq.delMin();<br>	<span class="hljs-comment">//优化1：一旦发现目的地的最短路径就停止搜索</span><br>    <span class="hljs-keyword">if</span> (v == d)	<span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">for</span> (Edge e : G.adj(v)) &#123;<br>    	relax(e, v, Nodes, d); <span class="hljs-comment">//对邻近点进行松弛</span><br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>边的松弛中，引入A*算法来进行优化</li>
</ol>
<p><code>优化 2:</code><strong>利用问题的欧式几何来进一步减少搜索时间</strong>；对于图来说，常将distTo[w] 更新为 distTo[v] +  v到w的距离。对于地图，将distTo看作s-&gt;v的最短距离+v-&gt;d的直接距离。相当于distTo不止考虑当前点到出发点的距离，也将考虑到目的地的距离。</p>
<p><img src="/images/algs4/image-20211225205912415.png" srcset="/img/loading.gif" lazyload></p>
<p><code>优化3：</code><strong>使用更快的优先队列。</strong>使用多路堆的方式来优化单路堆，使用教材源码IndexMultiwayMinPQ来代替初始化IndexPQ。没有进行单独实现，直接使用了algs4.jar</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> edu.princeton.cs.algs4.*;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dijkstra</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span>[] distTo;	<span class="hljs-comment">//length of shortest path : s-&gt;v</span><br>    <span class="hljs-keyword">private</span> Edge[] edgeTo;	<br><span class="hljs-comment">//    private IndexPQ pq;</span><br>    <span class="hljs-keyword">private</span> IndexMultiwayMinPQ&lt;Double&gt; pq;	<span class="hljs-comment">//优化3：使用更快的优先队列</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(EdgeWeightedGraph G, <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> d, <span class="hljs-keyword">double</span>[][] Nodes)</span><span class="hljs-comment">//初始化</span></span><br><span class="hljs-function">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">relax</span><span class="hljs-params">(Edge e, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">double</span>[][] Nodes, <span class="hljs-keyword">int</span> d)</span>			<span class="hljs-comment">//松弛边</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathTo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> 									<span class="hljs-comment">//判断目标节点是否可达</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> Iterable&lt;Edge&gt; <span class="hljs-title">pathTo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span>									<span class="hljs-comment">//遍历边</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>构造MapRouting类</strong>，进行usa.txt的读取，读入点和边的信息，并进行结果的输出。</p>
<ol>
<li><p>不断用usa.txt中读入点和边的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读入点的坐标</span><br><span class="hljs-keyword">int</span> v;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pointCount; i++) &#123;<br>	v = in.readInt();<br>	Nodes[v][<span class="hljs-number">0</span>] = in.readDouble();	<span class="hljs-comment">//x</span><br>	Nodes[v][<span class="hljs-number">1</span>] = in.readDouble();	<span class="hljs-comment">//y</span><br>&#125;	<br><span class="hljs-comment">//读入边的信息       </span><br><span class="hljs-keyword">int</span> v1, v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edgeCount; i++) &#123;<br>	v1 = in.readInt();<br>	v2 = in.readInt();<br>	G.addEdge(<span class="hljs-keyword">new</span> Edge(v1, v2, Distance(v1, v2)));<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>设置distance函数来计算优化2中的欧式距离以及加边时存储的两点的距离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Distance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;<br>	<span class="hljs-keyword">double</span> x1 = Nodes[v1][<span class="hljs-number">0</span>], y1 = Nodes[v1][<span class="hljs-number">1</span>];<br>	<span class="hljs-keyword">double</span> x2 = Nodes[v2][<span class="hljs-number">0</span>], y2 = Nodes[v2][<span class="hljs-number">1</span>];<br>	<span class="hljs-keyword">return</span> Math.sqrt(Math.pow((x1-x2), <span class="hljs-number">2</span>) + Math.pow((y1-y2), <span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>输出源点和汇点的距离</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> edu.princeton.cs.algs4.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapRouting</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> EdgeWeightedGraph G;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span>[][] Nodes;	<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getGraph</span><span class="hljs-params">(In in)</span>				<span class="hljs-comment">//读入usa.txt，初始化点和边</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Distance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span>	<span class="hljs-comment">//得到两点之间的距离</span></span><br><span class="hljs-function">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>			<span class="hljs-comment">//输出测试结果</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="五、实验结果-2"><a href="#五、实验结果-2" class="headerlink" title="五、实验结果"></a>五、实验结果</h3><p>未优化版本：</p>
<p><img src="/images/algs4/map1.png" srcset="/img/loading.gif" lazyload></p>
<p>优化1：</p>
<p><img src="/images/algs4/map2.png" srcset="/img/loading.gif" lazyload></p>
<p>优化2：</p>
<p><img src="/images/algs4/map3.jpg" srcset="/img/loading.gif" lazyload></p>
<p>优化3：</p>
<p><img src="/images/algs4/19DD17838CE46200EAA147CAA44A520D.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="六、分析与总结-2"><a href="#六、分析与总结-2" class="headerlink" title="六、分析与总结"></a>六、分析与总结</h3><table>
<thead>
<tr>
<th>算法种类</th>
<th>初始算法</th>
<th>优化1</th>
<th>优化2</th>
<th>优化3</th>
</tr>
</thead>
<tbody><tr>
<td>时间</td>
<td>0.399s</td>
<td>0.332s</td>
<td>0.173s</td>
<td>0.24s</td>
</tr>
</tbody></table>
<blockquote>
<p> CPU: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz   1.80 GHz with 8GB RAM</p>
<p>OS: Windows 10 64位</p>
</blockquote>
<p>本次测试的数据为0-&gt;10000的最短路径。能从数据看出，进行优化1后，能明显感受到运行速度变快，因为其本质没有使用新的数据结构，通过减少计算次数来优化算法，所以时间减少明显。对于优化2来说，优化了一倍左右的时间，这是由于采用了Dijkstra算法的优化，A*算法，在松弛边时有着很大的提升。而对于优化3，在0-&gt;10000这个测试中没有完全发挥出其优势，由于距离不够长，所以导致其耗时比优化2略高一点，但理论来说，大规模地图数据应为优化3最佳，但0-&gt;10000的略低了一些，所以有了此结果。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AE%9E%E9%AA%8C/">实验</a>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/c/">c++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/31/2021/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">边缘计算在物联网领域的应用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/04/2021/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%20%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB/">
                        <span class="hidden-mobile">代码整洁之道 程序员的职业素养</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"jsonPath":"/null"},"log":false});</script></body>
</html>
